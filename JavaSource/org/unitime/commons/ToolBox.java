begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.1 (University Timetabling Application)  * Copyright (C) 2008, UniTime LLC, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program; if not, write to the Free Software Foundation, Inc.,  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|commons
package|;
end_package

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_comment
comment|/**   * This class provides several static functions from different areas.  * @author Tomas Muller  */
end_comment

begin_class
specifier|public
class|class
name|ToolBox
block|{
comment|/** Replaces all occurances of a substring in a string. 	 * @param source source string 	 * @param substring substring 	 * @param newsubstring replacement for substring 	 * @return string with replacements 	 */
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|substring
parameter_list|,
name|String
name|newsubstring
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len1
init|=
name|substring
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|len2
init|=
name|newsubstring
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|idx
operator|=
operator|(
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|indexOf
argument_list|(
name|substring
argument_list|,
name|idx
argument_list|)
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|idx
argument_list|,
name|idx
operator|+
name|len1
argument_list|,
name|newsubstring
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|len2
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Replaces all occurances of a substring in a string -- ignores cases of strings. 	 * @param source source string 	 * @param substring substring 	 * @param newsubstring replacement for substring 	 * @return string with replacements 	 */
specifier|public
specifier|static
name|String
name|replaceIgnoreCase
parameter_list|(
name|String
name|source
parameter_list|,
name|String
name|substring
parameter_list|,
name|String
name|newsubstring
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len1
init|=
name|substring
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|len2
init|=
name|newsubstring
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|idx
operator|=
operator|(
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|indexOf
argument_list|(
name|substring
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|idx
argument_list|)
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|sb
operator|.
name|replace
argument_list|(
name|idx
argument_list|,
name|idx
operator|+
name|len1
argument_list|,
name|newsubstring
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|len2
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Expand a string into the required length by adding a given character at the begining or at the end of the string. 	 * @param source source string 	 * @param length desired length 	 * @param ch character to be added 	 * @param beg if true character ch is repeatedly added at the beginning of the string. If false at the end of the string. 	 * @return desired string 	 */
specifier|public
specifier|static
name|String
name|expand
parameter_list|(
name|String
name|source
parameter_list|,
name|int
name|length
parameter_list|,
name|char
name|ch
parameter_list|,
name|boolean
name|beg
parameter_list|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|source
operator|==
literal|null
condition|?
literal|""
else|:
name|source
operator|.
name|length
argument_list|()
operator|>
name|length
condition|?
operator|(
name|beg
condition|?
name|source
operator|.
name|substring
argument_list|(
name|source
operator|.
name|length
argument_list|()
operator|-
name|length
argument_list|)
else|:
name|source
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|length
argument_list|)
operator|)
else|:
name|source
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|beg
condition|)
block|{
name|sb
operator|.
name|insert
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Return caller (name of class which call the method from which this method was called) - for debug. 	 * @return caller class 	 */
specifier|public
specifier|static
name|String
name|getCaller
parameter_list|()
block|{
return|return
name|getCaller
argument_list|(
literal|4
argument_list|)
return|;
block|}
comment|/** Return caller class name. 	 * @param depth depth (1 .. ToolBox, 2 .. class which called ToolBox.getCaller, 3 .. class which called the caller class, ... ) 	 * @return caller class 	 */
specifier|public
specifier|static
name|String
name|getCaller
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
try|try
block|{
throw|throw
operator|new
name|Exception
argument_list|()
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
try|try
block|{
name|StackTraceElement
name|trace
init|=
name|e
operator|.
name|getStackTrace
argument_list|()
index|[
name|depth
operator|-
literal|1
index|]
decl_stmt|;
return|return
name|trace
operator|.
name|getClassName
argument_list|()
operator|+
literal|"."
operator|+
name|trace
operator|.
name|getMethodName
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
block|}
block|}
return|return
literal|"unknown"
return|;
block|}
comment|/** Sort enumeration 	 * @param e an enumeration 	 * @return sorted enumeration 	 */
specifier|public
specifier|static
name|Enumeration
name|sortEnumeration
parameter_list|(
name|java
operator|.
name|util
operator|.
name|Enumeration
name|e
parameter_list|)
block|{
return|return
name|sortEnumeration
argument_list|(
name|e
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Sort enumeration 	 * @param e an enumeration 	 * @param c comparator of two objects in enumeration e 	 * @return sorted enumeration 	 */
specifier|public
specifier|static
name|Enumeration
name|sortEnumeration
parameter_list|(
name|java
operator|.
name|util
operator|.
name|Enumeration
name|e
parameter_list|,
name|java
operator|.
name|util
operator|.
name|Comparator
name|c
parameter_list|)
block|{
name|Vector
name|v
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|v
operator|.
name|addElement
argument_list|(
name|e
operator|.
name|nextElement
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|v
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|elements
argument_list|()
return|;
block|}
comment|/** 	 * Return true if two Strings are different 	 * @param a 	 * @param b 	 * @return boolean 	 */
specifier|public
specifier|static
name|boolean
name|diff
parameter_list|(
name|String
name|a
parameter_list|,
name|String
name|b
parameter_list|)
block|{
name|boolean
name|ret
init|=
operator|!
operator|(
name|a
operator|==
literal|null
condition|?
name|b
operator|==
literal|null
condition|?
literal|true
else|:
literal|false
else|:
name|b
operator|==
literal|null
condition|?
literal|false
else|:
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: '"
operator|+
name|a
operator|+
literal|"' with '"
operator|+
name|b
operator|+
literal|"'"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/** 	 * Return true if two Vectors are different 	 * @param a 	 * @param b 	 * @return boolean 	 */
specifier|public
specifier|static
name|boolean
name|diff
parameter_list|(
name|Vector
name|a
parameter_list|,
name|Vector
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|b
operator|==
literal|null
condition|?
literal|false
else|:
literal|true
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a
operator|.
name|size
argument_list|()
operator|!=
name|b
operator|.
name|size
argument_list|()
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: size"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|a
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|oa
init|=
name|a
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Object
name|ob
init|=
name|b
operator|.
name|elementAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oa
operator|.
name|equals
argument_list|(
name|ob
argument_list|)
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: "
operator|+
name|oa
operator|+
literal|" with "
operator|+
name|ob
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** 	 * Return true if two Hashtables are different 	 * @param a 	 * @param b 	 * @return boolean 	 */
specifier|public
specifier|static
name|boolean
name|diff
parameter_list|(
name|Hashtable
name|a
parameter_list|,
name|Hashtable
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return
operator|(
name|b
operator|==
literal|null
condition|?
literal|false
else|:
literal|true
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|a
operator|.
name|size
argument_list|()
operator|!=
name|b
operator|.
name|size
argument_list|()
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: size"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
for|for
control|(
name|Enumeration
name|e
init|=
name|a
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|keya
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Object
name|keyb
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|containsKey
argument_list|(
name|keya
argument_list|)
condition|)
block|{
comment|// hashCode differs but try to find it
for|for
control|(
name|Enumeration
name|eb
init|=
name|b
operator|.
name|keys
argument_list|()
init|;
name|keyb
operator|==
literal|null
operator|&&
name|eb
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|key
init|=
name|eb
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|keya
argument_list|)
condition|)
block|{
name|keyb
operator|=
name|key
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|keyb
operator|=
name|keya
expr_stmt|;
block|}
if|if
condition|(
name|keyb
operator|==
literal|null
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: key "
operator|+
name|keya
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Object
name|oa
init|=
name|a
operator|.
name|get
argument_list|(
name|keya
argument_list|)
decl_stmt|;
name|Object
name|ob
init|=
name|b
operator|.
name|get
argument_list|(
name|keyb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oa
operator|.
name|equals
argument_list|(
name|ob
argument_list|)
condition|)
block|{
name|Debug
operator|.
name|log
argument_list|(
literal|"  diff: "
operator|+
name|oa
operator|+
literal|" with "
operator|+
name|ob
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** This class is used by getCaller method, it reads i-th line of output stream. 	 */
specifier|private
specifier|static
class|class
name|LineOutputStream
extends|extends
name|java
operator|.
name|io
operator|.
name|OutputStream
block|{
comment|/** buffer */
name|StringBuffer
name|iBuffer
init|=
literal|null
decl_stmt|;
comment|/** line to be read */
name|int
name|iLine
init|=
literal|0
decl_stmt|;
comment|/** line counter */
name|int
name|iCurLine
init|=
literal|0
decl_stmt|;
comment|/** It create an instance of LineOutputStream. 		 * @param line line to be read 		 */
specifier|public
name|LineOutputStream
parameter_list|(
name|int
name|line
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|iLine
operator|=
name|line
expr_stmt|;
name|iBuffer
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
block|}
comment|/** Writes a byte to stream 		 * @param b a byte 		 */
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|b
operator|==
literal|'\n'
condition|)
block|{
name|iCurLine
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iLine
operator|==
name|iCurLine
condition|)
block|{
name|iBuffer
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Closes the stream 		 */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Returns read line 		 * @param read line 		 */
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|iBuffer
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
block|}
comment|/** 	 * This function constructs the absolute path to the target folder 	 * by traversing up from the App URL till the target folder 	 * @param AppURL URL of the app 	 * @param targetFolder The folder for which path is to be obtained 	 * @return Absolute file path  	 */
specifier|public
specifier|synchronized
specifier|static
name|String
name|getBasePath
parameter_list|(
name|URL
name|appURL
parameter_list|,
name|String
name|targetFolder
parameter_list|)
block|{
comment|//Get file and parent
name|java
operator|.
name|io
operator|.
name|File
name|file
init|=
operator|new
name|java
operator|.
name|io
operator|.
name|File
argument_list|(
name|appURL
operator|.
name|getFile
argument_list|()
argument_list|)
decl_stmt|;
name|java
operator|.
name|io
operator|.
name|File
name|parent
init|=
name|file
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
comment|// Iterate up the folder structure till WEB-INF is encountered
while|while
condition|(
name|parent
operator|!=
literal|null
operator|&&
operator|!
name|parent
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|targetFolder
argument_list|)
condition|)
name|parent
operator|=
name|parent
operator|.
name|getParentFile
argument_list|()
expr_stmt|;
return|return
operator|(
name|parent
operator|!=
literal|null
condition|?
name|parent
operator|.
name|getAbsolutePath
argument_list|()
else|:
literal|null
operator|)
return|;
block|}
block|}
end_class

end_unit

