begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.1 (University Timetabling Application)  * Copyright (C) 2008, UniTime LLC, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program; if not, write to the Free Software Foundation, Inc.,  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|FlushMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|Hibernate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|LazyInitializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|Transaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|ApplicationProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|interfaces
operator|.
name|RoomAvailabilityInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|interfaces
operator|.
name|RoomAvailabilityInterface
operator|.
name|TimeBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Assignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Building
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|BuildingPref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|ClassInstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Class_
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|CourseOffering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|CourseOfferingReservation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DatePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Department
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DepartmentalInstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DistributionObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DistributionPref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|ExactTimeMins
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|InstrOfferingConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|InstructionalOffering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|LastLikeCourseDemand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|PreferenceLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Room
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomFeaturePref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomGroupPref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomPref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomSharingModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|SchedulingSubpart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Session
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Solution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|SolverGroup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|SubjectArea
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|TimePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|TimePatternModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|TimePref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|comparators
operator|.
name|ClassComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|AssignmentDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|Class_DAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|LocationDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|SessionDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|SolutionDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|SolverGroupDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|TimetableManagerDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|remote
operator|.
name|core
operator|.
name|RemoteSolverServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|util
operator|.
name|DateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|util
operator|.
name|RoomAvailability
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|TimetableLoader
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|ClassLimitConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|DepartmentSpreadConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|DiscouragedRoomConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|GroupConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|InstructorConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|JenrlConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|MinimizeNumberOfUsedGroupsOfTime
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|MinimizeNumberOfUsedRoomsConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|RoomConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|constraint
operator|.
name|SpreadConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|InitialSectioning
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Lecture
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Placement
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|RoomLocation
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Student
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimeLocation
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimetableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|preference
operator|.
name|MinMaxPreferenceCombination
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|preference
operator|.
name|PreferenceCombination
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|preference
operator|.
name|SumPreferenceCombination
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|model
operator|.
name|Constraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|model
operator|.
name|Value
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|FastVector
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|Progress
import|;
end_import

begin_comment
comment|/**  * @author Tomas Muller  */
end_comment

begin_class
specifier|public
class|class
name|TimetableDatabaseLoader
extends|extends
name|TimetableLoader
block|{
specifier|private
specifier|static
name|Log
name|sLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TimetableDatabaseLoader
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Session
name|iSession
decl_stmt|;
specifier|private
name|Long
name|iSessionId
decl_stmt|;
specifier|private
name|Long
index|[]
name|iSolverGroupId
decl_stmt|;
specifier|private
name|String
name|iSolverGroupIds
decl_stmt|;
specifier|private
name|String
name|iDepartmentIds
init|=
literal|null
decl_stmt|;
specifier|private
name|SolverGroup
index|[]
name|iSolverGroup
decl_stmt|;
specifier|private
name|Long
index|[]
name|iSolutionId
decl_stmt|;
specifier|private
name|Hashtable
name|iRooms
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iInstructors
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iLectures
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iSubparts
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iStudents
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iDeptNames
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iPatterns
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
name|iClasses
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
specifier|private
name|Set
name|iAllUsedDatePatterns
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
specifier|private
name|Set
name|iAllClasses
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|iDeptBalancing
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iMppAssignment
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iInteractiveMode
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|iSpread
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iAutoSameStudents
init|=
literal|true
decl_stmt|;
specifier|private
name|double
name|iFewerSeatsDisouraged
init|=
literal|0.01
decl_stmt|;
specifier|private
name|double
name|iFewerSeatsStronglyDisouraged
init|=
literal|0.02
decl_stmt|;
specifier|private
name|double
name|iNormalizedPrefDecreaseFactor
init|=
name|TimePatternModel
operator|.
name|sDefaultDecreaseFactor
decl_stmt|;
specifier|private
name|double
name|iAlterTimePatternWeight
init|=
literal|0.0
decl_stmt|;
specifier|private
name|TimePatternModel
name|iAlterTimePatternModel
init|=
operator|(
name|TimePatternModel
operator|)
name|TimePattern
operator|.
name|getDefaultRequiredTimeTable
argument_list|()
operator|.
name|getModel
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|iWeakenTimePreferences
init|=
literal|false
decl_stmt|;
specifier|private
name|Progress
name|iProgress
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|iStartDay
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|iEndDay
init|=
literal|0
decl_stmt|;
comment|//private Set iAvailableRooms = new HashSet();
specifier|private
name|boolean
name|iLoadStudentEnrlsFromSolution
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|iFixMinPerWeek
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|iAssignSingleton
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iIgnoreRoomSharing
init|=
literal|false
decl_stmt|;
specifier|private
name|String
name|iAutoSameStudentsConstraint
init|=
literal|"SAME_STUDENTS"
decl_stmt|;
specifier|private
name|String
name|iInstructorFormat
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|iRoomAvailabilityTimeStampIsSet
init|=
literal|false
decl_stmt|;
specifier|public
name|TimetableDatabaseLoader
parameter_list|(
name|TimetableModel
name|model
parameter_list|)
block|{
name|super
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|Progress
operator|.
name|sTraceEnabled
operator|=
literal|false
expr_stmt|;
name|iProgress
operator|=
name|Progress
operator|.
name|getInstance
argument_list|(
name|model
argument_list|)
expr_stmt|;
name|iSessionId
operator|=
name|model
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyLong
argument_list|(
literal|"General.SessionId"
argument_list|,
operator|(
name|Long
operator|)
literal|null
argument_list|)
expr_stmt|;
name|iSolverGroupId
operator|=
name|model
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyLongArry
argument_list|(
literal|"General.SolverGroupId"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|iSolutionId
operator|=
name|model
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyLongArry
argument_list|(
literal|"General.SolutionId"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|iIgnoreRoomSharing
operator|=
name|model
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.IgnoreRoomSharing"
argument_list|,
name|iIgnoreRoomSharing
argument_list|)
expr_stmt|;
name|iSolverGroupIds
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|iSolverGroupId
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|iSolverGroupIds
operator|+=
literal|","
expr_stmt|;
name|iSolverGroupIds
operator|+=
name|iSolverGroupId
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
name|iDeptBalancing
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.DeptBalancing"
argument_list|,
name|iDeptBalancing
argument_list|)
expr_stmt|;
name|iSpread
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.Spread"
argument_list|,
name|iSpread
argument_list|)
expr_stmt|;
name|iAutoSameStudents
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.AutoSameStudents"
argument_list|,
name|iAutoSameStudents
argument_list|)
expr_stmt|;
name|iMppAssignment
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.MPP"
argument_list|,
name|iMppAssignment
argument_list|)
expr_stmt|;
name|iInteractiveMode
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.InteractiveMode"
argument_list|,
name|iInteractiveMode
argument_list|)
expr_stmt|;
name|iAssignSingleton
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"General.AssignSingleton"
argument_list|,
name|iAssignSingleton
argument_list|)
expr_stmt|;
name|iFewerSeatsDisouraged
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyDouble
argument_list|(
literal|"Global.FewerSeatsDisouraged"
argument_list|,
name|iFewerSeatsDisouraged
argument_list|)
expr_stmt|;
name|iFewerSeatsStronglyDisouraged
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyDouble
argument_list|(
literal|"Global.FewerSeatsStronglyDisouraged"
argument_list|,
name|iFewerSeatsStronglyDisouraged
argument_list|)
expr_stmt|;
name|iNormalizedPrefDecreaseFactor
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyDouble
argument_list|(
literal|"General.NormalizedPrefDecreaseFactor"
argument_list|,
name|iNormalizedPrefDecreaseFactor
argument_list|)
expr_stmt|;
name|iLoadStudentEnrlsFromSolution
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"Global.LoadStudentEnrlsFromSolution"
argument_list|,
name|iLoadStudentEnrlsFromSolution
argument_list|)
expr_stmt|;
name|iFixMinPerWeek
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"Global.FixMinPerWeek"
argument_list|,
name|iFixMinPerWeek
argument_list|)
expr_stmt|;
name|iAlterTimePatternWeight
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyDouble
argument_list|(
literal|"TimePreferences.Weight"
argument_list|,
name|iAlterTimePatternWeight
argument_list|)
expr_stmt|;
name|iAlterTimePatternModel
operator|.
name|setPreferences
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"TimePreferences.Pref"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|iWeakenTimePreferences
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getPropertyBoolean
argument_list|(
literal|"TimePreferences.Weaken"
argument_list|,
name|iWeakenTimePreferences
argument_list|)
expr_stmt|;
name|iAutoSameStudentsConstraint
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"General.AutoSameStudentsConstraint"
argument_list|,
name|iAutoSameStudentsConstraint
argument_list|)
expr_stmt|;
name|iInstructorFormat
operator|=
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|getProperty
argument_list|(
literal|"General.InstructorFormat"
argument_list|,
name|DepartmentalInstructor
operator|.
name|sNameFormatLastFist
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|getClassLabel
parameter_list|(
name|Class_
name|clazz
parameter_list|)
block|{
return|return
literal|"<A href='classDetail.do?cid="
operator|+
name|clazz
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|"'>"
operator|+
name|clazz
operator|.
name|getClassLabel
argument_list|()
operator|+
literal|"</A>"
return|;
block|}
specifier|private
name|String
name|getClassLabel
parameter_list|(
name|Lecture
name|lecture
parameter_list|)
block|{
return|return
literal|"<A href='classDetail.do?cid="
operator|+
name|lecture
operator|.
name|getClassId
argument_list|()
operator|+
literal|"'>"
operator|+
name|lecture
operator|.
name|getName
argument_list|()
operator|+
literal|"</A>"
return|;
block|}
specifier|private
name|String
name|getOfferingLabel
parameter_list|(
name|InstructionalOffering
name|offering
parameter_list|)
block|{
return|return
literal|"<A href='instructionalOfferingDetail.do?io="
operator|+
name|offering
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|"'>"
operator|+
name|offering
operator|.
name|getCourseName
argument_list|()
operator|+
literal|"</A>"
return|;
block|}
specifier|private
name|String
name|getOfferingLabel
parameter_list|(
name|CourseOffering
name|offering
parameter_list|)
block|{
return|return
literal|"<A href='instructionalOfferingDetail.do?io="
operator|+
name|offering
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|"'>"
operator|+
name|offering
operator|.
name|getCourseName
argument_list|()
operator|+
literal|"</A>"
return|;
block|}
specifier|private
name|String
name|getSubpartLabel
parameter_list|(
name|SchedulingSubpart
name|subpart
parameter_list|)
block|{
name|String
name|suffix
init|=
name|subpart
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
decl_stmt|;
return|return
literal|"<A href='schedulingSubpartDetail.do?ssuid="
operator|+
name|subpart
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|"'>"
operator|+
name|subpart
operator|.
name|getCourseName
argument_list|()
operator|+
literal|" "
operator|+
name|subpart
operator|.
name|getItypeDesc
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
operator|(
name|suffix
operator|==
literal|null
operator|||
name|suffix
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|" ("
operator|+
name|suffix
operator|+
literal|")"
operator|)
operator|+
literal|"</A>"
return|;
block|}
specifier|private
name|Hashtable
name|iRoomPreferences
init|=
literal|null
decl_stmt|;
specifier|private
name|PreferenceLevel
name|getRoomPreference
parameter_list|(
name|Long
name|deptId
parameter_list|,
name|Long
name|locationId
parameter_list|)
block|{
comment|/**FOR TESTING       	if (locationId.intValue()==3798) return PreferenceLevel.getPreferenceLevel(PreferenceLevel.sStronglyDiscouraged); //BRNG B222     	if (locationId.intValue()==3852) return PreferenceLevel.getPreferenceLevel(PreferenceLevel.sStronglyDiscouraged); //ME 118     	if (locationId.intValue()==3713) return PreferenceLevel.getPreferenceLevel(PreferenceLevel.sStronglyDiscouraged); //CIVL 2108     	*/
if|if
condition|(
name|iRoomPreferences
operator|==
literal|null
condition|)
block|{
name|iRoomPreferences
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|j
init|=
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Department
name|department
init|=
operator|(
name|Department
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hashtable
name|roomPreferencesThisDept
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|iRoomPreferences
operator|.
name|put
argument_list|(
name|department
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|roomPreferencesThisDept
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|department
operator|.
name|getPreferences
argument_list|(
name|RoomPref
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomPref
name|pref
init|=
operator|(
name|RoomPref
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|roomPreferencesThisDept
operator|.
name|put
argument_list|(
name|pref
operator|.
name|getRoom
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|pref
operator|.
name|getPrefLevel
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Hashtable
name|roomPreferencesThisDept
init|=
operator|(
name|Hashtable
operator|)
name|iRoomPreferences
operator|.
name|get
argument_list|(
name|deptId
argument_list|)
decl_stmt|;
if|if
condition|(
name|roomPreferencesThisDept
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|(
name|PreferenceLevel
operator|)
name|roomPreferencesThisDept
operator|.
name|get
argument_list|(
name|locationId
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Vector
name|computeRoomLocations
parameter_list|(
name|Class_
name|clazz
parameter_list|)
block|{
return|return
name|computeRoomLocations
argument_list|(
name|clazz
argument_list|,
literal|false
argument_list|,
literal|0.01
argument_list|,
literal|0.02
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Vector
name|computeRoomLocations
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|boolean
name|interactiveMode
parameter_list|,
name|double
name|fewerSeatsDisouraged
parameter_list|,
name|double
name|fewerSeatsStronglyDisouraged
parameter_list|)
block|{
name|int
name|minClassLimit
init|=
name|clazz
operator|.
name|getExpectedCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|maxClassLimit
init|=
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxClassLimit
operator|<
name|minClassLimit
condition|)
name|maxClassLimit
operator|=
name|minClassLimit
expr_stmt|;
name|float
name|room2limitRatio
init|=
name|clazz
operator|.
name|getRoomRatio
argument_list|()
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|int
name|roomCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|minClassLimit
operator|<=
literal|0
condition|?
name|room2limitRatio
else|:
name|room2limitRatio
operator|*
name|minClassLimit
argument_list|)
decl_stmt|;
name|int
name|discouragedCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
literal|1.0
operator|-
name|fewerSeatsStronglyDisouraged
operator|)
operator|*
name|roomCapacity
argument_list|)
decl_stmt|;
name|int
name|stronglyDiscouragedCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
literal|1.0
operator|-
name|fewerSeatsStronglyDisouraged
operator|)
operator|*
name|roomCapacity
argument_list|)
decl_stmt|;
name|Vector
name|roomLocations
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|boolean
name|reqRoom
init|=
literal|false
decl_stmt|;
name|boolean
name|reqBldg
init|=
literal|false
decl_stmt|;
name|boolean
name|reqGroup
init|=
literal|false
decl_stmt|;
name|Set
name|allRooms
init|=
name|clazz
operator|.
name|getAvailableRooms
argument_list|()
decl_stmt|;
name|Set
name|groupPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomGroupPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|roomPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|bldgPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|BuildingPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|featurePrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomFeaturePref
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|allRooms
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Location
name|room
init|=
operator|(
name|Location
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|add
init|=
literal|true
decl_stmt|;
name|PreferenceCombination
name|pref
init|=
operator|new
name|SumPreferenceCombination
argument_list|()
decl_stmt|;
comment|// --- group preference ----------
name|PreferenceCombination
name|groupPref
init|=
name|PreferenceCombination
operator|.
name|getDefault
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|groupPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomGroupPref
name|p
init|=
operator|(
name|RoomGroupPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getRoomGroup
argument_list|()
operator|.
name|getRooms
argument_list|()
operator|.
name|contains
argument_list|(
name|room
argument_list|)
condition|)
name|groupPref
operator|.
name|addPreferenceProlog
argument_list|(
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqGroup
operator|&&
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqGroup
operator|&&
operator|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|reqGroup
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|interactiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
argument_list|)
expr_stmt|;
comment|// --- room preference ------------
name|String
name|roomPref
init|=
literal|null
decl_stmt|;
name|PreferenceLevel
name|roomPreference
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|.
name|getPreferences
argument_list|(
name|RoomPref
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomPref
name|x
init|=
operator|(
name|RoomPref
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|room
operator|.
name|equals
argument_list|(
name|x
operator|.
name|getRoom
argument_list|()
argument_list|)
condition|)
name|roomPreference
operator|=
name|x
operator|.
name|getPrefLevel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|roomPreference
operator|!=
literal|null
condition|)
block|{
name|roomPref
operator|=
name|roomPreference
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|roomPref
argument_list|)
condition|)
block|{
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
operator|.
name|equals
argument_list|(
name|roomPref
argument_list|)
condition|)
block|{
name|roomPref
operator|=
name|PreferenceLevel
operator|.
name|sProhibited
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i2
init|=
name|roomPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomPref
name|p
init|=
operator|(
name|RoomPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|room
operator|.
name|equals
argument_list|(
name|p
operator|.
name|getRoom
argument_list|()
argument_list|)
condition|)
block|{
name|roomPref
operator|=
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|roomPref
operator|!=
literal|null
operator|&&
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqRoom
operator|&&
operator|(
name|roomPref
operator|==
literal|null
operator|||
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqRoom
operator|&&
operator|(
name|roomPref
operator|!=
literal|null
operator|&&
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|reqRoom
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|interactiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|roomPref
operator|!=
literal|null
operator|&&
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|roomPref
argument_list|)
expr_stmt|;
comment|// --- building preference ------------
name|Building
name|bldg
init|=
operator|(
name|room
operator|instanceof
name|Room
condition|?
operator|(
operator|(
name|Room
operator|)
name|room
operator|)
operator|.
name|getBuilding
argument_list|()
else|:
literal|null
operator|)
decl_stmt|;
name|String
name|bldgPref
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|bldgPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BuildingPref
name|p
init|=
operator|(
name|BuildingPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|bldg
operator|!=
literal|null
operator|&&
name|bldg
operator|.
name|equals
argument_list|(
name|p
operator|.
name|getBuilding
argument_list|()
argument_list|)
condition|)
block|{
name|bldgPref
operator|=
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bldgPref
operator|!=
literal|null
operator|&&
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqBldg
operator|&&
operator|(
name|bldgPref
operator|==
literal|null
operator|||
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqBldg
operator|&&
operator|(
name|bldgPref
operator|!=
literal|null
operator|&&
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|reqBldg
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|interactiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bldgPref
operator|!=
literal|null
operator|&&
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|bldgPref
argument_list|)
expr_stmt|;
comment|// --- room features preference --------
name|boolean
name|acceptableFeatures
init|=
literal|true
decl_stmt|;
name|PreferenceCombination
name|featurePref
init|=
operator|new
name|MinMaxPreferenceCombination
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|featurePrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomFeaturePref
name|roomFeaturePref
init|=
operator|(
name|RoomFeaturePref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|RoomFeature
name|feature
init|=
name|roomFeaturePref
operator|.
name|getRoomFeature
argument_list|()
decl_stmt|;
name|String
name|p
init|=
name|roomFeaturePref
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
decl_stmt|;
name|boolean
name|hasFeature
init|=
name|feature
operator|.
name|getRooms
argument_list|()
operator|.
name|contains
argument_list|(
name|room
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
name|hasFeature
condition|)
block|{
name|acceptableFeatures
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|&&
operator|!
name|hasFeature
condition|)
block|{
name|acceptableFeatures
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
name|hasFeature
operator|&&
operator|!
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|featurePref
operator|.
name|addPreferenceProlog
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|pref
operator|.
name|addPreferenceInt
argument_list|(
name|featurePref
operator|.
name|getPreferenceInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acceptableFeatures
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
comment|// --- room size -----------------
if|if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|stronglyDiscouragedCapacity
condition|)
block|{
if|if
condition|(
name|interactiveMode
condition|)
name|pref
operator|.
name|addPreferenceInt
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|discouragedCapacity
condition|)
block|{
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|roomCapacity
condition|)
block|{
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sDiscouraged
argument_list|)
expr_stmt|;
block|}
name|int
name|prefInt
init|=
name|pref
operator|.
name|getPreferenceInt
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|add
condition|)
continue|continue;
name|roomLocations
operator|.
name|addElement
argument_list|(
operator|new
name|RoomLocation
argument_list|(
name|room
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|room
operator|.
name|getLabel
argument_list|()
argument_list|,
operator|(
name|bldg
operator|==
literal|null
condition|?
literal|null
else|:
name|bldg
operator|.
name|getUniqueId
argument_list|()
operator|)
argument_list|,
name|prefInt
argument_list|,
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
operator|(
name|room
operator|.
name|getCoordinateX
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|room
operator|.
name|getCoordinateX
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|room
operator|.
name|getCoordinateY
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|room
operator|.
name|getCoordinateY
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|room
operator|.
name|isIgnoreTooFar
argument_list|()
operator|==
literal|null
condition|?
literal|false
else|:
name|room
operator|.
name|isIgnoreTooFar
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|roomLocations
return|;
block|}
specifier|private
name|Lecture
name|loadClass
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|Vector
name|timeLocations
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|Vector
name|roomLocations
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|debug
argument_list|(
literal|"loading class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
argument_list|)
expr_stmt|;
name|Department
name|dept
init|=
name|clazz
operator|.
name|getControllingDept
argument_list|()
decl_stmt|;
name|iDeptNames
operator|.
name|put
argument_list|(
name|dept
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|dept
operator|.
name|getShortLabel
argument_list|()
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"department: "
operator|+
name|dept
operator|.
name|getName
argument_list|()
operator|+
literal|" (id:"
operator|+
name|dept
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|int
name|minClassLimit
init|=
name|clazz
operator|.
name|getExpectedCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|maxClassLimit
init|=
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxClassLimit
operator|<
name|minClassLimit
condition|)
name|maxClassLimit
operator|=
name|minClassLimit
expr_stmt|;
name|float
name|room2limitRatio
init|=
name|clazz
operator|.
name|getRoomRatio
argument_list|()
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|int
name|roomCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|minClassLimit
operator|<=
literal|0
condition|?
name|room2limitRatio
else|:
name|room2limitRatio
operator|*
name|minClassLimit
argument_list|)
decl_stmt|;
comment|/**FOR TESTING     	if (clazz.getCourseName().equals("A&AE 001")) {     		minClassLimit = clazz.getRoomCapacity().intValue();     		maxClassLimit = clazz.getExpectedCapacity().intValue();     		room2limitRatio = 1.0;     		roomCapacity = (int)Math.ceil(minClassLimit*room2limitRatio);     		iProgress.debug("Tweaking "+getClassLabel(clazz)+": classLimit="+minClassLimit+".."+maxClassLimit+", room2limitRatio="+room2limitRatio);     	}     	*/
name|iProgress
operator|.
name|trace
argument_list|(
literal|"class limit: ["
operator|+
name|minClassLimit
operator|+
literal|","
operator|+
name|maxClassLimit
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room2limitRatio: "
operator|+
name|room2limitRatio
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room capacity: "
operator|+
name|roomCapacity
argument_list|)
expr_stmt|;
name|int
name|discouragedCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
literal|1.0
operator|-
name|iFewerSeatsDisouraged
operator|)
operator|*
name|roomCapacity
argument_list|)
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"discouraged capacity: "
operator|+
name|discouragedCapacity
argument_list|)
expr_stmt|;
name|int
name|stronglyDiscouragedCapacity
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
operator|(
literal|1.0
operator|-
name|iFewerSeatsStronglyDisouraged
operator|)
operator|*
name|roomCapacity
argument_list|)
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"strongly discouraged capacity: "
operator|+
name|stronglyDiscouragedCapacity
argument_list|)
expr_stmt|;
name|Set
name|timePrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|TimePref
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|timePrefs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
operator|!=
literal|0
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" has no time pattern selected (class not loaded).<i>If not changed, this class will be treated as Arrange "
operator|+
name|Math
operator|.
name|round
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
operator|/
literal|50.0
argument_list|)
operator|+
literal|" Hours in MSF.</i>"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Set
name|patterns
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|DatePattern
name|datePattern
init|=
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
decl_stmt|;
if|if
condition|(
name|datePattern
operator|==
literal|null
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" has no date pattern selected (class not loaded)."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|iAllUsedDatePatterns
operator|.
name|add
argument_list|(
name|datePattern
argument_list|)
expr_stmt|;
name|int
name|nrRooms
init|=
operator|(
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|==
literal|null
condition|?
literal|1
else|:
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
name|Set
name|groupPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomGroupPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|roomPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|bldgPrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|BuildingPref
operator|.
name|class
argument_list|)
decl_stmt|;
name|Set
name|featurePrefs
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomFeaturePref
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|nrRooms
operator|>
literal|0
condition|)
block|{
name|boolean
name|reqRoom
init|=
literal|false
decl_stmt|;
name|boolean
name|reqBldg
init|=
literal|false
decl_stmt|;
name|boolean
name|reqGroup
init|=
literal|false
decl_stmt|;
name|Set
name|allRooms
init|=
name|clazz
operator|.
name|getAvailableRooms
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|allRooms
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Location
name|room
init|=
operator|(
name|Location
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"checking room "
operator|+
name|room
operator|.
name|getLabel
argument_list|()
operator|+
literal|" ..."
argument_list|)
expr_stmt|;
name|boolean
name|add
init|=
literal|true
decl_stmt|;
name|PreferenceCombination
name|pref
init|=
operator|new
name|SumPreferenceCombination
argument_list|()
decl_stmt|;
comment|// --- group preference ----------
name|PreferenceCombination
name|groupPref
init|=
name|PreferenceCombination
operator|.
name|getDefault
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|groupPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomGroupPref
name|p
init|=
operator|(
name|RoomGroupPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getRoomGroup
argument_list|()
operator|.
name|getRooms
argument_list|()
operator|.
name|contains
argument_list|(
name|room
argument_list|)
condition|)
name|groupPref
operator|.
name|addPreferenceProlog
argument_list|(
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"group is prohibited :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqGroup
operator|&&
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"building is not required :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqGroup
operator|&&
operator|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"group is required, removing all previous rooms (they are not required)"
argument_list|)
expr_stmt|;
name|reqGroup
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|groupPref
operator|.
name|getPreferenceProlog
argument_list|()
argument_list|)
expr_stmt|;
comment|// --- room preference ------------
name|String
name|roomPref
init|=
literal|null
decl_stmt|;
name|PreferenceLevel
name|roomPreference
init|=
name|getRoomPreference
argument_list|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|room
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|roomPreference
operator|!=
literal|null
condition|)
block|{
name|roomPref
operator|=
name|roomPreference
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iInteractiveMode
operator|&&
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|roomPref
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room is prohibited (on room level) :-("
argument_list|)
expr_stmt|;
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
operator|.
name|equals
argument_list|(
name|roomPref
argument_list|)
condition|)
block|{
name|roomPref
operator|=
name|PreferenceLevel
operator|.
name|sProhibited
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i2
init|=
name|roomPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomPref
name|p
init|=
operator|(
name|RoomPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|room
operator|.
name|equals
argument_list|(
name|p
operator|.
name|getRoom
argument_list|()
argument_list|)
condition|)
block|{
name|roomPref
operator|=
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room preference is "
operator|+
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|roomPref
operator|!=
literal|null
operator|&&
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room is prohibited :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqRoom
operator|&&
operator|(
name|roomPref
operator|==
literal|null
operator|||
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room is not required :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqRoom
operator|&&
operator|(
name|roomPref
operator|!=
literal|null
operator|&&
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room is required, removing all previous rooms (they are not required)"
argument_list|)
expr_stmt|;
name|reqRoom
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|roomPref
operator|!=
literal|null
operator|&&
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|roomPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|roomPref
argument_list|)
expr_stmt|;
comment|// --- building preference ------------
name|Building
name|bldg
init|=
operator|(
name|room
operator|instanceof
name|Room
condition|?
operator|(
operator|(
name|Room
operator|)
name|room
operator|)
operator|.
name|getBuilding
argument_list|()
else|:
literal|null
operator|)
decl_stmt|;
name|String
name|bldgPref
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|bldgPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BuildingPref
name|p
init|=
operator|(
name|BuildingPref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|bldg
operator|!=
literal|null
operator|&&
name|bldg
operator|.
name|equals
argument_list|(
name|p
operator|.
name|getBuilding
argument_list|()
argument_list|)
condition|)
block|{
name|bldgPref
operator|=
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"building preference is "
operator|+
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bldgPref
operator|!=
literal|null
operator|&&
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"building is prohibited :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|reqBldg
operator|&&
operator|(
name|bldgPref
operator|==
literal|null
operator|||
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"building is not required :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reqBldg
operator|&&
operator|(
name|bldgPref
operator|!=
literal|null
operator|&&
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"building is required, removing all previous rooms (they are not required)"
argument_list|)
expr_stmt|;
name|reqBldg
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|setPreference
argument_list|(
name|r
operator|.
name|getPreference
argument_list|()
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|roomLocations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bldgPref
operator|!=
literal|null
operator|&&
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|bldgPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|bldgPref
argument_list|)
expr_stmt|;
comment|// --- room features preference --------
name|boolean
name|acceptableFeatures
init|=
literal|true
decl_stmt|;
name|PreferenceCombination
name|featurePref
init|=
operator|new
name|MinMaxPreferenceCombination
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|featurePrefs
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomFeaturePref
name|roomFeaturePref
init|=
operator|(
name|RoomFeaturePref
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|RoomFeature
name|feature
init|=
name|roomFeaturePref
operator|.
name|getRoomFeature
argument_list|()
decl_stmt|;
name|String
name|p
init|=
name|roomFeaturePref
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
decl_stmt|;
name|boolean
name|hasFeature
init|=
name|feature
operator|.
name|getRooms
argument_list|()
operator|.
name|contains
argument_list|(
name|room
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
name|hasFeature
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"present feature "
operator|+
name|feature
operator|.
name|getLabel
argument_list|()
operator|+
literal|" is prohibited :-("
argument_list|)
expr_stmt|;
name|acceptableFeatures
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|&&
operator|!
name|hasFeature
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"not present feature "
operator|+
name|feature
operator|.
name|getLabel
argument_list|()
operator|+
literal|" is required :-("
argument_list|)
expr_stmt|;
name|acceptableFeatures
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
name|hasFeature
operator|&&
operator|!
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|&&
operator|!
name|p
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
name|featurePref
operator|.
name|addPreferenceProlog
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|pref
operator|.
name|addPreferenceInt
argument_list|(
name|featurePref
operator|.
name|getPreferenceInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acceptableFeatures
condition|)
block|{
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
comment|// --- room size -----------------
if|if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|stronglyDiscouragedCapacity
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"too small :-("
argument_list|)
expr_stmt|;
if|if
condition|(
name|iInteractiveMode
condition|)
name|pref
operator|.
name|addPreferenceInt
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|add
operator|=
literal|false
expr_stmt|;
block|}
if|else if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|discouragedCapacity
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room of strongly discouraged size"
argument_list|)
expr_stmt|;
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<
name|roomCapacity
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room of discouraged size"
argument_list|)
expr_stmt|;
name|pref
operator|.
name|addPreferenceProlog
argument_list|(
name|PreferenceLevel
operator|.
name|sDiscouraged
argument_list|)
expr_stmt|;
block|}
name|int
name|prefInt
init|=
name|pref
operator|.
name|getPreferenceInt
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"room preference is "
operator|+
name|prefInt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|add
condition|)
continue|continue;
name|roomLocations
operator|.
name|addElement
argument_list|(
operator|new
name|RoomLocation
argument_list|(
name|room
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|room
operator|.
name|getLabel
argument_list|()
argument_list|,
operator|(
name|bldg
operator|==
literal|null
condition|?
literal|null
else|:
name|bldg
operator|.
name|getUniqueId
argument_list|()
operator|)
argument_list|,
name|prefInt
argument_list|,
name|room
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
operator|(
name|room
operator|.
name|getCoordinateX
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|room
operator|.
name|getCoordinateX
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|room
operator|.
name|getCoordinateY
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|room
operator|.
name|getCoordinateY
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|room
operator|.
name|isIgnoreTooFar
argument_list|()
operator|==
literal|null
condition|?
literal|false
else|:
name|room
operator|.
name|isIgnoreTooFar
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|,
name|getRoomConstraint
argument_list|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
argument_list|,
name|room
argument_list|,
name|hibSession
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|roomLocations
operator|.
name|isEmpty
argument_list|()
operator|||
name|roomLocations
operator|.
name|size
argument_list|()
operator|<
operator|(
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|==
literal|null
condition|?
literal|1
else|:
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" has no available room"
operator|+
operator|(
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|!=
literal|null
operator|&&
name|clazz
operator|.
name|getNbrRooms
argument_list|()
operator|.
name|intValue
argument_list|()
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
operator|)
operator|+
literal|" (class not loaded)."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|groupPrefs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|roomPrefs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|bldgPrefs
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|featurePrefs
operator|.
name|isEmpty
argument_list|()
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" requires no room (number of rooms is set to zero), but it contains some room preferences."
argument_list|)
expr_stmt|;
block|}
name|int
name|minPerWeek
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|boolean
name|onlyReq
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|timePrefs
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TimePref
name|timePref
init|=
operator|(
name|TimePref
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|TimePatternModel
name|pattern
init|=
name|timePref
operator|.
name|getTimePatternModel
argument_list|()
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|isExactTime
argument_list|()
operator|||
name|pattern
operator|.
name|countPreferences
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
operator|>
literal|0
condition|)
name|onlyReq
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|onlyReq
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"time pattern has requred times"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i1
init|=
name|timePrefs
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|TimePref
name|timePref
init|=
operator|(
name|TimePref
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|TimePatternModel
name|pattern
init|=
name|timePref
operator|.
name|getTimePatternModel
argument_list|()
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|isExactTime
argument_list|()
condition|)
block|{
name|int
name|length
init|=
name|ExactTimeMins
operator|.
name|getNrSlotsPerMtg
argument_list|(
name|pattern
operator|.
name|getExactDays
argument_list|()
argument_list|,
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|breakTime
init|=
name|ExactTimeMins
operator|.
name|getBreakTime
argument_list|(
name|pattern
operator|.
name|getExactDays
argument_list|()
argument_list|,
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
decl_stmt|;
name|TimeLocation
name|loc
init|=
operator|new
name|TimeLocation
argument_list|(
name|pattern
operator|.
name|getExactDays
argument_list|()
argument_list|,
name|pattern
operator|.
name|getExactStartSlot
argument_list|()
argument_list|,
name|length
argument_list|,
name|PreferenceLevel
operator|.
name|sIntLevelNeutral
argument_list|,
literal|0
argument_list|,
name|datePattern
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getName
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getPatternBitSet
argument_list|()
argument_list|,
name|breakTime
argument_list|)
decl_stmt|;
name|loc
operator|.
name|setTimePatternId
argument_list|(
name|pattern
operator|.
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|timeLocations
operator|.
name|addElement
argument_list|(
name|loc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|patterns
operator|.
name|add
argument_list|(
name|pattern
operator|.
name|getTimePattern
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iWeakenTimePreferences
condition|)
block|{
name|pattern
operator|.
name|weakenHardPreferences
argument_list|()
expr_stmt|;
name|onlyReq
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|.
name|intValue
argument_list|()
operator|!=
name|pattern
operator|.
name|getMinPerMtg
argument_list|()
operator|*
name|pattern
operator|.
name|getNrMeetings
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" has "
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getMinutesPerWk
argument_list|()
operator|+
literal|" minutes per week, but "
operator|+
name|pattern
operator|.
name|getName
argument_list|()
operator|+
literal|" time pattern selected."
argument_list|)
expr_stmt|;
name|minPerWeek
operator|=
name|pattern
operator|.
name|getMinPerMtg
argument_list|()
operator|*
name|pattern
operator|.
name|getNrMeetings
argument_list|()
expr_stmt|;
if|if
condition|(
name|iFixMinPerWeek
condition|)
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|setMinutesPerWk
argument_list|(
operator|new
name|Integer
argument_list|(
name|minPerWeek
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|time
init|=
literal|0
init|;
name|time
operator|<
name|pattern
operator|.
name|getNrTimes
argument_list|()
condition|;
name|time
operator|++
control|)
block|{
for|for
control|(
name|int
name|day
init|=
literal|0
init|;
name|day
operator|<
name|pattern
operator|.
name|getNrDays
argument_list|()
condition|;
name|day
operator|++
control|)
block|{
name|String
name|pref
init|=
name|pattern
operator|.
name|getPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|)
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"checking time "
operator|+
name|pattern
operator|.
name|getDayHeader
argument_list|(
name|day
argument_list|)
operator|+
literal|" "
operator|+
name|pattern
operator|.
name|getTimeHeaderShort
argument_list|(
name|time
argument_list|)
operator|+
literal|" ("
operator|+
name|pref
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iInteractiveMode
operator|&&
name|pref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"time is prohibited :-("
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|iInteractiveMode
operator|&&
name|onlyReq
operator|&&
operator|!
name|pref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|trace
argument_list|(
literal|"time is not required :-("
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Iterator
name|startSlotsIterator
init|=
name|pattern
operator|.
name|getStartSlots
argument_list|(
name|day
argument_list|,
name|time
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|TimeLocation
name|loc
init|=
operator|new
name|TimeLocation
argument_list|(
name|pattern
operator|.
name|getDayCode
argument_list|(
name|day
argument_list|)
argument_list|,
name|pattern
operator|.
name|getStartSlot
argument_list|(
name|time
argument_list|)
argument_list|,
name|pattern
operator|.
name|getSlotsPerMtg
argument_list|()
argument_list|,
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|pattern
operator|.
name|getPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|)
argument_list|)
argument_list|,
name|pattern
operator|.
name|getNormalizedPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|,
name|iNormalizedPrefDecreaseFactor
argument_list|)
argument_list|,
name|datePattern
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getName
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getPatternBitSet
argument_list|()
argument_list|,
name|pattern
operator|.
name|getBreakTime
argument_list|()
argument_list|)
decl_stmt|;
name|loc
operator|.
name|setTimePatternId
argument_list|(
name|pattern
operator|.
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iAlterTimePatternWeight
operator|!=
literal|0.0
condition|)
block|{
name|String
name|altPref
init|=
name|iAlterTimePatternModel
operator|.
name|getCombinedPreference
argument_list|(
name|loc
operator|.
name|getDayCode
argument_list|()
argument_list|,
name|loc
operator|.
name|getStartSlot
argument_list|()
argument_list|,
name|loc
operator|.
name|getLength
argument_list|()
argument_list|,
name|TimePatternModel
operator|.
name|sMixAlgMinMax
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|altPref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sNeutral
argument_list|)
condition|)
block|{
name|loc
operator|.
name|setNormalizedPreference
argument_list|(
name|loc
operator|.
name|getNormalizedPreference
argument_list|()
operator|+
name|iAlterTimePatternWeight
operator|*
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|altPref
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iInteractiveMode
operator|&&
name|onlyReq
operator|&&
operator|!
name|pref
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
block|{
name|loc
operator|.
name|setPreference
argument_list|(
name|PreferenceLevel
operator|.
name|sIntLevelProhibited
argument_list|)
expr_stmt|;
name|loc
operator|.
name|setNormalizedPreference
argument_list|(
name|PreferenceLevel
operator|.
name|sIntLevelProhibited
argument_list|)
expr_stmt|;
block|}
name|timeLocations
operator|.
name|addElement
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|iInteractiveMode
condition|)
block|{
name|Vector
name|allPatterns
init|=
operator|(
name|Vector
operator|)
name|iPatterns
operator|.
name|get
argument_list|(
operator|new
name|Integer
argument_list|(
name|minPerWeek
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|allPatterns
operator|==
literal|null
condition|)
block|{
name|allPatterns
operator|=
name|TimePattern
operator|.
name|findByMinPerWeek
argument_list|(
name|iSession
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|minPerWeek
argument_list|,
name|clazz
operator|.
name|getManagingDept
argument_list|()
argument_list|)
expr_stmt|;
name|iPatterns
operator|.
name|put
argument_list|(
operator|new
name|Integer
argument_list|(
name|minPerWeek
argument_list|)
argument_list|,
name|allPatterns
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e1
init|=
name|allPatterns
operator|.
name|elements
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|TimePattern
name|pattern
init|=
operator|(
name|TimePattern
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|patterns
operator|.
name|contains
argument_list|(
name|pattern
argument_list|)
condition|)
continue|continue;
name|TimePatternModel
name|model
init|=
name|pattern
operator|.
name|getTimePatternModel
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"adding prohibited pattern "
operator|+
name|model
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|time
init|=
literal|0
init|;
name|time
operator|<
name|model
operator|.
name|getNrTimes
argument_list|()
condition|;
name|time
operator|++
control|)
block|{
for|for
control|(
name|int
name|day
init|=
literal|0
init|;
name|day
operator|<
name|model
operator|.
name|getNrDays
argument_list|()
condition|;
name|day
operator|++
control|)
block|{
name|PreferenceLevel
name|pref
init|=
name|PreferenceLevel
operator|.
name|getPreferenceLevel
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
decl_stmt|;
name|Iterator
name|startSlotsIterator
init|=
name|model
operator|.
name|getStartSlots
argument_list|(
name|day
argument_list|,
name|time
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|TimeLocation
name|loc
init|=
operator|new
name|TimeLocation
argument_list|(
name|model
operator|.
name|getDayCode
argument_list|(
name|day
argument_list|)
argument_list|,
name|model
operator|.
name|getStartSlot
argument_list|(
name|time
argument_list|)
argument_list|,
name|model
operator|.
name|getSlotsPerMtg
argument_list|()
argument_list|,
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|model
operator|.
name|getPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|)
argument_list|)
argument_list|,
name|model
operator|.
name|getNormalizedPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|,
name|iNormalizedPrefDecreaseFactor
argument_list|)
argument_list|,
name|datePattern
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getName
argument_list|()
argument_list|,
name|datePattern
operator|.
name|getPatternBitSet
argument_list|()
argument_list|,
name|model
operator|.
name|getBreakTime
argument_list|()
argument_list|)
decl_stmt|;
name|loc
operator|.
name|setTimePatternId
argument_list|(
name|model
operator|.
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|loc
operator|.
name|setPreference
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|loc
operator|.
name|setNormalizedPreference
argument_list|(
literal|1000.0
argument_list|)
expr_stmt|;
name|timeLocations
operator|.
name|addElement
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|timeLocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" has no available time (class not loaded)."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Vector
name|instructors
init|=
name|clazz
operator|.
name|getLeadInstructors
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|clazz
operator|.
name|getClassLabel
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|new
name|Lecture
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|.
name|getSolverGroup
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|className
argument_list|,
name|timeLocations
argument_list|,
name|roomLocations
argument_list|,
name|nrRooms
argument_list|,
literal|null
argument_list|,
name|minClassLimit
argument_list|,
name|maxClassLimit
argument_list|,
name|room2limitRatio
argument_list|)
decl_stmt|;
name|lecture
operator|.
name|setNote
argument_list|(
name|clazz
operator|.
name|getNotes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|!=
literal|null
condition|)
name|lecture
operator|.
name|setScheduler
argument_list|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|lecture
operator|.
name|setDepartment
argument_list|(
name|dept
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|instructors
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|getInstructorConstraint
argument_list|(
name|instructor
argument_list|,
name|hibSession
argument_list|)
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
name|long
name|estNrValues
init|=
name|lecture
operator|.
name|nrTimeLocations
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lecture
operator|.
name|getNrRooms
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|estNrValues
operator|*=
operator|(
name|lecture
operator|.
name|nrRoomLocations
argument_list|()
operator|-
name|i
operator|)
operator|/
operator|(
name|lecture
operator|.
name|getNrRooms
argument_list|()
operator|-
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|estNrValues
operator|>
literal|1000000
condition|)
block|{
name|iProgress
operator|.
name|error
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" has too many possible placements ("
operator|+
name|estNrValues
operator|+
literal|"). "
operator|+
literal|"The class was not loaded in order to prevent out of memory exception. "
operator|+
literal|"Please restrict the number of available rooms and/or times for this class."
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|instructors
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|getInstructorConstraint
argument_list|(
name|instructor
argument_list|,
name|hibSession
argument_list|)
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
if|else if
condition|(
name|estNrValues
operator|>
literal|10000
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" has quite a lot of possible placements ("
operator|+
name|estNrValues
operator|+
literal|"). "
operator|+
literal|"Solver may run too slow. "
operator|+
literal|"If possible, please restrict the number of available rooms and/or times for this class."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" has no available placement (class not loaded)."
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|instructors
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|getInstructorConstraint
argument_list|(
name|instructor
argument_list|,
name|hibSession
argument_list|)
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
else|else
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" has no available placement."
argument_list|)
expr_stmt|;
block|}
name|iLectures
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|lecture
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e1
init|=
name|roomLocations
operator|.
name|elements
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|r
operator|.
name|getRoomConstraint
argument_list|()
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
comment|/*         for (Iterator i1=clazz.effectivePreferences(DistributionPref.class, false).iterator();i1.hasNext();) {         	DistributionPref pref = (DistributionPref)i1.next();         	iProgress.trace("Dist. constraint "+pref.getPrefLevel().getPrefName()+" "+pref.getDistributionType().getLabel()+" added for class "+lecture.getName());          	Constraint constraint = getGroupConstraint(pref);         	if (constraint!=null)         		constraint.addVariable(lecture);         }         */
return|return
name|lecture
return|;
block|}
specifier|private
name|void
name|assignCommited
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getModel
argument_list|()
operator|.
name|hasConstantVariables
argument_list|()
condition|)
return|return;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Assigning committed classes ..."
argument_list|,
name|getModel
argument_list|()
operator|.
name|constantVariables
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|getModel
argument_list|()
operator|.
name|constantVariables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
if|if
condition|(
name|lecture
operator|.
name|getAssignment
argument_list|()
operator|!=
literal|null
condition|)
continue|continue;
name|Placement
name|placement
init|=
operator|(
name|Placement
operator|)
name|lecture
operator|.
name|getInitialAssignment
argument_list|()
decl_stmt|;
name|Hashtable
name|conflictConstraints
init|=
name|getModel
argument_list|()
operator|.
name|conflictConstraints
argument_list|(
name|placement
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflictConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lecture
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|placement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|warn
init|=
literal|"Unable to assign committed class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|placement
operator|.
name|getName
argument_list|()
decl_stmt|;
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;Reason:"
expr_stmt|;
for|for
control|(
name|Enumeration
name|ex
init|=
name|conflictConstraints
operator|.
name|keys
argument_list|()
init|;
name|ex
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|ex
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Collection
name|vals
init|=
operator|(
name|Collection
operator|)
name|conflictConstraints
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|vals
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Value
name|v
init|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
operator|(
name|Lecture
operator|)
name|v
operator|.
name|variable
argument_list|()
argument_list|)
operator|+
literal|" = "
operator|+
operator|(
operator|(
name|Placement
operator|)
name|v
operator|)
operator|.
name|getLongName
argument_list|()
expr_stmt|;
block|}
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;    in constraint "
operator|+
name|c
expr_stmt|;
name|iProgress
operator|.
name|warn
argument_list|(
name|warn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|purgeInvalidValues
parameter_list|()
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Purging invalid placements ..."
argument_list|,
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HashSet
name|alreadyEmpty
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|alreadyEmpty
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e
init|=
operator|(
operator|new
name|Vector
argument_list|(
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
argument_list|)
operator|)
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Vector
name|oldValues
init|=
operator|new
name|Vector
argument_list|(
name|lecture
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|lecture
operator|.
name|purgeInvalidValues
argument_list|(
name|iInteractiveMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|alreadyEmpty
operator|.
name|contains
argument_list|(
name|lecture
argument_list|)
condition|)
block|{
name|String
name|warn
init|=
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" has no available placement (after enforcing consistency between the problem and committed solutions"
operator|+
operator|(
name|iInteractiveMode
condition|?
literal|""
else|:
literal|", class not loaded"
operator|)
operator|+
literal|")."
decl_stmt|;
for|for
control|(
name|Enumeration
name|f
init|=
name|oldValues
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Placement
name|p
init|=
operator|(
name|Placement
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|p
operator|.
name|getNotValidReason
argument_list|()
expr_stmt|;
block|}
name|iProgress
operator|.
name|warn
argument_list|(
name|warn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
block|{
name|getModel
argument_list|()
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|f
init|=
operator|(
operator|new
name|Vector
argument_list|(
name|lecture
operator|.
name|constraints
argument_list|()
argument_list|)
operator|)
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|c
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|variables
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|getModel
argument_list|()
operator|.
name|removeConstraint
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|lecture
operator|.
name|students
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|s
init|=
operator|(
name|Student
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|s
operator|.
name|getLectures
argument_list|()
operator|.
name|remove
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadAssignment
parameter_list|(
name|Assignment
name|assignment
parameter_list|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dayCode
init|=
name|assignment
operator|.
name|getDays
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|startSlot
init|=
name|assignment
operator|.
name|getStartSlot
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Long
name|patternId
init|=
name|assignment
operator|.
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
decl_stmt|;
name|Set
name|rooms
init|=
name|assignment
operator|.
name|getRooms
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
return|return;
name|Placement
name|initialPlacement
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|placement
init|=
operator|(
name|Placement
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getDayCode
argument_list|()
operator|!=
name|dayCode
condition|)
continue|continue;
if|if
condition|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getStartSlot
argument_list|()
operator|!=
name|startSlot
condition|)
continue|continue;
name|boolean
name|sameRooms
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|rooms
operator|.
name|iterator
argument_list|()
init|;
name|sameRooms
operator|&&
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Location
name|r
init|=
operator|(
name|Location
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|placement
operator|.
name|hasRoomLocation
argument_list|(
name|r
operator|.
name|getUniqueId
argument_list|()
argument_list|)
condition|)
name|sameRooms
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sameRooms
condition|)
continue|continue;
name|initialPlacement
operator|=
name|placement
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|initialPlacement
operator|==
literal|null
condition|)
block|{
name|TimeLocation
name|timeLocation
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Enumeration
name|e2
init|=
name|lecture
operator|.
name|timeLocations
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e2
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|TimeLocation
name|t
init|=
operator|(
name|TimeLocation
operator|)
name|e2
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|getDayCode
argument_list|()
operator|!=
name|dayCode
condition|)
continue|continue;
if|if
condition|(
name|t
operator|.
name|getStartSlot
argument_list|()
operator|!=
name|startSlot
condition|)
continue|continue;
if|if
condition|(
operator|!
name|t
operator|.
name|getTimePatternId
argument_list|()
operator|.
name|equals
argument_list|(
name|patternId
argument_list|)
condition|)
continue|continue;
name|timeLocation
operator|=
name|t
expr_stmt|;
break|break;
block|}
name|Vector
name|roomLocations
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|rooms
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Location
name|room
init|=
operator|(
name|Location
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e2
init|=
name|lecture
operator|.
name|roomLocations
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e2
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|r
init|=
operator|(
name|RoomLocation
operator|)
name|e2
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|room
operator|.
name|getUniqueId
argument_list|()
argument_list|)
condition|)
name|roomLocations
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeLocation
operator|!=
literal|null
operator|&&
name|roomLocations
operator|.
name|size
argument_list|()
operator|==
name|lecture
operator|.
name|getNrRooms
argument_list|()
condition|)
block|{
name|initialPlacement
operator|=
operator|new
name|Placement
argument_list|(
name|lecture
argument_list|,
name|timeLocation
argument_list|,
name|roomLocations
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialPlacement
operator|==
literal|null
condition|)
block|{
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|(
name|assignment
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" "
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|rooms
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
operator|(
name|Location
operator|)
name|i
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getLabel
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|assignment
operator|.
name|getInstructors
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|assignment
operator|.
name|getInstructors
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
operator|(
operator|(
name|DepartmentalInstructor
operator|)
name|i
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getName
argument_list|(
name|iInstructorFormat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Unable to assign "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|sb
operator|+
literal|" (placement not valid)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|initialPlacement
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|String
name|reason
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|lecture
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ic
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|initialPlacement
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;instructor "
operator|+
name|ic
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
if|if
condition|(
name|lecture
operator|.
name|getNrRooms
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|initialPlacement
operator|.
name|isMultiRoom
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|f
init|=
name|initialPlacement
operator|.
name|getRoomLocations
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|roomLocation
init|=
operator|(
name|RoomLocation
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|roomLocation
operator|.
name|getRoomConstraint
argument_list|()
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|initialPlacement
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|lecture
operator|.
name|getScheduler
argument_list|()
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;room "
operator|+
name|roomLocation
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|initialPlacement
operator|.
name|getRoomLocation
argument_list|()
operator|.
name|getRoomConstraint
argument_list|()
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|initialPlacement
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|lecture
operator|.
name|getScheduler
argument_list|()
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;room "
operator|+
name|initialPlacement
operator|.
name|getRoomLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
block|}
name|Hashtable
name|conflictConstraints
init|=
name|getModel
argument_list|()
operator|.
name|conflictConstraints
argument_list|(
name|initialPlacement
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|conflictConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|ex
init|=
name|conflictConstraints
operator|.
name|keys
argument_list|()
init|;
name|ex
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|ex
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Collection
name|vals
init|=
operator|(
name|Collection
operator|)
name|conflictConstraints
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|vals
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|p
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|l
init|=
operator|(
name|Lecture
operator|)
name|p
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|isCommitted
argument_list|()
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;conflict with committed assignment "
operator|+
name|getClassLabel
argument_list|(
name|l
argument_list|)
operator|+
literal|" = "
operator|+
name|p
operator|.
name|getLongName
argument_list|()
operator|+
literal|" (in constraint "
operator|+
name|c
operator|+
literal|")"
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|initialPlacement
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;constraint "
operator|+
name|c
expr_stmt|;
block|}
block|}
block|}
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Unable to assign "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|initialPlacement
operator|.
name|getLongName
argument_list|()
operator|+
operator|(
name|reason
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|"."
else|:
literal|":"
operator|+
name|reason
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iMppAssignment
condition|)
name|lecture
operator|.
name|setInitialAssignment
argument_list|(
name|initialPlacement
argument_list|)
expr_stmt|;
name|Hashtable
name|conflictConstraints
init|=
name|getModel
argument_list|()
operator|.
name|conflictConstraints
argument_list|(
name|initialPlacement
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflictConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lecture
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|initialPlacement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|warn
init|=
literal|"Unable to assign "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|initialPlacement
operator|.
name|getName
argument_list|()
decl_stmt|;
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;Reason:"
expr_stmt|;
for|for
control|(
name|Enumeration
name|ex
init|=
name|conflictConstraints
operator|.
name|keys
argument_list|()
init|;
name|ex
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|ex
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Collection
name|vals
init|=
operator|(
name|Collection
operator|)
name|conflictConstraints
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|vals
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Value
name|v
init|=
operator|(
name|Value
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
operator|(
name|Lecture
operator|)
name|v
operator|.
name|variable
argument_list|()
argument_list|)
operator|+
literal|" = "
operator|+
operator|(
operator|(
name|Placement
operator|)
name|v
operator|)
operator|.
name|getLongName
argument_list|()
expr_stmt|;
block|}
name|warn
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;    in constraint "
operator|+
name|c
expr_stmt|;
name|iProgress
operator|.
name|warn
argument_list|(
name|warn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|RoomConstraint
name|getRoomConstraint
parameter_list|(
name|Department
name|dept
parameter_list|,
name|Location
name|location
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|RoomConstraint
name|rc
init|=
operator|(
name|RoomConstraint
operator|)
name|iRooms
operator|.
name|get
argument_list|(
name|location
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|null
condition|)
block|{
name|PreferenceLevel
name|roomPreference
init|=
name|getRoomPreference
argument_list|(
name|dept
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|location
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|discouraged
init|=
operator|(
operator|!
name|iInteractiveMode
operator|&&
name|roomPreference
operator|!=
literal|null
operator|&&
operator|(
name|roomPreference
operator|.
name|getPrefProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
operator|||
name|roomPreference
operator|.
name|getPrefProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
argument_list|)
operator|||
name|roomPreference
operator|.
name|getPrefProlog
argument_list|()
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|sDiscouraged
argument_list|)
operator|)
operator|)
decl_stmt|;
name|RoomSharingModel
name|sharingModel
init|=
name|location
operator|.
name|getRoomSharingModel
argument_list|()
decl_stmt|;
if|if
condition|(
name|sharingModel
operator|!=
literal|null
operator|&&
name|iIgnoreRoomSharing
condition|)
block|{
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|sharingModel
operator|.
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|sharingModel
operator|.
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|String
operator|.
name|valueOf
argument_list|(
name|RoomSharingModel
operator|.
name|sNotAvailablePref
argument_list|)
operator|.
name|equals
argument_list|(
name|sharingModel
operator|.
name|getPreference
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
argument_list|)
condition|)
name|sharingModel
operator|.
name|setPreference
argument_list|(
name|d
argument_list|,
name|t
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|RoomSharingModel
operator|.
name|sFreeForAllPref
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sharingModel
operator|!=
literal|null
operator|&&
name|sharingModel
operator|.
name|allAvailable
argument_list|(
literal|null
argument_list|)
condition|)
name|sharingModel
operator|=
literal|null
expr_stmt|;
name|Long
name|buildingId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|location
operator|instanceof
name|Room
condition|)
block|{
name|buildingId
operator|=
operator|(
operator|(
name|Room
operator|)
name|location
operator|)
operator|.
name|getBuilding
argument_list|()
operator|.
name|getUniqueId
argument_list|()
expr_stmt|;
block|}
name|rc
operator|=
operator|(
name|discouraged
condition|?
operator|new
name|DiscouragedRoomConstraint
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
name|location
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|location
operator|.
name|getLabel
argument_list|()
argument_list|,
name|buildingId
argument_list|,
name|location
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|sharingModel
argument_list|,
operator|(
name|location
operator|.
name|getCoordinateX
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|location
operator|.
name|getCoordinateX
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|getCoordinateY
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|location
operator|.
name|getCoordinateY
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|isIgnoreTooFar
argument_list|()
operator|==
literal|null
condition|?
literal|false
else|:
name|location
operator|.
name|isIgnoreTooFar
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|==
literal|null
condition|?
literal|true
else|:
operator|!
name|location
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|)
else|:
operator|new
name|RoomConstraint
argument_list|(
name|location
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|location
operator|.
name|getLabel
argument_list|()
argument_list|,
name|buildingId
argument_list|,
name|location
operator|.
name|getCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|sharingModel
argument_list|,
operator|(
name|location
operator|.
name|getCoordinateX
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|location
operator|.
name|getCoordinateX
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|getCoordinateY
argument_list|()
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|location
operator|.
name|getCoordinateY
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|isIgnoreTooFar
argument_list|()
operator|==
literal|null
condition|?
literal|false
else|:
name|location
operator|.
name|isIgnoreTooFar
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|,
operator|(
name|location
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|==
literal|null
condition|?
literal|true
else|:
operator|!
name|location
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
argument_list|)
operator|)
expr_stmt|;
name|rc
operator|.
name|setType
argument_list|(
name|location
operator|instanceof
name|Room
condition|?
operator|(
operator|(
name|Room
operator|)
name|location
operator|)
operator|.
name|getRoomType
argument_list|()
operator|.
name|getUniqueId
argument_list|()
else|:
literal|null
argument_list|)
expr_stmt|;
comment|//loadRoomAvailability(location, rc, hibSession);
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|iRooms
operator|.
name|put
argument_list|(
name|location
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
specifier|private
name|InstructorConstraint
name|getInstructorConstraint
parameter_list|(
name|DepartmentalInstructor
name|instructor
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
if|if
condition|(
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|!=
literal|null
operator|&&
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|iInstructors
operator|.
name|get
argument_list|(
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
argument_list|)
decl_stmt|;
comment|/*     		if (ic!=null&& !ic.getResourceId().equals(instructor.getUniqueId()))     			iProgress.debug("Instructor "+instructor.getName(iInstructorFormat)+" (puid:"+instructor.getExternalUniqueId()+") is interesting :)");     		*/
if|if
condition|(
name|ic
operator|!=
literal|null
condition|)
return|return
name|ic
return|;
block|}
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|iInstructors
operator|.
name|get
argument_list|(
name|instructor
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ic
operator|==
literal|null
condition|)
block|{
name|boolean
name|ignDist
init|=
operator|(
name|instructor
operator|.
name|isIgnoreToFar
argument_list|()
operator|!=
literal|null
operator|&&
name|instructor
operator|.
name|isIgnoreToFar
argument_list|()
operator|.
name|booleanValue
argument_list|()
operator|)
decl_stmt|;
name|ic
operator|=
operator|new
name|InstructorConstraint
argument_list|(
name|instructor
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getName
argument_list|(
name|iInstructorFormat
argument_list|)
argument_list|,
name|ignDist
argument_list|)
expr_stmt|;
name|ic
operator|.
name|setType
argument_list|(
name|instructor
operator|.
name|getPositionType
argument_list|()
operator|==
literal|null
condition|?
operator|new
name|Long
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
else|:
operator|new
name|Long
argument_list|(
name|instructor
operator|.
name|getPositionType
argument_list|()
operator|.
name|getSortOrder
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|//loadInstructorAvailability(instructor, ic, hibSession);
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|iInstructors
operator|.
name|put
argument_list|(
name|instructor
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|!=
literal|null
operator|&&
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|iInstructors
operator|.
name|put
argument_list|(
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
return|return
name|ic
return|;
block|}
specifier|private
name|void
name|loadInstructorAvailability
parameter_list|(
name|DepartmentalInstructor
name|instructor
parameter_list|,
name|InstructorConstraint
name|ic
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
if|if
condition|(
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|==
literal|null
operator|||
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return;
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from DepartmentalInstructor i inner join i.assignments as a "
operator|+
literal|"where i.externalUniqueId=:puid and a.solution.owner.session.uniqueId=:sessionId and a.solution.commited=true and a.solution.owner.uniqueId not in ("
operator|+
name|iSolverGroupIds
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|q
operator|.
name|setString
argument_list|(
literal|"puid"
argument_list|,
name|instructor
operator|.
name|getExternalUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|iSessionId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|q
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Placement
name|p
init|=
name|a
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|ic
operator|.
name|setNotAvailable
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iLectures
operator|.
name|containsKey
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLectures
operator|.
name|put
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|,
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|loadInstructorAvailabilities
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|String
name|puids
parameter_list|)
block|{
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct i.externalUniqueId, a from DepartmentalInstructor i inner join i.assignments as a "
operator|+
literal|"where i.externalUniqueId in ("
operator|+
name|puids
operator|+
literal|") and a.solution.owner.session.uniqueId=:sessionId and a.solution.commited=true and a.solution.owner.uniqueId not in ("
operator|+
name|iSolverGroupIds
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|iSessionId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|q
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
index|[]
name|x
init|=
operator|(
name|Object
index|[]
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|puid
init|=
operator|(
name|String
operator|)
name|x
index|[
literal|0
index|]
decl_stmt|;
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|x
index|[
literal|1
index|]
decl_stmt|;
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|iInstructors
operator|.
name|get
argument_list|(
name|puid
argument_list|)
decl_stmt|;
name|Placement
name|p
init|=
name|a
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|ic
operator|.
name|setNotAvailable
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iLectures
operator|.
name|containsKey
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLectures
operator|.
name|put
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|,
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|loadInstructorAvailabilities
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading instructor availabilities ..."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|StringBuffer
name|puids
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|iInstructors
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|ic
operator|.
name|getPuid
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|puids
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|puids
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|puids
operator|.
name|append
argument_list|(
literal|"'"
operator|+
name|ic
operator|.
name|getPuid
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|100
condition|)
block|{
name|loadInstructorAvailabilities
argument_list|(
name|hibSession
argument_list|,
name|puids
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|puids
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|puids
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|loadInstructorAvailabilities
argument_list|(
name|hibSession
argument_list|,
name|puids
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|loadRoomAvailability
parameter_list|(
name|Location
name|location
parameter_list|,
name|RoomConstraint
name|rc
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from Location r inner join r.assignments as a "
operator|+
literal|"where r.uniqueId=:roomId and a.solution.owner.session.uniqueId=:sessionId and a.solution.commited=true and a.solution.owner.uniqueId not in ("
operator|+
name|iSolverGroupIds
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"roomId"
argument_list|,
name|location
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|iSessionId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|q
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Placement
name|p
init|=
name|a
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|rc
operator|.
name|setNotAvailable
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iLectures
operator|.
name|containsKey
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLectures
operator|.
name|put
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|,
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|loadRoomAvailabilities
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|String
name|roomids
parameter_list|)
block|{
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct r.uniqueId, a from Location r inner join r.assignments as a "
operator|+
literal|"where r.uniqueId in ("
operator|+
name|roomids
operator|+
literal|") and a.solution.owner.session.uniqueId=:sessionId and a.solution.commited=true and a.solution.owner.uniqueId not in ("
operator|+
name|iSolverGroupIds
operator|+
literal|")"
argument_list|)
decl_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|iSessionId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|q
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
index|[]
name|x
init|=
operator|(
name|Object
index|[]
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Long
name|roomId
init|=
operator|(
name|Long
operator|)
name|x
index|[
literal|0
index|]
decl_stmt|;
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|x
index|[
literal|1
index|]
decl_stmt|;
name|Placement
name|p
init|=
name|a
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|RoomConstraint
name|rc
init|=
operator|(
name|RoomConstraint
operator|)
name|iRooms
operator|.
name|get
argument_list|(
name|roomId
argument_list|)
decl_stmt|;
name|rc
operator|.
name|setNotAvailable
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iLectures
operator|.
name|containsKey
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLectures
operator|.
name|put
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|,
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|loadRoomAvailabilities
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading room availabilities ..."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|StringBuffer
name|roomids
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|iRooms
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomConstraint
name|rc
init|=
operator|(
name|RoomConstraint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|roomids
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|roomids
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|roomids
operator|.
name|append
argument_list|(
name|rc
operator|.
name|getResourceId
argument_list|()
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|100
condition|)
block|{
name|loadRoomAvailabilities
argument_list|(
name|hibSession
argument_list|,
name|roomids
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|roomids
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|roomids
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|loadRoomAvailabilities
argument_list|(
name|hibSession
argument_list|,
name|roomids
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
specifier|private
name|Constraint
name|createGroupConstraint
parameter_list|(
name|DistributionPref
name|pref
parameter_list|)
block|{
name|Constraint
name|gc
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|"SAME_INSTR"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
operator|&&
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
block|{
name|gc
operator|=
operator|new
name|InstructorConstraint
argument_list|(
operator|new
name|Long
argument_list|(
operator|-
operator|(
name|int
operator|)
name|pref
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"SPREAD"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
name|gc
operator|=
operator|new
name|SpreadConstraint
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|"spread"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"MIN_ROOM_USE"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
name|gc
operator|=
operator|new
name|MinimizeNumberOfUsedRoomsConstraint
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|info
argument_list|(
literal|"Minimize number of used rooms constraint not loaded due to the interactive mode of the solver."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"MIN_GRUSE(10x1h)"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
name|gc
operator|=
operator|new
name|MinimizeNumberOfUsedGroupsOfTime
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|"10x1h"
argument_list|,
name|MinimizeNumberOfUsedGroupsOfTime
operator|.
name|sGroups10of1h
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|info
argument_list|(
literal|"Minimize number of used groups of time constraint not loaded due to the interactive mode of the solver."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"MIN_GRUSE(5x2h)"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
name|gc
operator|=
operator|new
name|MinimizeNumberOfUsedGroupsOfTime
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|"5x2h"
argument_list|,
name|MinimizeNumberOfUsedGroupsOfTime
operator|.
name|sGroups5of2h
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|info
argument_list|(
literal|"Minimize number of used groups of time constraint not loaded due to the interactive mode of the solver."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"MIN_GRUSE(3x3h)"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
name|gc
operator|=
operator|new
name|MinimizeNumberOfUsedGroupsOfTime
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|"3x3h"
argument_list|,
name|MinimizeNumberOfUsedGroupsOfTime
operator|.
name|sGroups3of3h
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|info
argument_list|(
literal|"Minimize number of used groups of time constraint not loaded due to the interactive mode of the solver."
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
literal|"MIN_GRUSE(2x5h)"
operator|.
name|equals
argument_list|(
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|iInteractiveMode
condition|)
name|gc
operator|=
operator|new
name|MinimizeNumberOfUsedGroupsOfTime
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|"2x5h"
argument_list|,
name|MinimizeNumberOfUsedGroupsOfTime
operator|.
name|sGroups2of5h
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|info
argument_list|(
literal|"Minimize number of used groups of time constraint not loaded due to the interactive mode of the solver."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gc
operator|=
operator|new
name|GroupConstraint
argument_list|(
name|pref
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
argument_list|,
name|pref
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|gc
return|;
block|}
specifier|private
name|void
name|errorAddGroupConstraintNotFound
parameter_list|(
name|DistributionPref
name|pref
parameter_list|,
name|Class_
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|pref
operator|.
name|getOwner
argument_list|()
operator|!=
literal|null
operator|&&
name|pref
operator|.
name|getOwner
argument_list|()
operator|instanceof
name|DepartmentalInstructor
condition|)
name|iProgress
operator|.
name|info
argument_list|(
literal|"Lecture "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" not found/loaded, but used in distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Lecture "
operator|+
name|getClassLabel
argument_list|(
name|clazz
argument_list|)
operator|+
literal|" not found/loaded, but used in distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Lecture
name|getLecture
parameter_list|(
name|Class_
name|clazz
parameter_list|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
return|return
name|lecture
return|;
if|if
condition|(
name|iAllClasses
operator|.
name|contains
argument_list|(
name|clazz
argument_list|)
condition|)
return|return
literal|null
return|;
try|try
block|{
name|Assignment
name|assignment
init|=
name|clazz
operator|.
name|getCommittedAssignment
argument_list|()
decl_stmt|;
if|if
condition|(
name|assignment
operator|!=
literal|null
condition|)
block|{
name|Placement
name|placement
init|=
name|assignment
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|lecture
operator|=
operator|(
name|Lecture
operator|)
name|placement
operator|.
name|variable
argument_list|()
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|iLectures
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LazyInitializationException
name|e
parameter_list|)
block|{
name|Assignment
name|assignment
init|=
operator|(
operator|new
name|AssignmentDAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getCommittedAssignment
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|assignment
operator|!=
literal|null
condition|)
block|{
name|Placement
name|placement
init|=
name|assignment
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|lecture
operator|=
operator|(
name|Lecture
operator|)
name|placement
operator|.
name|variable
argument_list|()
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|iLectures
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|lecture
return|;
block|}
specifier|private
name|void
name|addGroupConstraint
parameter_list|(
name|Constraint
name|gc
parameter_list|)
block|{
if|if
condition|(
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|boolean
name|allVariablesAreCommitted
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
name|allVariablesAreCommitted
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allVariablesAreCommitted
condition|)
block|{
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Not created constraint "
operator|+
name|gc
operator|.
name|getName
argument_list|()
operator|+
literal|" between "
operator|+
name|gc
operator|.
name|variables
argument_list|()
operator|+
literal|" (all variables are committed)"
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
operator|(
operator|new
name|Vector
argument_list|(
name|gc
operator|.
name|variables
argument_list|()
argument_list|)
operator|)
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|gc
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"Added constraint "
operator|+
name|gc
operator|.
name|getName
argument_list|()
operator|+
literal|" between "
operator|+
name|gc
operator|.
name|variables
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|loadGroupConstraint
parameter_list|(
name|DistributionPref
name|pref
parameter_list|)
block|{
name|int
name|groupingType
init|=
operator|(
name|pref
operator|.
name|getGrouping
argument_list|()
operator|==
literal|null
condition|?
name|DistributionPref
operator|.
name|sGroupingNone
else|:
name|pref
operator|.
name|getGrouping
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|groupingType
operator|==
name|DistributionPref
operator|.
name|sGroupingProgressive
condition|)
block|{
name|int
name|maxSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|pref
operator|.
name|getOrderedSetOfDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distributionObject
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
name|maxSize
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|else if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
condition|)
name|maxSize
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxSize
argument_list|,
operator|(
operator|(
name|SchedulingSubpart
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|)
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Constraint
name|gc
index|[]
init|=
operator|new
name|Constraint
index|[
name|maxSize
index|]
decl_stmt|;
name|Set
name|gcClasses
index|[]
init|=
operator|new
name|Set
index|[
name|maxSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|gc
index|[
name|i
index|]
operator|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|gc
index|[
name|i
index|]
operator|==
literal|null
condition|)
return|return;
name|gcClasses
index|[
name|i
index|]
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
block|}
name|Vector
name|allLectureOfCorrectOrder
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|pref
operator|.
name|getOrderedSetOfDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distributionObject
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
name|allLectureOfCorrectOrder
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
condition|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Vector
name|classes
init|=
operator|new
name|Vector
argument_list|(
name|subpart
operator|.
name|getClasses
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|classes
argument_list|,
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|classes
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
name|allLectureOfCorrectOrder
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Vector
name|distributionObjects
init|=
operator|new
name|Vector
argument_list|(
name|pref
operator|.
name|getDistributionObjects
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|distributionObjects
argument_list|,
operator|new
name|ChildrenFirstDistributionObjectComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|distributionObjects
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distributionObject
init|=
operator|(
name|DistributionObject
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gc
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|gc
index|[
name|j
index|]
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|gcClasses
index|[
name|j
index|]
operator|.
name|add
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
condition|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Vector
name|classes
init|=
operator|new
name|Vector
argument_list|(
name|subpart
operator|.
name|getClasses
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|classes
argument_list|,
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|gc
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|Class_
name|clazz
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|gcClasses
index|[
name|j
index|]
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
operator|&&
name|clazz
operator|==
literal|null
condition|;
control|)
block|{
name|clazz
operator|=
name|getParentClass
argument_list|(
operator|(
name|Class_
operator|)
name|k
operator|.
name|next
argument_list|()
argument_list|,
name|subpart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
name|clazz
operator|=
operator|(
name|Class_
operator|)
name|classes
operator|.
name|elementAt
argument_list|(
name|j
operator|%
name|classes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gc
index|[
name|j
index|]
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|gcClasses
index|[
name|j
index|]
operator|.
name|add
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
operator|+
literal|" refers to unsupported object "
operator|+
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Comparator
name|cmp
init|=
operator|new
name|ObjectsByGivenOrderComparator
argument_list|(
name|allLectureOfCorrectOrder
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gc
index|[
name|i
index|]
operator|.
name|variables
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|gc
index|[
name|i
index|]
operator|.
name|variables
argument_list|()
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|addGroupConstraint
argument_list|(
name|gc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|else if
condition|(
name|groupingType
operator|==
name|DistributionPref
operator|.
name|sGroupingPairWise
condition|)
block|{
name|Vector
name|lectures
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|pref
operator|.
name|getOrderedSetOfDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distributionObject
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
condition|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Vector
name|classes
init|=
operator|new
name|Vector
argument_list|(
name|subpart
operator|.
name|getClasses
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|classes
argument_list|,
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|classes
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
operator|+
literal|" refers to unsupported object "
operator|+
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lectures
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
operator|+
literal|" refers to less than two classes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|idx1
init|=
literal|0
init|;
name|idx1
operator|<
name|lectures
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|idx1
operator|++
control|)
block|{
name|Lecture
name|l1
init|=
operator|(
name|Lecture
operator|)
name|lectures
operator|.
name|elementAt
argument_list|(
name|idx1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx2
init|=
name|idx1
operator|+
literal|1
init|;
name|idx2
operator|<
name|lectures
operator|.
name|size
argument_list|()
condition|;
name|idx2
operator|++
control|)
block|{
name|Lecture
name|l2
init|=
operator|(
name|Lecture
operator|)
name|lectures
operator|.
name|elementAt
argument_list|(
name|idx2
argument_list|)
decl_stmt|;
name|Constraint
name|gc
init|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
decl_stmt|;
if|if
condition|(
name|gc
operator|==
literal|null
condition|)
return|return;
name|gc
operator|.
name|addVariable
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|gc
operator|.
name|addVariable
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|Constraint
name|gc
init|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
decl_stmt|;
if|if
condition|(
name|gc
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Iterator
name|i
init|=
name|pref
operator|.
name|getOrderedSetOfDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distributionObject
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupingType
operator|>=
name|DistributionPref
operator|.
name|sGroupingByTwo
operator|&&
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|groupingType
condition|)
block|{
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
name|gc
operator|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|gc
operator|==
literal|null
condition|)
return|return;
block|}
block|}
if|else if
condition|(
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
condition|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|Vector
name|classes
init|=
operator|new
name|Vector
argument_list|(
name|subpart
operator|.
name|getClasses
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|classes
argument_list|,
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|classes
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupingType
operator|>=
name|DistributionPref
operator|.
name|sGroupingByTwo
operator|&&
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|groupingType
condition|)
block|{
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
name|gc
operator|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|gc
operator|==
literal|null
condition|)
return|return;
block|}
block|}
block|}
else|else
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Distribution preference "
operator|+
name|pref
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getLabel
argument_list|()
operator|+
name|pref
operator|.
name|getGroupingSufix
argument_list|()
operator|+
literal|" refers to unsupported object "
operator|+
name|distributionObject
operator|.
name|getPrefGroup
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadInstructorGroupConstraint
parameter_list|(
name|DepartmentalInstructor
name|instructor
parameter_list|,
name|DistributionPref
name|pref
parameter_list|)
block|{
name|Constraint
name|gc
init|=
name|createGroupConstraint
argument_list|(
name|pref
argument_list|)
decl_stmt|;
if|if
condition|(
name|gc
operator|==
literal|null
condition|)
return|return;
name|boolean
name|allExternallyManaged
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|instructor
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassInstructor
name|classInstructor
init|=
operator|(
name|ClassInstructor
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|classInstructor
operator|.
name|getClassInstructing
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|getManagingDept
argument_list|()
operator|.
name|isExternalManager
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|allExternallyManaged
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allExternallyManaged
condition|)
return|return;
for|for
control|(
name|Iterator
name|i
init|=
name|instructor
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassInstructor
name|classInstructor
init|=
operator|(
name|ClassInstructor
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|classInstructor
operator|.
name|getClassInstructing
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
block|{
name|errorAddGroupConstraintNotFound
argument_list|(
name|pref
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|loadInstructorGroupConstraints
parameter_list|(
name|DepartmentalInstructor
name|instructor
parameter_list|)
block|{
name|Set
name|prefs
init|=
name|instructor
operator|.
name|getPreferences
argument_list|(
name|DistributionPref
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefs
operator|==
literal|null
operator|||
name|prefs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|Iterator
name|i
init|=
name|prefs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionPref
name|pref
init|=
operator|(
name|DistributionPref
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|loadInstructorGroupConstraint
argument_list|(
name|instructor
argument_list|,
name|pref
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|loadInstructorGroupConstraints
parameter_list|(
name|Department
name|department
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|List
name|instructors
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct di from DepartmentalInstructor di inner join di.department d where d.uniqueId=:deptId"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"deptId"
argument_list|,
name|department
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|instructors
operator|==
literal|null
operator|||
name|instructors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading instructor distr. constraints for "
operator|+
name|department
operator|.
name|getShortLabel
argument_list|()
operator|+
literal|" ..."
argument_list|,
name|instructors
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|instructors
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|loadInstructorGroupConstraints
argument_list|(
name|instructor
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|Class_
name|getParentClass
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|SchedulingSubpart
name|parentSubpart
parameter_list|)
block|{
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|parentSubpart
operator|.
name|getClasses
argument_list|()
operator|.
name|contains
argument_list|(
name|clazz
argument_list|)
condition|)
return|return
name|clazz
return|;
return|return
name|getParentClass
argument_list|(
name|clazz
operator|.
name|getParentClass
argument_list|()
argument_list|,
name|parentSubpart
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|ChildrenFirstDistributionObjectComparator
implements|implements
name|Comparator
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
name|DistributionObject
name|d1
init|=
operator|(
name|DistributionObject
operator|)
name|o1
decl_stmt|;
name|DistributionObject
name|d2
init|=
operator|(
name|DistributionObject
operator|)
name|o2
decl_stmt|;
if|if
condition|(
name|d1
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
block|{
if|if
condition|(
name|d2
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
return|return
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
return|;
else|else
return|return
literal|1
return|;
comment|//classes last
block|}
if|else if
condition|(
name|d2
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|Class_
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|d1
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
operator|)
operator|||
operator|!
operator|(
name|d2
operator|.
name|getPrefGroup
argument_list|()
operator|instanceof
name|SchedulingSubpart
operator|)
condition|)
return|return
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
return|;
comment|//should not happen
name|SchedulingSubpart
name|s1
init|=
operator|(
name|SchedulingSubpart
operator|)
name|d1
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
name|SchedulingSubpart
name|s2
init|=
operator|(
name|SchedulingSubpart
operator|)
name|d2
operator|.
name|getPrefGroup
argument_list|()
decl_stmt|;
if|if
condition|(
name|s1
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|s2
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
return|return
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
return|;
else|else
return|return
literal|1
return|;
comment|//singleton last
block|}
if|else if
condition|(
name|s2
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|getParentClass
argument_list|(
operator|(
name|Class_
operator|)
name|s1
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|s2
argument_list|)
operator|!=
literal|null
condition|)
return|return
operator|-
literal|1
return|;
comment|//c1 is child, c2 is parent
if|if
condition|(
name|getParentClass
argument_list|(
operator|(
name|Class_
operator|)
name|s2
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|,
name|s1
argument_list|)
operator|!=
literal|null
condition|)
return|return
literal|1
return|;
comment|//c2 is child, c1 is parent
return|return
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
return|;
block|}
block|}
specifier|private
name|String
name|getClassLimitConstraitName
parameter_list|(
name|SchedulingSubpart
name|subpart
parameter_list|)
block|{
if|if
condition|(
name|subpart
operator|==
literal|null
condition|)
return|return
literal|"class-limit"
return|;
name|String
name|name
init|=
name|subpart
operator|.
name|getCourseName
argument_list|()
operator|+
literal|" "
operator|+
name|subpart
operator|.
name|getItypeDesc
argument_list|()
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|sufix
init|=
name|subpart
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|sufix
operator|!=
literal|null
operator|&&
name|sufix
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|name
operator|+=
literal|" ("
operator|+
name|sufix
operator|+
literal|")"
expr_stmt|;
return|return
name|name
return|;
block|}
specifier|private
name|String
name|getClassLimitConstraitName
parameter_list|(
name|Lecture
name|lecture
parameter_list|)
block|{
return|return
name|getClassLimitConstraitName
argument_list|(
operator|(
name|SchedulingSubpart
operator|)
name|iSubparts
operator|.
name|get
argument_list|(
name|lecture
operator|.
name|getSchedulingSubpartId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|void
name|createChildrenClassLimitConstraits
parameter_list|(
name|Lecture
name|parentLecture
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parentLecture
operator|.
name|hasAnyChildren
argument_list|()
condition|)
return|return;
for|for
control|(
name|Enumeration
name|e1
init|=
name|parentLecture
operator|.
name|getChildrenSubpartIds
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Long
name|subpartId
init|=
operator|(
name|Long
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Vector
name|children
init|=
name|parentLecture
operator|.
name|getChildren
argument_list|(
name|subpartId
argument_list|)
decl_stmt|;
name|ClassLimitConstraint
name|clc
init|=
operator|new
name|ClassLimitConstraint
argument_list|(
name|parentLecture
argument_list|,
name|getClassLimitConstraitName
argument_list|(
name|parentLecture
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|isMakingSense
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|children
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|minClassLimit
argument_list|()
operator|!=
name|lecture
operator|.
name|maxClassLimit
argument_list|()
condition|)
block|{
name|isMakingSense
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isMakingSense
condition|)
continue|continue;
for|for
control|(
name|Enumeration
name|e
init|=
name|children
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|clc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|createChildrenClassLimitConstraits
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
operator|(
operator|(
name|SchedulingSubpart
operator|)
name|iSubparts
operator|.
name|get
argument_list|(
name|subpartId
argument_list|)
operator|)
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
name|clc
operator|.
name|setClassLimitDelta
argument_list|(
name|clc
operator|.
name|getClassLimitDelta
argument_list|()
operator|-
name|clazz
operator|.
name|getClassLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|iProgress
operator|.
name|trace
argument_list|(
literal|"Added constraint "
operator|+
name|clc
operator|.
name|getName
argument_list|()
operator|+
literal|" between "
operator|+
name|clc
operator|.
name|variables
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|clc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Lecture
name|getEnrollment
parameter_list|(
name|Student
name|student
parameter_list|,
name|Vector
name|lectures
parameter_list|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|lectures
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|student
operator|.
name|getLectures
argument_list|()
operator|.
name|contains
argument_list|(
name|lecture
argument_list|)
condition|)
return|return
name|lecture
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|void
name|load
parameter_list|()
block|{
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
init|=
literal|null
decl_stmt|;
name|Transaction
name|tx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|TimetableManagerDAO
name|dao
init|=
operator|new
name|TimetableManagerDAO
argument_list|()
decl_stmt|;
name|hibSession
operator|=
name|dao
operator|.
name|getSession
argument_list|()
expr_stmt|;
name|tx
operator|=
name|hibSession
operator|.
name|beginTransaction
argument_list|()
expr_stmt|;
name|load
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
name|tx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Unable to load input data, reason:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|tx
operator|.
name|rollback
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
comment|// here we need to close the session since this code may run in a separate thread
if|if
condition|(
name|hibSession
operator|!=
literal|null
operator|&&
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|hibSession
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|postSameStudentConstraint
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|boolean
name|posted
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|getChildClasses
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getChildClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|postSameStudentConstraint
argument_list|(
name|c
argument_list|,
name|type
argument_list|)
condition|)
name|posted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|posted
condition|)
return|return
literal|true
return|;
name|GroupConstraint
name|gc
init|=
operator|new
name|GroupConstraint
argument_list|(
literal|null
argument_list|,
name|type
argument_list|,
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
decl_stmt|;
name|Lecture
name|lecture
init|=
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|gc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|Class_
name|parent
init|=
name|clazz
decl_stmt|;
while|while
condition|(
operator|(
name|parent
operator|=
name|parent
operator|.
name|getParentClass
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Lecture
name|parentLecture
init|=
name|getLecture
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentLecture
operator|!=
literal|null
condition|)
name|gc
operator|.
name|addVariable
argument_list|(
name|parentLecture
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|subpart
operator|.
name|getParentSubpart
argument_list|()
operator|!=
literal|null
operator|||
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
continue|continue;
name|Class_
name|singleClazz
init|=
operator|(
name|Class_
operator|)
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|singleLecture
init|=
name|getLecture
argument_list|(
name|singleClazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|singleLecture
operator|!=
literal|null
operator|&&
operator|!
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|contains
argument_list|(
name|singleLecture
argument_list|)
condition|)
name|gc
operator|.
name|addVariable
argument_list|(
name|singleLecture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gc
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|gc
operator|.
name|removeVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|addGroupConstraint
argument_list|(
name|gc
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|propagateCommittedAssignment
parameter_list|(
name|HashSet
name|students
parameter_list|,
name|Assignment
name|assignment
parameter_list|)
block|{
name|Class_
name|clazz
init|=
name|assignment
operator|.
name|getClazz
argument_list|()
decl_stmt|;
name|Lecture
name|parentLecture
init|=
literal|null
decl_stmt|;
name|Class_
name|c
init|=
name|clazz
decl_stmt|;
while|while
condition|(
operator|(
name|parentLecture
operator|==
literal|null
operator|||
name|parentLecture
operator|.
name|isCommitted
argument_list|()
operator|)
operator|&&
name|c
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|c
operator|=
name|c
operator|.
name|getParentClass
argument_list|()
expr_stmt|;
name|parentLecture
operator|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|c
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentLecture
operator|!=
literal|null
operator|&&
operator|!
name|parentLecture
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|parentLecture
operator|.
name|sameSubpartLectures
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lecture
operator|.
name|equals
argument_list|(
name|parentLecture
argument_list|)
operator|&&
operator|!
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
comment|//iProgress.debug("[A] Students "+students+" cannot enroll "+lecture.getName()+" due to the enrollment of "+clazz.getClassLabel());
for|for
control|(
name|Iterator
name|i
init|=
name|students
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|student
operator|.
name|addCanNotEnroll
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getChildSubparts
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getChildSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|child
init|=
operator|(
name|Class_
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|equals
argument_list|(
name|child
operator|.
name|getParentClass
argument_list|()
argument_list|)
condition|)
name|propagateCommittedAssignment
argument_list|(
name|students
argument_list|,
name|clazz
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|void
name|propagateCommittedAssignment
parameter_list|(
name|HashSet
name|students
parameter_list|,
name|Class_
name|parent
parameter_list|,
name|Class_
name|clazz
parameter_list|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
operator|&&
operator|!
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
comment|//iProgress.debug("[B] Students "+students+" cannot enroll "+lecture.getName()+" due to the enrollment of "+parent.getClassLabel());
for|for
control|(
name|Iterator
name|i
init|=
name|students
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|student
operator|.
name|addCanNotEnroll
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getChildClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|child
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|propagateCommittedAssignment
argument_list|(
name|students
argument_list|,
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|loadCommittedStudentConflicts
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|Query
name|q
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|iSolverGroup
operator|.
name|length
operator|>
literal|1
operator|||
name|iSolverGroup
index|[
literal|0
index|]
operator|.
name|isExternalManager
argument_list|()
condition|)
block|{
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a, e.studentId from "
operator|+
literal|"Solution s inner join s.assignments a inner join s.studentEnrollments e "
operator|+
literal|"where "
operator|+
literal|"s.commited=true and s.owner.session.uniqueId=:sessionId and s.owner not in ("
operator|+
name|iSolverGroupIds
operator|+
literal|") and "
operator|+
literal|"a.clazz=e.clazz"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a, e.studentId from "
operator|+
literal|"Solution s inner join s.assignments a inner join s.studentEnrollments e, "
operator|+
literal|"LastLikeCourseDemand d inner join d.subjectArea sa "
operator|+
literal|"where "
operator|+
literal|"s.commited=true and s.owner.session.uniqueId=:sessionId and s.owner.uniqueId!=:ownerId and "
operator|+
literal|"a.clazz=e.clazz and e.studentId=d.student.uniqueId and sa.department.uniqueId in ("
operator|+
name|iDepartmentIds
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"ownerId"
argument_list|,
name|iSolverGroup
index|[
literal|0
index|]
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|iSessionId
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|List
name|assignmentEnrollments
init|=
name|q
operator|.
name|list
argument_list|()
decl_stmt|;
name|Hashtable
name|assignments
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|assignmentEnrollments
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
index|[]
name|result
init|=
operator|(
name|Object
index|[]
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|result
index|[
literal|0
index|]
decl_stmt|;
name|Long
name|studentId
init|=
operator|(
name|Long
operator|)
name|result
index|[
literal|1
index|]
decl_stmt|;
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|iStudents
operator|.
name|get
argument_list|(
name|studentId
argument_list|)
decl_stmt|;
if|if
condition|(
name|student
operator|!=
literal|null
condition|)
block|{
name|HashSet
name|students
init|=
operator|(
name|HashSet
operator|)
name|assignments
operator|.
name|get
argument_list|(
name|assignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|students
operator|==
literal|null
condition|)
block|{
name|students
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|assignments
operator|.
name|put
argument_list|(
name|assignment
argument_list|,
name|students
argument_list|)
expr_stmt|;
block|}
name|students
operator|.
name|add
argument_list|(
name|student
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i1
init|=
name|assignmentEnrollments
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
index|[]
name|result
init|=
operator|(
name|Object
index|[]
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|result
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|assignments
operator|.
name|containsKey
argument_list|(
name|assignment
argument_list|)
condition|)
name|hibSession
operator|.
name|evict
argument_list|(
name|assignment
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e1
init|=
name|assignments
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e1
init|=
name|assignments
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
operator|.
name|getChildClasses
argument_list|()
argument_list|)
expr_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e1
init|=
name|assignments
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getChildSubparts
argument_list|()
argument_list|)
expr_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|assignment
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading student conflicts with commited solutions ..."
argument_list|,
name|assignments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|assignments
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|HashSet
name|students
init|=
operator|(
name|HashSet
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Placement
name|committedPlacement
init|=
name|assignment
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|students
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|student
operator|.
name|addCommitedPlacement
argument_list|(
name|committedPlacement
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iLectures
operator|.
name|containsKey
argument_list|(
name|assignment
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLectures
operator|.
name|put
argument_list|(
name|assignment
operator|.
name|getClassId
argument_list|()
argument_list|,
name|committedPlacement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|committedPlacement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|propagateCommittedAssignment
argument_list|(
name|students
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|canAttend
parameter_list|(
name|Set
name|cannotAttendLectures
parameter_list|,
name|Collection
name|lectures
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|e
init|=
name|lectures
operator|.
name|iterator
argument_list|()
init|;
name|e
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|cannotAttendLectures
operator|.
name|contains
argument_list|(
name|lecture
argument_list|)
condition|)
continue|continue;
name|boolean
name|canAttend
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|hasAnyChildren
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|f
init|=
name|lecture
operator|.
name|getChildrenSubpartIds
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Long
name|subpartId
init|=
operator|(
name|Long
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canAttend
argument_list|(
name|cannotAttendLectures
argument_list|,
name|lecture
operator|.
name|getChildren
argument_list|(
name|subpartId
argument_list|)
argument_list|)
condition|)
block|{
name|canAttend
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|canAttend
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|canAttendConfigurations
parameter_list|(
name|Set
name|cannotAttendLectures
parameter_list|,
name|Vector
name|configurations
parameter_list|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|configurations
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Configuration
name|cfg
init|=
operator|(
name|Configuration
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|boolean
name|canAttend
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Enumeration
name|f
init|=
name|cfg
operator|.
name|getTopSubpartIds
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Long
name|subpartId
init|=
operator|(
name|Long
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|canAttend
argument_list|(
name|cannotAttendLectures
argument_list|,
name|cfg
operator|.
name|getTopLectures
argument_list|(
name|subpartId
argument_list|)
argument_list|)
condition|)
block|{
name|canAttend
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|canAttend
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|checkReservation
parameter_list|(
name|CourseOffering
name|course
parameter_list|,
name|Set
name|cannotAttendLectures
parameter_list|,
name|Vector
name|configurations
parameter_list|)
block|{
if|if
condition|(
name|canAttendConfigurations
argument_list|(
name|cannotAttendLectures
argument_list|,
name|configurations
argument_list|)
condition|)
return|return;
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Inconsistent course reservations for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|propagateCannotAttend
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|HashSet
name|cannotAttendLectures
parameter_list|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getChildClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|child
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|child
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
name|cannotAttendLectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|propagateCannotAttend
argument_list|(
name|child
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|propagateUpCannotAttend
parameter_list|(
name|Set
name|classes
parameter_list|,
name|HashSet
name|cannotAttendLectures
parameter_list|)
block|{
if|if
condition|(
name|classes
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|HashSet
name|parentClasses
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|HashSet
name|subparts
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|x
init|=
name|classes
operator|.
name|iterator
argument_list|()
init|;
name|x
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|cx
init|=
operator|(
name|Class_
operator|)
name|x
operator|.
name|next
argument_list|()
decl_stmt|;
empty_stmt|;
name|SchedulingSubpart
name|subpart
init|=
name|cx
operator|.
name|getSchedulingSubpart
argument_list|()
decl_stmt|;
if|if
condition|(
name|subparts
operator|.
name|add
argument_list|(
name|subpart
argument_list|)
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|classes
operator|.
name|contains
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
if|if
condition|(
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
condition|)
name|parentClasses
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getParentClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
operator|&&
operator|!
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
name|cannotAttendLectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|propagateUpCannotAttend
argument_list|(
name|parentClasses
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Set
name|computeCannotAttendLectures
parameter_list|(
name|Set
name|reservedClassIds
parameter_list|)
block|{
name|HashSet
name|cannotAttendLectures
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|HashSet
name|parentClasses
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|reservedClassIds
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Long
name|classId
init|=
operator|(
name|Long
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|cx
init|=
operator|(
name|Class_
operator|)
name|iClasses
operator|.
name|get
argument_list|(
name|classId
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
operator|==
literal|null
condition|)
name|cx
operator|=
operator|(
operator|new
name|Class_DAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|classId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|cx
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
condition|)
name|parentClasses
operator|.
name|add
argument_list|(
name|cx
operator|.
name|getParentClass
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|cx
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedClassIds
operator|.
name|contains
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
condition|)
continue|continue;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
operator|&&
operator|!
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
name|cannotAttendLectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|propagateCannotAttend
argument_list|(
name|clazz
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
block|}
block|}
name|propagateUpCannotAttend
argument_list|(
name|parentClasses
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
return|return
name|cannotAttendLectures
return|;
block|}
specifier|private
name|void
name|load
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
throws|throws
name|Exception
block|{
name|iProgress
operator|.
name|setStatus
argument_list|(
literal|"Loading input data ..."
argument_list|)
expr_stmt|;
name|SolverGroupDAO
name|dao
init|=
operator|new
name|SolverGroupDAO
argument_list|()
decl_stmt|;
name|hibSession
operator|=
name|dao
operator|.
name|getSession
argument_list|()
expr_stmt|;
name|hibSession
operator|.
name|setFlushMode
argument_list|(
name|FlushMode
operator|.
name|COMMIT
argument_list|)
expr_stmt|;
name|iSolverGroup
operator|=
literal|null
expr_stmt|;
name|iSession
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|iSolverGroup
operator|==
literal|null
condition|)
block|{
name|iSolverGroup
operator|=
operator|new
name|SolverGroup
index|[
name|iSolverGroupId
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|iSolverGroup
index|[
name|i
index|]
operator|=
name|dao
operator|.
name|get
argument_list|(
name|iSolverGroupId
index|[
name|i
index|]
argument_list|,
name|hibSession
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSolverGroup
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Unable to load solver group "
operator|+
name|iSolverGroupId
index|[
name|i
index|]
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
name|iProgress
operator|.
name|debug
argument_list|(
literal|"solver group["
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|"]: "
operator|+
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iSolverGroup
operator|==
literal|null
operator|||
name|iSolverGroup
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"No solver group loaded."
argument_list|)
expr_stmt|;
return|return;
block|}
name|iDepartmentIds
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|iSolverGroup
index|[
name|j
index|]
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Department
name|d
init|=
operator|(
name|Department
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iDepartmentIds
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|iDepartmentIds
operator|+=
literal|","
expr_stmt|;
name|iDepartmentIds
operator|+=
name|d
operator|.
name|getUniqueId
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"General.DepartmentIds"
argument_list|,
name|iDepartmentIds
argument_list|)
expr_stmt|;
name|Hashtable
name|solutions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|iSolutionId
operator|!=
literal|null
operator|&&
name|iSolutionId
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|solutions
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
comment|//iLoadStudentEnrlsFromSolution = true;
name|String
name|note
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolutionId
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Solution
name|solution
init|=
operator|(
operator|new
name|SolutionDAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|iSolutionId
index|[
name|i
index|]
argument_list|,
name|hibSession
argument_list|)
decl_stmt|;
if|if
condition|(
name|solution
operator|==
literal|null
condition|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Unable to load solution "
operator|+
name|iSolutionId
index|[
name|i
index|]
operator|+
literal|"."
argument_list|)
expr_stmt|;
return|return;
block|}
name|iProgress
operator|.
name|debug
argument_list|(
literal|"solution["
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|"] version: "
operator|+
name|solution
operator|.
name|getUniqueId
argument_list|()
operator|+
literal|" (created "
operator|+
name|solution
operator|.
name|getCreated
argument_list|()
operator|+
literal|", solver group "
operator|+
name|solution
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|solution
operator|.
name|getNote
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|note
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|note
operator|+=
literal|"\n"
expr_stmt|;
name|note
operator|+=
name|solution
operator|.
name|getNote
argument_list|()
expr_stmt|;
block|}
name|solutions
operator|.
name|put
argument_list|(
name|solution
operator|.
name|getOwner
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|solution
operator|.
name|isCommited
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
name|iLoadStudentEnrlsFromSolution
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|iLoadStudentEnrlsFromSolution
operator|&&
name|i
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|solutions
operator|.
name|containsKey
argument_list|(
name|iSolverGroupId
index|[
name|i
index|]
argument_list|)
condition|)
name|iLoadStudentEnrlsFromSolution
operator|=
literal|false
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"General.Note"
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|String
name|solutionIdStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Solution
name|solution
init|=
operator|(
name|Solution
operator|)
name|solutions
operator|.
name|get
argument_list|(
name|iSolverGroupId
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|solution
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|solutionIdStr
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|solutionIdStr
operator|+=
literal|","
expr_stmt|;
name|solutionIdStr
operator|+=
name|solution
operator|.
name|getUniqueId
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"General.SolutionId"
argument_list|,
name|solutionIdStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iSession
operator|==
literal|null
condition|)
name|iSession
operator|=
operator|(
operator|new
name|SessionDAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|iSessionId
argument_list|,
name|hibSession
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSession
operator|==
literal|null
condition|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"No session loaded."
argument_list|)
expr_stmt|;
return|return;
block|}
name|iProgress
operator|.
name|debug
argument_list|(
literal|"session: "
operator|+
name|iSession
operator|.
name|getLabel
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"Data.Term"
argument_list|,
name|iSession
operator|.
name|getAcademicYearTerm
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"Data.Initiative"
argument_list|,
name|iSession
operator|.
name|getAcademicInitiative
argument_list|()
argument_list|)
expr_stmt|;
name|iStartDay
operator|=
name|DateUtils
operator|.
name|getDayOfYear
argument_list|(
name|iSession
operator|.
name|getSessionBeginDateTime
argument_list|()
argument_list|)
expr_stmt|;
name|iEndDay
operator|=
name|DateUtils
operator|.
name|getDayOfYear
argument_list|(
name|iSession
operator|.
name|getSessionEndDateTime
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|setYear
argument_list|(
name|iSession
operator|.
name|getYear
argument_list|()
argument_list|)
expr_stmt|;
name|iAllClasses
operator|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|j
init|=
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Department
name|d
init|=
operator|(
name|Department
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|iAllClasses
operator|.
name|addAll
argument_list|(
name|d
operator|.
name|getClassesFetchWithStructure
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iAllClasses
operator|==
literal|null
operator|||
name|iAllClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"No classes to load."
argument_list|)
expr_stmt|;
return|return;
block|}
name|iProgress
operator|.
name|debug
argument_list|(
literal|"classes to load: "
operator|+
name|iAllClasses
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getInstrOfferingConfigs
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getSchedulingSubparts
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getClasses
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getClassInstructors
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|c
operator|.
name|getClassInstructors
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassInstructor
name|ci
init|=
operator|(
name|ClassInstructor
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|ci
operator|.
name|getInstructor
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|c
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getPreferences
argument_list|()
argument_list|)
expr_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|c
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getPreferences
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|c
operator|.
name|getClassInstructors
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassInstructor
name|ci
init|=
operator|(
name|ClassInstructor
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|ci
operator|.
name|getInstructor
argument_list|()
operator|.
name|getPreferences
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|c
operator|.
name|getControllingDept
argument_list|()
operator|.
name|getPreferences
argument_list|()
expr_stmt|;
name|c
operator|.
name|getManagingDept
argument_list|()
operator|.
name|getPreferences
argument_list|()
expr_stmt|;
block|}
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading classes ..."
argument_list|,
name|iAllClasses
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hashtable
name|subparts
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|offerings
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|configurations
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|altConfigurations
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|io2lectures
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|int
name|ord
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
name|loadClass
argument_list|(
name|clazz
argument_list|,
name|hibSession
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
name|lecture
operator|.
name|setOrd
argument_list|(
name|ord
operator|++
argument_list|)
expr_stmt|;
name|iClasses
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
name|loadInstructorAvailabilities
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
name|loadRoomAvailabilities
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Setting parent classes ..."
argument_list|,
name|iLectures
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
continue|continue;
name|Class_
name|parentClazz
init|=
name|clazz
operator|.
name|getParentClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentClazz
operator|!=
literal|null
condition|)
block|{
name|Lecture
name|parentLecture
init|=
literal|null
decl_stmt|;
name|Class_
name|c
init|=
name|clazz
decl_stmt|;
while|while
condition|(
operator|(
name|parentLecture
operator|==
literal|null
operator|||
name|parentLecture
operator|.
name|isCommitted
argument_list|()
operator|)
operator|&&
name|c
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|c
operator|=
name|c
operator|.
name|getParentClass
argument_list|()
expr_stmt|;
name|parentLecture
operator|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|c
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentLecture
operator|!=
literal|null
operator|&&
operator|!
name|parentLecture
operator|.
name|isCommitted
argument_list|()
condition|)
name|lecture
operator|.
name|setParent
argument_list|(
name|parentLecture
argument_list|)
expr_stmt|;
block|}
name|SchedulingSubpart
name|subpart
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
decl_stmt|;
name|InstrOfferingConfig
name|config
init|=
name|subpart
operator|.
name|getInstrOfferingConfig
argument_list|()
decl_stmt|;
name|InstructionalOffering
name|offering
init|=
name|config
operator|.
name|getInstructionalOffering
argument_list|()
decl_stmt|;
name|HashSet
name|lectures
init|=
operator|(
name|HashSet
operator|)
name|io2lectures
operator|.
name|get
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lectures
operator|==
literal|null
condition|)
block|{
name|lectures
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|io2lectures
operator|.
name|put
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|lectures
argument_list|)
expr_stmt|;
block|}
name|lectures
operator|.
name|add
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|iSubparts
operator|.
name|put
argument_list|(
name|subpart
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|subpart
argument_list|)
expr_stmt|;
if|if
condition|(
name|lecture
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|)
block|{
name|Configuration
name|cfg
init|=
operator|(
name|Configuration
operator|)
name|configurations
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfg
operator|==
literal|null
condition|)
block|{
name|cfg
operator|=
operator|new
name|Configuration
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|config
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|config
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|configurations
operator|.
name|put
argument_list|(
name|config
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
name|Vector
name|altCfgs
init|=
operator|(
name|Vector
operator|)
name|altConfigurations
operator|.
name|get
argument_list|(
name|offering
argument_list|)
decl_stmt|;
if|if
condition|(
name|altCfgs
operator|==
literal|null
condition|)
block|{
name|altCfgs
operator|=
operator|new
name|FastVector
argument_list|()
expr_stmt|;
name|altConfigurations
operator|.
name|put
argument_list|(
name|offering
argument_list|,
name|altCfgs
argument_list|)
expr_stmt|;
block|}
name|altCfgs
operator|.
name|addElement
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|setAltConfigurations
argument_list|(
name|altCfgs
argument_list|)
expr_stmt|;
block|}
name|lecture
operator|.
name|setConfiguration
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|Hashtable
name|topSubparts
init|=
operator|(
name|Hashtable
operator|)
name|offerings
operator|.
name|get
argument_list|(
name|offering
argument_list|)
decl_stmt|;
if|if
condition|(
name|topSubparts
operator|==
literal|null
condition|)
block|{
name|topSubparts
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|offerings
operator|.
name|put
argument_list|(
name|offering
argument_list|,
name|topSubparts
argument_list|)
expr_stmt|;
block|}
name|HashSet
name|topSubpartsThisConfig
init|=
operator|(
name|HashSet
operator|)
name|topSubparts
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|topSubpartsThisConfig
operator|==
literal|null
condition|)
block|{
name|topSubpartsThisConfig
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|topSubparts
operator|.
name|put
argument_list|(
name|config
argument_list|,
name|topSubpartsThisConfig
argument_list|)
expr_stmt|;
block|}
name|topSubpartsThisConfig
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Vector
name|sameSubpart
init|=
operator|(
name|Vector
operator|)
name|subparts
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sameSubpart
operator|==
literal|null
condition|)
block|{
name|sameSubpart
operator|=
operator|new
name|FastVector
argument_list|()
expr_stmt|;
name|subparts
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|,
name|sameSubpart
argument_list|)
expr_stmt|;
block|}
name|sameSubpart
operator|.
name|addElement
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|lecture
operator|.
name|setSameSubpartLectures
argument_list|(
name|sameSubpart
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
name|Vector
name|distPrefs
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|distPrefs
operator|.
name|addAll
argument_list|(
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getDistributionPreferences
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading distribution preferences ..."
argument_list|,
name|distPrefs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|distPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionPref
name|distributionPref
init|=
operator|(
name|DistributionPref
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Hibernate
operator|.
name|initialize
argument_list|(
name|distributionPref
operator|.
name|getDistributionObjects
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|distPrefs
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionPref
name|distributionPref
init|=
operator|(
name|DistributionPref
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|PreferenceLevel
operator|.
name|sNeutral
operator|.
name|equals
argument_list|(
name|distributionPref
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
name|loadGroupConstraint
argument_list|(
name|distributionPref
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|j
init|=
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|loadInstructorGroupConstraints
argument_list|(
operator|(
name|Department
operator|)
name|j
operator|.
name|next
argument_list|()
argument_list|,
name|hibSession
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iAutoSameStudents
condition|)
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Posting automatic same_students constraints ..."
argument_list|,
name|iAllClasses
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|iAllClasses
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|lecture
operator|.
name|hasAnyChildren
argument_list|()
condition|)
name|postSameStudentConstraint
argument_list|(
name|clazz
argument_list|,
name|iAutoSameStudentsConstraint
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
name|assignCommited
argument_list|()
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Posting class limit constraints ..."
argument_list|,
name|offerings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|offerings
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|InstructionalOffering
name|offering
init|=
operator|(
name|InstructionalOffering
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Hashtable
name|topSubparts
init|=
operator|(
name|Hashtable
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|topSubparts
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|subpartEntry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|InstrOfferingConfig
name|config
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|subpartEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
name|topSubpartsThisConfig
init|=
operator|(
name|Set
operator|)
name|subpartEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|topSubpartsThisConfig
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
name|Vector
name|lectures
init|=
operator|(
name|Vector
operator|)
name|subparts
operator|.
name|get
argument_list|(
name|subpart
argument_list|)
decl_stmt|;
name|boolean
name|isMakingSense
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Enumeration
name|e4
init|=
name|lectures
operator|.
name|elements
argument_list|()
init|;
name|e4
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e4
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|minClassLimit
argument_list|()
operator|!=
name|lecture
operator|.
name|maxClassLimit
argument_list|()
condition|)
block|{
name|isMakingSense
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isMakingSense
condition|)
continue|continue;
if|if
condition|(
name|subpart
operator|.
name|getParentSubpart
argument_list|()
operator|==
literal|null
condition|)
block|{
name|ClassLimitConstraint
name|clc
init|=
operator|new
name|ClassLimitConstraint
argument_list|(
name|config
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|,
name|getClassLimitConstraitName
argument_list|(
name|subpart
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
name|e4
init|=
name|lectures
operator|.
name|elements
argument_list|()
init|;
name|e4
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e4
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|clc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|createChildrenClassLimitConstraits
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i4
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i4
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i4
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
name|clc
operator|.
name|setClassLimitDelta
argument_list|(
name|clc
operator|.
name|getClassLimitDelta
argument_list|()
operator|-
name|clazz
operator|.
name|getClassLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|iProgress
operator|.
name|trace
argument_list|(
literal|"Added constraint "
operator|+
name|clc
operator|.
name|getName
argument_list|()
operator|+
literal|" between "
operator|+
name|clc
operator|.
name|variables
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|clc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Hashtable
name|clcs
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e4
init|=
name|lectures
operator|.
name|elements
argument_list|()
init|;
name|e4
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e4
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|iClasses
operator|.
name|get
argument_list|(
name|lecture
operator|.
name|getClassId
argument_list|()
argument_list|)
decl_stmt|;
name|Class_
name|parentClazz
init|=
name|clazz
operator|.
name|getParentClass
argument_list|()
decl_stmt|;
name|ClassLimitConstraint
name|clc
init|=
operator|(
name|ClassLimitConstraint
operator|)
name|clcs
operator|.
name|get
argument_list|(
name|parentClazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|clc
operator|==
literal|null
condition|)
block|{
name|clc
operator|=
operator|new
name|ClassLimitConstraint
argument_list|(
name|parentClazz
operator|.
name|getClassLimit
argument_list|()
argument_list|,
name|parentClazz
operator|.
name|getClassLabel
argument_list|()
argument_list|)
expr_stmt|;
name|clcs
operator|.
name|put
argument_list|(
name|parentClazz
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|clc
argument_list|)
expr_stmt|;
block|}
name|clc
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|createChildrenClassLimitConstraits
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i4
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i4
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i4
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iLectures
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|Class_
name|parentClazz
init|=
name|clazz
operator|.
name|getParentClass
argument_list|()
decl_stmt|;
name|ClassLimitConstraint
name|clc
init|=
operator|(
name|ClassLimitConstraint
operator|)
name|clcs
operator|.
name|get
argument_list|(
name|parentClazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|clc
operator|!=
literal|null
condition|)
name|clc
operator|.
name|setClassLimitDelta
argument_list|(
name|clc
operator|.
name|getClassLimitDelta
argument_list|()
operator|-
name|clazz
operator|.
name|getClassLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i4
init|=
name|clcs
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i4
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassLimitConstraint
name|clc
init|=
operator|(
name|ClassLimitConstraint
operator|)
name|i4
operator|.
name|next
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|trace
argument_list|(
literal|"Added constraint "
operator|+
name|clc
operator|.
name|getName
argument_list|()
operator|+
literal|" between "
operator|+
name|clc
operator|.
name|variables
argument_list|()
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|clc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
name|Hashtable
name|demands
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|demandsPermId
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|StringBuffer
name|subjectAreas
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iSolverGroup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|Iterator
name|j
init|=
name|iSolverGroup
index|[
name|i
index|]
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Department
name|dept
init|=
operator|(
name|Department
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|dept
operator|.
name|getSubjectAreas
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SubjectArea
name|sa
init|=
operator|(
name|SubjectArea
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|subjectAreas
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|subjectAreas
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|subjectAreas
operator|.
name|append
argument_list|(
name|sa
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|demands
operator|.
name|put
argument_list|(
name|sa
operator|.
name|getUniqueId
argument_list|()
argument_list|,
operator|new
name|Hashtable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|subjectAreas
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select d.subjectArea.uniqueId, d.courseNbr, d.student.uniqueId, d.coursePermId "
operator|+
literal|"from LastLikeCourseDemand d where d.subjectArea.uniqueId in ("
operator|+
name|subjectAreas
operator|+
literal|")"
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|q
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
index|[]
name|d
init|=
operator|(
name|Object
index|[]
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Long
name|subjectAreaId
init|=
operator|(
name|Long
operator|)
name|d
index|[
literal|0
index|]
decl_stmt|;
name|String
name|courseNbr
init|=
operator|(
name|String
operator|)
name|d
index|[
literal|1
index|]
decl_stmt|;
name|Long
name|studentId
init|=
operator|(
name|Long
operator|)
name|d
index|[
literal|2
index|]
decl_stmt|;
name|String
name|coursePermId
init|=
operator|(
name|String
operator|)
name|d
index|[
literal|3
index|]
decl_stmt|;
name|Hashtable
name|demandsThisSubjArea
init|=
operator|(
name|Hashtable
operator|)
name|demands
operator|.
name|get
argument_list|(
name|subjectAreaId
argument_list|)
decl_stmt|;
name|HashSet
name|studentIds
init|=
operator|(
name|HashSet
operator|)
name|demandsThisSubjArea
operator|.
name|get
argument_list|(
name|courseNbr
argument_list|)
decl_stmt|;
if|if
condition|(
name|studentIds
operator|==
literal|null
condition|)
block|{
name|studentIds
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|demandsThisSubjArea
operator|.
name|put
argument_list|(
name|courseNbr
argument_list|,
name|studentIds
argument_list|)
expr_stmt|;
block|}
name|studentIds
operator|.
name|add
argument_list|(
name|studentId
argument_list|)
expr_stmt|;
if|if
condition|(
name|coursePermId
operator|!=
literal|null
condition|)
block|{
name|studentIds
operator|=
operator|(
name|HashSet
operator|)
name|demandsPermId
operator|.
name|get
argument_list|(
name|coursePermId
argument_list|)
expr_stmt|;
if|if
condition|(
name|studentIds
operator|==
literal|null
condition|)
block|{
name|studentIds
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|demandsPermId
operator|.
name|put
argument_list|(
name|coursePermId
argument_list|,
name|studentIds
argument_list|)
expr_stmt|;
block|}
name|studentIds
operator|.
name|add
argument_list|(
name|studentId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading students ..."
argument_list|,
name|offerings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hashtable
name|offering2students
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e1
init|=
name|offerings
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructionalOffering
name|offering
init|=
operator|(
name|InstructionalOffering
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|int
name|totalCourseLimit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CourseOffering
name|course
init|=
operator|(
name|CourseOffering
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|courseLimit
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|offering
operator|.
name|getCourseReservations
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CourseOfferingReservation
name|r
init|=
operator|(
name|CourseOfferingReservation
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getCourseOffering
argument_list|()
operator|.
name|equals
argument_list|(
name|course
argument_list|)
condition|)
name|courseLimit
operator|=
name|r
operator|.
name|getReserved
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|courseLimit
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|courseLimit
operator|=
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
else|else
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Cross-listed course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" does not have any course reservation."
argument_list|)
expr_stmt|;
name|courseLimit
operator|=
name|course
operator|.
name|getDemand
argument_list|()
operator|.
name|intValue
argument_list|()
operator|+
operator|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getDemand
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
name|totalCourseLimit
operator|+=
name|courseLimit
expr_stmt|;
block|}
name|Double
name|factor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|totalCourseLimit
operator|<
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Total number of course reservations is bellow the offering limit for instructional offering "
operator|+
name|getOfferingLabel
argument_list|(
name|offering
argument_list|)
operator|+
literal|" ("
operator|+
name|totalCourseLimit
operator|+
literal|"<"
operator|+
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
operator|+
literal|")."
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalCourseLimit
operator|>
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Total number of course reservations exceeds the offering limit for instructional offering "
operator|+
name|getOfferingLabel
argument_list|(
name|offering
argument_list|)
operator|+
literal|" ("
operator|+
name|totalCourseLimit
operator|+
literal|">"
operator|+
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
operator|+
literal|")."
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalCourseLimit
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|totalCourseLimit
operator|!=
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
condition|)
name|factor
operator|=
operator|new
name|Double
argument_list|(
operator|(
operator|(
name|double
operator|)
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
operator|/
name|totalCourseLimit
argument_list|)
expr_stmt|;
name|Hashtable
name|computedCourseReservations
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Hashtable
name|course2students
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CourseOffering
name|course
init|=
operator|(
name|CourseOffering
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|Set
name|studentIds
init|=
literal|null
decl_stmt|;
name|Hashtable
name|demandsThisSubjArea
init|=
operator|(
name|Hashtable
operator|)
name|demands
operator|.
name|get
argument_list|(
name|course
operator|.
name|getSubjectArea
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|demandsThisSubjArea
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|course
operator|.
name|getPermId
argument_list|()
operator|!=
literal|null
operator|&&
name|demandsPermId
operator|.
name|containsKey
argument_list|(
name|course
operator|.
name|getPermId
argument_list|()
argument_list|)
condition|)
name|studentIds
operator|=
operator|(
name|Set
operator|)
name|demandsPermId
operator|.
name|get
argument_list|(
name|course
operator|.
name|getPermId
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|studentIds
operator|=
operator|(
name|Set
operator|)
name|demandsThisSubjArea
operator|.
name|get
argument_list|(
name|course
operator|.
name|getCourseNbr
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
name|courseDemands
init|=
name|course
operator|.
name|getCourseOfferingDemands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|courseDemands
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|studentIds
operator|=
operator|new
name|HashSet
argument_list|(
name|courseDemands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|courseDemands
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|LastLikeCourseDemand
name|demand
init|=
operator|(
name|LastLikeCourseDemand
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
name|studentIds
operator|.
name|add
argument_list|(
name|demand
operator|.
name|getStudent
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|demandsThisSubjArea
operator|=
operator|(
name|Hashtable
operator|)
name|demands
operator|.
name|get
argument_list|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getSubjectArea
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|demandsThisSubjArea
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|studentIds
operator|==
literal|null
condition|)
name|studentIds
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
if|if
condition|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getPermId
argument_list|()
operator|!=
literal|null
operator|&&
name|demandsPermId
operator|.
name|containsKey
argument_list|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getPermId
argument_list|()
argument_list|)
condition|)
block|{
name|studentIds
operator|.
name|addAll
argument_list|(
operator|(
name|Set
operator|)
name|demandsPermId
operator|.
name|get
argument_list|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getPermId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|studentIds
operator|.
name|addAll
argument_list|(
operator|(
name|Set
operator|)
name|demandsThisSubjArea
operator|.
name|get
argument_list|(
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getCourseNbr
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
name|courseDemands
init|=
name|course
operator|.
name|getDemandOffering
argument_list|()
operator|.
name|getCourseOfferingDemands
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|courseDemands
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|studentIds
operator|==
literal|null
condition|)
name|studentIds
operator|=
operator|new
name|HashSet
argument_list|(
name|courseDemands
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|courseDemands
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|LastLikeCourseDemand
name|demand
init|=
operator|(
name|LastLikeCourseDemand
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
name|studentIds
operator|.
name|add
argument_list|(
name|demand
operator|.
name|getStudent
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|courseLimit
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|offering
operator|.
name|getCourseReservations
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CourseOfferingReservation
name|r
init|=
operator|(
name|CourseOfferingReservation
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getCourseOffering
argument_list|()
operator|.
name|equals
argument_list|(
name|course
argument_list|)
condition|)
name|courseLimit
operator|=
name|r
operator|.
name|getReserved
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|courseLimit
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|courseLimit
operator|=
name|offering
operator|.
name|getLimit
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
else|else
block|{
name|courseLimit
operator|=
name|studentIds
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|factor
operator|!=
literal|null
condition|)
name|courseLimit
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|courseLimit
operator|*
name|factor
operator|.
name|doubleValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|studentIds
operator|==
literal|null
operator|||
name|studentIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|info
argument_list|(
literal|"No student enrollments for offering "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|courseLimit
operator|==
literal|0
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"No reserved space for students of offering "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|double
name|weight
init|=
operator|(
name|courseLimit
operator|==
literal|0
condition|?
literal|1.0
else|:
operator|(
name|double
operator|)
name|courseLimit
operator|/
name|studentIds
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
name|Set
name|cannotAttendLectures
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|HashSet
name|reservedClasses
init|=
operator|new
name|HashSet
argument_list|(
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct r.owner from CourseOfferingReservation r "
operator|+
literal|"where r.courseOffering.uniqueId=:courseId and r.ownerClassId='C'"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"courseId"
argument_list|,
name|course
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|list
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reservedClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Course requests for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" are "
operator|+
name|reservedClasses
argument_list|)
expr_stmt|;
name|cannotAttendLectures
operator|=
name|computeCannotAttendLectures
argument_list|(
name|reservedClasses
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Prohibited lectures for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" are "
operator|+
name|cannotAttendLectures
argument_list|)
expr_stmt|;
name|checkReservation
argument_list|(
name|course
argument_list|,
name|cannotAttendLectures
argument_list|,
operator|(
name|Vector
operator|)
name|altConfigurations
operator|.
name|get
argument_list|(
name|offering
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Hashtable
name|totalClassLimit
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|reservedClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Long
name|classId
init|=
operator|(
name|Long
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|iClasses
operator|.
name|get
argument_list|(
name|classId
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
name|clazz
operator|=
operator|(
operator|new
name|Class_DAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|classId
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
continue|continue;
name|Integer
name|tcl
init|=
operator|(
name|Integer
operator|)
name|totalClassLimit
operator|.
name|get
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
decl_stmt|;
name|totalClassLimit
operator|.
name|put
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|,
operator|new
name|Integer
argument_list|(
operator|(
name|tcl
operator|==
literal|null
condition|?
literal|0
else|:
name|tcl
operator|.
name|intValue
argument_list|()
operator|)
operator|+
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|totalClassLimit
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
operator|(
operator|(
name|Integer
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|courseLimit
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|courseLimit
operator|>
name|limit
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Too little space reserved in "
operator|+
name|getSubpartLabel
argument_list|(
name|subpart
argument_list|)
operator|+
literal|" for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" ("
operator|+
name|limit
operator|+
literal|"<"
operator|+
name|courseLimit
operator|+
literal|")."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|offering
operator|.
name|getCourseOfferings
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CourseOffering
name|co
init|=
operator|(
name|CourseOffering
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|co
operator|.
name|equals
argument_list|(
name|course
argument_list|)
condition|)
continue|continue;
name|Hashtable
name|cannotAttendClasses
init|=
operator|(
name|Hashtable
operator|)
name|computedCourseReservations
operator|.
name|get
argument_list|(
name|co
argument_list|)
decl_stmt|;
if|if
condition|(
name|cannotAttendClasses
operator|==
literal|null
condition|)
block|{
name|cannotAttendClasses
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|computedCourseReservations
operator|.
name|put
argument_list|(
name|co
argument_list|,
name|cannotAttendClasses
argument_list|)
expr_stmt|;
block|}
name|HashSet
name|cannotAttendClassesThisSubpart
init|=
operator|(
name|HashSet
operator|)
name|cannotAttendClasses
operator|.
name|get
argument_list|(
name|subpart
argument_list|)
decl_stmt|;
if|if
condition|(
name|cannotAttendClassesThisSubpart
operator|==
literal|null
condition|)
block|{
name|cannotAttendClassesThisSubpart
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|cannotAttendClasses
operator|.
name|put
argument_list|(
name|subpart
argument_list|,
name|cannotAttendClassesThisSubpart
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|k
init|=
name|reservedClasses
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Long
name|classId
init|=
operator|(
name|Long
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|iClasses
operator|.
name|get
argument_list|(
name|classId
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
name|clazz
operator|=
operator|(
operator|new
name|Class_DAO
argument_list|()
operator|)
operator|.
name|get
argument_list|(
name|classId
argument_list|)
expr_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|equals
argument_list|(
name|subpart
argument_list|)
condition|)
name|cannotAttendClassesThisSubpart
operator|.
name|add
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|Iterator
name|i3
init|=
name|studentIds
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Long
name|studentId
init|=
operator|(
name|Long
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|iStudents
operator|.
name|get
argument_list|(
name|studentId
argument_list|)
decl_stmt|;
if|if
condition|(
name|student
operator|==
literal|null
condition|)
block|{
name|student
operator|=
operator|new
name|Student
argument_list|(
name|studentId
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addStudent
argument_list|(
name|student
argument_list|)
expr_stmt|;
name|iStudents
operator|.
name|put
argument_list|(
name|studentId
argument_list|,
name|student
argument_list|)
expr_stmt|;
block|}
name|student
operator|.
name|addOffering
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|weight
argument_list|)
expr_stmt|;
name|Set
name|students
init|=
operator|(
name|Set
operator|)
name|offering2students
operator|.
name|get
argument_list|(
name|offering
argument_list|)
decl_stmt|;
if|if
condition|(
name|students
operator|==
literal|null
condition|)
block|{
name|students
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|offering2students
operator|.
name|put
argument_list|(
name|offering
argument_list|,
name|students
argument_list|)
expr_stmt|;
block|}
name|students
operator|.
name|add
argument_list|(
name|student
argument_list|)
expr_stmt|;
name|Set
name|cstudents
init|=
operator|(
name|Set
operator|)
name|course2students
operator|.
name|get
argument_list|(
name|course
argument_list|)
decl_stmt|;
if|if
condition|(
name|cstudents
operator|==
literal|null
condition|)
block|{
name|cstudents
operator|=
operator|new
name|HashSet
argument_list|()
expr_stmt|;
name|course2students
operator|.
name|put
argument_list|(
name|course
argument_list|,
name|cstudents
argument_list|)
expr_stmt|;
block|}
name|cstudents
operator|.
name|add
argument_list|(
name|student
argument_list|)
expr_stmt|;
name|student
operator|.
name|addCanNotEnroll
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i1
init|=
name|computedCourseReservations
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry1
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|CourseOffering
name|course
init|=
operator|(
name|CourseOffering
operator|)
name|entry1
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Hashtable
name|cannotAttendClasses
init|=
operator|(
name|Hashtable
operator|)
name|entry1
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|HashSet
name|reservedClasses
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|cannotAttendClasses
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry2
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|entry2
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|HashSet
name|cannotAttendClassesThisSubpart
init|=
operator|(
name|HashSet
operator|)
name|entry2
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|cannotAttendClassesThisSubpart
operator|.
name|contains
argument_list|(
name|clazz
argument_list|)
condition|)
continue|continue;
name|reservedClasses
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|reservedClasses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Set
name|students
init|=
operator|(
name|Set
operator|)
name|course2students
operator|.
name|get
argument_list|(
name|course
argument_list|)
decl_stmt|;
if|if
condition|(
name|students
operator|==
literal|null
operator|||
name|students
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Course requests for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" are "
operator|+
name|reservedClasses
argument_list|)
expr_stmt|;
name|Set
name|cannotAttendLectures
init|=
name|computeCannotAttendLectures
argument_list|(
name|reservedClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|cannotAttendLectures
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|students
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|student
operator|.
name|addCanNotEnroll
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|cannotAttendLectures
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|Set
name|allCannotAttendLectures
init|=
operator|(
name|Set
operator|)
name|student
operator|.
name|canNotEnrollSections
argument_list|()
operator|.
name|get
argument_list|(
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|)
decl_stmt|;
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Prohibited lectures for course "
operator|+
name|getOfferingLabel
argument_list|(
name|course
argument_list|)
operator|+
literal|" are "
operator|+
name|allCannotAttendLectures
argument_list|)
expr_stmt|;
name|checkReservation
argument_list|(
name|course
argument_list|,
name|allCannotAttendLectures
argument_list|,
operator|(
name|Vector
operator|)
name|altConfigurations
operator|.
name|get
argument_list|(
name|offering
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
name|iProgress
operator|.
name|debug
argument_list|(
name|iStudents
operator|.
name|size
argument_list|()
operator|+
literal|" students loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
name|loadCommittedStudentConflicts
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|solutions
operator|!=
literal|null
operator|&&
name|iLoadStudentEnrlsFromSolution
condition|)
block|{
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|Solution
name|solution
init|=
operator|(
name|Solution
operator|)
name|solutions
operator|.
name|get
argument_list|(
name|iSolverGroupId
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
name|List
name|studentEnrls
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct e.studentId, e.clazz.uniqueId from StudentEnrollment e where e.solution.uniqueId=:solutionId"
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|solution
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|list
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading student enrolments ["
operator|+
operator|(
name|idx
operator|+
literal|1
operator|)
operator|+
literal|"] ..."
argument_list|,
name|studentEnrls
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hashtable
name|subpart2students
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|studentEnrls
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
index|[]
init|=
operator|(
name|Object
index|[]
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Long
name|studentId
init|=
operator|(
name|Long
operator|)
name|o
index|[
literal|0
index|]
decl_stmt|;
name|Long
name|clazzId
init|=
operator|(
name|Long
operator|)
name|o
index|[
literal|1
index|]
decl_stmt|;
name|Student
name|student
init|=
operator|(
name|Student
operator|)
name|iStudents
operator|.
name|get
argument_list|(
name|studentId
argument_list|)
decl_stmt|;
if|if
condition|(
name|student
operator|==
literal|null
condition|)
continue|continue;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|iLectures
operator|.
name|get
argument_list|(
name|clazzId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|student
operator|.
name|hasOffering
argument_list|(
name|lecture
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getOfferingId
argument_list|()
argument_list|)
operator|&&
name|student
operator|.
name|canEnroll
argument_list|(
name|lecture
argument_list|)
condition|)
block|{
name|student
operator|.
name|addLecture
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|lecture
operator|.
name|addStudent
argument_list|(
name|student
argument_list|)
expr_stmt|;
block|}
block|}
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasRoomAvailability
argument_list|()
condition|)
name|loadRoomAvailability
argument_list|(
name|RoomAvailability
operator|.
name|getInstance
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Initial sectioning ..."
argument_list|,
name|offerings
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e1
init|=
name|offerings
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructionalOffering
name|offering
init|=
operator|(
name|InstructionalOffering
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Set
name|students
init|=
operator|(
name|Set
operator|)
name|offering2students
operator|.
name|get
argument_list|(
name|offering
argument_list|)
decl_stmt|;
if|if
condition|(
name|students
operator|==
literal|null
condition|)
continue|continue;
name|InitialSectioning
operator|.
name|initialSectioningCfg
argument_list|(
name|iProgress
argument_list|,
name|offering
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|offering
operator|.
name|getCourseName
argument_list|()
argument_list|,
name|students
argument_list|,
operator|(
name|Vector
operator|)
name|altConfigurations
operator|.
name|get
argument_list|(
name|offering
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     		Hashtable topSubparts = (Hashtable)entry.getValue();     		for (Iterator i2=topSubparts.entrySet().iterator();i2.hasNext();) {     			Map.Entry subpartEntry = (Map.Entry)i2.next();     			InstrOfferingConfig config = (InstrOfferingConfig)subpartEntry.getKey();     			Set topSubpartsThisConfig = (Set)subpartEntry.getValue();     			for (Iterator i3=topSubpartsThisConfig.iterator();i3.hasNext();) {         			SchedulingSubpart subpart = (SchedulingSubpart)i3.next();         			Vector lectures = (Vector)subparts.get(subpart);         			initialSectioning(offering.getUniqueId(), offering.getCourseName(),students,lectures);     			}     		}     		*/
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e
init|=
name|iStudents
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
operator|(
operator|(
name|Student
operator|)
name|e
operator|.
name|nextElement
argument_list|()
operator|)
operator|.
name|clearDistanceCache
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Computing jenrl ..."
argument_list|,
name|iStudents
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hashtable
name|jenrls
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|iStudents
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|st
init|=
operator|(
name|Student
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|st
operator|.
name|getLectures
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|l1
init|=
operator|(
name|Lecture
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i3
init|=
name|st
operator|.
name|getLectures
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|l2
init|=
operator|(
name|Lecture
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|l1
operator|.
name|getId
argument_list|()
operator|>=
name|l2
operator|.
name|getId
argument_list|()
condition|)
continue|continue;
name|Hashtable
name|x
init|=
operator|(
name|Hashtable
operator|)
name|jenrls
operator|.
name|get
argument_list|(
name|l1
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|null
condition|)
block|{
name|x
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
name|jenrls
operator|.
name|put
argument_list|(
name|l1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|JenrlConstraint
name|jenrl
init|=
operator|(
name|JenrlConstraint
operator|)
name|x
operator|.
name|get
argument_list|(
name|l2
argument_list|)
decl_stmt|;
if|if
condition|(
name|jenrl
operator|==
literal|null
condition|)
block|{
name|jenrl
operator|=
operator|new
name|JenrlConstraint
argument_list|()
expr_stmt|;
name|jenrl
operator|.
name|addVariable
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|jenrl
operator|.
name|addVariable
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|jenrl
argument_list|)
expr_stmt|;
name|x
operator|.
name|put
argument_list|(
name|l2
argument_list|,
name|jenrl
argument_list|)
expr_stmt|;
block|}
name|jenrl
operator|.
name|incJenrl
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
block|}
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|solutions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|iSolverGroupId
operator|.
name|length
condition|;
name|idx
operator|++
control|)
block|{
name|Solution
name|solution
init|=
operator|(
name|Solution
operator|)
name|solutions
operator|.
name|get
argument_list|(
name|iSolverGroupId
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|solution
operator|==
literal|null
condition|)
continue|continue;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Creating initial assignment ["
operator|+
operator|(
name|idx
operator|+
literal|1
operator|)
operator|+
literal|"] ..."
argument_list|,
name|solution
operator|.
name|getAssignments
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|solution
operator|.
name|getAssignments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
name|loadAssignment
argument_list|(
name|assignment
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|hibSession
operator|.
name|isOpen
argument_list|()
condition|)
name|iProgress
operator|.
name|fatal
argument_list|(
literal|"Hibernate session not open."
argument_list|)
expr_stmt|;
if|if
condition|(
name|iSpread
condition|)
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Posting automatic spread constraints ..."
argument_list|,
name|subparts
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e1
init|=
name|subparts
operator|.
name|keys
argument_list|()
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|subpart
operator|.
name|isAutoSpreadInTime
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|iProgress
operator|.
name|debug
argument_list|(
literal|"Automatic spread constraint disabled for "
operator|+
name|getSubpartLabel
argument_list|(
name|subpart
argument_list|)
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/*     			if (subpart.getClasses().size()<=5) {     				GroupConstraint gc = new GroupConstraint(new Long(-1),GroupConstraint.TYPE_DIFF_TIME,PreferenceLevel.sStronglyPreferred);     				for (Iterator i2=subpart.getClasses().iterator();i2.hasNext();) {     					Class_ clazz = (Class_)i2.next();     					Lecture lecture = (Lecture)iLectures.get(clazz.getUniqueId());     					if (lecture==null) continue;     					gc.addVariable(lecture);     				}     				getModel().addConstraint(gc);     			} else {     			*/
name|SpreadConstraint
name|spread
init|=
operator|new
name|SpreadConstraint
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
name|subpart
operator|.
name|getCourseName
argument_list|()
operator|+
literal|" "
operator|+
name|subpart
operator|.
name|getItypeDesc
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|getLecture
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|lecture
operator|==
literal|null
condition|)
continue|continue;
name|spread
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spread
operator|.
name|variables
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|iProgress
operator|.
name|warn
argument_list|(
literal|"No class for course "
operator|+
name|getSubpartLabel
argument_list|(
name|subpart
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|spread
argument_list|)
expr_stmt|;
comment|/*     			}     			*/
comment|//iProgress.trace("Constraint "+spread+" added.");
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|iDeptBalancing
condition|)
block|{
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Creating dept. spread constraints ..."
argument_list|,
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Hashtable
name|depSpreadConstraints
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|getDepartment
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|DepartmentSpreadConstraint
name|deptConstr
init|=
operator|(
name|DepartmentSpreadConstraint
operator|)
name|depSpreadConstraints
operator|.
name|get
argument_list|(
name|lecture
operator|.
name|getDepartment
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|deptConstr
operator|==
literal|null
condition|)
block|{
name|deptConstr
operator|=
operator|new
name|DepartmentSpreadConstraint
argument_list|(
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
name|lecture
operator|.
name|getDepartment
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|iDeptNames
operator|.
name|get
argument_list|(
name|lecture
operator|.
name|getDepartment
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|depSpreadConstraints
operator|.
name|put
argument_list|(
name|lecture
operator|.
name|getDepartment
argument_list|()
argument_list|,
name|deptConstr
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addConstraint
argument_list|(
name|deptConstr
argument_list|)
expr_stmt|;
block|}
name|deptConstr
operator|.
name|addVariable
argument_list|(
name|lecture
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
block|}
block|}
name|purgeInvalidValues
argument_list|()
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|getModel
argument_list|()
operator|.
name|constraints
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|SpreadConstraint
condition|)
operator|(
operator|(
name|SpreadConstraint
operator|)
name|c
operator|)
operator|.
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|DiscouragedRoomConstraint
condition|)
operator|(
operator|(
name|DiscouragedRoomConstraint
operator|)
name|c
operator|)
operator|.
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|MinimizeNumberOfUsedRoomsConstraint
condition|)
operator|(
operator|(
name|MinimizeNumberOfUsedRoomsConstraint
operator|)
name|c
operator|)
operator|.
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|instanceof
name|MinimizeNumberOfUsedGroupsOfTime
condition|)
operator|(
operator|(
name|MinimizeNumberOfUsedGroupsOfTime
operator|)
name|c
operator|)
operator|.
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Checking for inconsistencies..."
argument_list|,
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|lecture
operator|.
name|students
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Student
name|s
init|=
operator|(
name|Student
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|canEnroll
argument_list|(
name|lecture
argument_list|)
condition|)
name|iProgress
operator|.
name|info
argument_list|(
literal|"Invalid student enrollment of student "
operator|+
name|s
operator|.
name|getId
argument_list|()
operator|+
literal|" in class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" found."
argument_list|)
expr_stmt|;
block|}
comment|//check same instructor constraint
if|if
condition|(
operator|!
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lecture
operator|.
name|timeLocations
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|lecture
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|f
init|=
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|other
init|=
operator|(
name|Lecture
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
name|other
operator|.
name|timeLocations
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|lecture
operator|.
name|getClassId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|getClassId
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|Placement
name|p1
init|=
operator|(
name|Placement
operator|)
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|firstElement
argument_list|()
decl_stmt|;
name|Placement
name|p2
init|=
operator|(
name|Placement
operator|)
name|other
operator|.
name|values
argument_list|()
operator|.
name|firstElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|other
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|g
init|=
name|lecture
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|g
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|g
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|other
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|contains
argument_list|(
name|ic
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p1
operator|.
name|canShareRooms
argument_list|(
name|p2
argument_list|)
operator|&&
name|p1
operator|.
name|sameRooms
argument_list|(
name|p2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p1
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|p2
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Same instructor and overlapping time required:"
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p1
operator|.
name|getLongName
argument_list|()
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|other
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p2
operator|.
name|getLongName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|ic
operator|.
name|getDistancePreference
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|==
name|PreferenceLevel
operator|.
name|sIntLevelProhibited
operator|&&
name|lecture
operator|.
name|roomLocations
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|other
operator|.
name|roomLocations
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Same instructor, back-to-back time and rooms too far (distance="
operator|+
name|Math
operator|.
name|round
argument_list|(
literal|10.0
operator|*
name|Placement
operator|.
name|getDistance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
operator|+
literal|"m) required:"
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p1
operator|.
name|getLongName
argument_list|()
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|other
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p2
operator|.
name|getLongName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|lecture
operator|.
name|isSingleton
argument_list|()
condition|)
continue|continue;
for|for
control|(
name|Enumeration
name|f
init|=
name|getModel
argument_list|()
operator|.
name|variables
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|other
init|=
operator|(
name|Lecture
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|other
operator|.
name|isSingleton
argument_list|()
operator|||
name|lecture
operator|.
name|getClassId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|other
operator|.
name|getClassId
argument_list|()
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|Placement
name|p1
init|=
operator|(
name|Placement
operator|)
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|firstElement
argument_list|()
decl_stmt|;
name|Placement
name|p2
init|=
operator|(
name|Placement
operator|)
name|other
operator|.
name|values
argument_list|()
operator|.
name|firstElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|p1
operator|.
name|shareRooms
argument_list|(
name|p2
argument_list|)
operator|&&
name|p1
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|p2
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|&&
operator|!
name|p1
operator|.
name|canShareRooms
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Same room and overlapping time required:"
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p1
operator|.
name|getLongName
argument_list|()
operator|+
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;"
operator|+
name|getClassLabel
argument_list|(
name|other
argument_list|)
operator|+
literal|"&larr; "
operator|+
name|p2
operator|.
name|getLongName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lecture
operator|.
name|getAssignment
argument_list|()
operator|==
literal|null
condition|)
block|{
name|Placement
name|placement
init|=
operator|(
name|Placement
operator|)
name|lecture
operator|.
name|values
argument_list|()
operator|.
name|firstElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|placement
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|String
name|reason
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Enumeration
name|g
init|=
name|lecture
operator|.
name|getInstructorConstraints
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|g
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|InstructorConstraint
name|ic
init|=
operator|(
name|InstructorConstraint
operator|)
name|g
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ic
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|placement
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;instructor "
operator|+
name|ic
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
if|if
condition|(
name|lecture
operator|.
name|getNrRooms
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|placement
operator|.
name|isMultiRoom
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|f
init|=
name|placement
operator|.
name|getRoomLocations
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|f
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomLocation
name|roomLocation
init|=
operator|(
name|RoomLocation
operator|)
name|f
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|roomLocation
operator|.
name|getRoomConstraint
argument_list|()
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|placement
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|lecture
operator|.
name|getScheduler
argument_list|()
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;room "
operator|+
name|roomLocation
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|placement
operator|.
name|getRoomLocation
argument_list|()
operator|.
name|getRoomConstraint
argument_list|()
operator|.
name|isAvailable
argument_list|(
name|lecture
argument_list|,
name|placement
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|lecture
operator|.
name|getScheduler
argument_list|()
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;room "
operator|+
name|placement
operator|.
name|getRoomLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" not available"
expr_stmt|;
block|}
block|}
name|Hashtable
name|conflictConstraints
init|=
name|getModel
argument_list|()
operator|.
name|conflictConstraints
argument_list|(
name|placement
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|conflictConstraints
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Enumeration
name|ex
init|=
name|conflictConstraints
operator|.
name|keys
argument_list|()
init|;
name|ex
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Constraint
name|c
init|=
operator|(
name|Constraint
operator|)
name|ex
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Collection
name|vals
init|=
operator|(
name|Collection
operator|)
name|conflictConstraints
operator|.
name|get
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|vals
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|p
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|l
init|=
operator|(
name|Lecture
operator|)
name|p
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|isCommitted
argument_list|()
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;conflict with committed assignment "
operator|+
name|getClassLabel
argument_list|(
name|l
argument_list|)
operator|+
literal|" = "
operator|+
name|p
operator|.
name|getLongName
argument_list|()
operator|+
literal|" (in constraint "
operator|+
name|c
operator|+
literal|")"
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|placement
argument_list|)
condition|)
name|reason
operator|+=
literal|"<br>&nbsp;&nbsp;&nbsp;&nbsp;constraint "
operator|+
name|c
expr_stmt|;
block|}
block|}
block|}
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Class "
operator|+
name|getClassLabel
argument_list|(
name|lecture
argument_list|)
operator|+
literal|" requires an invalid placement "
operator|+
name|placement
operator|.
name|getLongName
argument_list|()
operator|+
operator|(
name|reason
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|"."
else|:
literal|":"
operator|+
name|reason
operator|)
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|iAssignSingleton
operator|&&
name|getModel
argument_list|()
operator|.
name|conflictValues
argument_list|(
name|placement
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|lecture
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|placement
argument_list|)
expr_stmt|;
block|}
block|}
operator|new
name|EnrollmentCheck
argument_list|(
name|getModel
argument_list|()
argument_list|)
operator|.
name|checkStudentEnrollments
argument_list|(
name|iProgress
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getModel
argument_list|()
operator|.
name|assignedVariables
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|iLoadStudentEnrlsFromSolution
condition|)
name|getModel
argument_list|()
operator|.
name|switchStudents
argument_list|()
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Done"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
name|iProgress
operator|.
name|info
argument_list|(
literal|"Model successfully loaded."
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
class|class
name|ObjectsByGivenOrderComparator
implements|implements
name|Comparator
block|{
name|Vector
name|iOrderedSet
init|=
literal|null
decl_stmt|;
specifier|public
name|ObjectsByGivenOrderComparator
parameter_list|(
name|Vector
name|orderedSetOfLectures
parameter_list|)
block|{
name|iOrderedSet
operator|=
name|orderedSetOfLectures
expr_stmt|;
block|}
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
name|int
name|idx1
init|=
name|iOrderedSet
operator|.
name|indexOf
argument_list|(
name|o1
argument_list|)
decl_stmt|;
name|int
name|idx2
init|=
name|iOrderedSet
operator|.
name|indexOf
argument_list|(
name|o2
argument_list|)
decl_stmt|;
name|int
name|cmp
init|=
name|Double
operator|.
name|compare
argument_list|(
name|idx1
argument_list|,
name|idx2
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
operator|(
operator|(
name|Comparable
operator|)
name|o1
operator|)
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
specifier|public
name|boolean
name|isRemote
parameter_list|()
block|{
return|return
name|RemoteSolverServer
operator|.
name|getServerThread
argument_list|()
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|hasRoomAvailability
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|isRemote
argument_list|()
condition|)
block|{
return|return
operator|(
name|Boolean
operator|)
name|RemoteSolverServer
operator|.
name|query
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"hasRoomAvailability"
block|}
argument_list|)
return|;
block|}
else|else
return|return
name|RoomAvailability
operator|.
name|getInstance
argument_list|()
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|sLog
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Unable to access room availability service, reason:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
specifier|public
name|void
name|roomAvailabilityActivate
parameter_list|(
name|Date
name|startTime
parameter_list|,
name|Date
name|endTime
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|isRemote
argument_list|()
condition|)
block|{
name|RemoteSolverServer
operator|.
name|query
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"activateRoomAvailability"
block|,
name|iSessionId
block|,
name|startTime
block|,
name|endTime
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RoomAvailability
operator|.
name|getInstance
argument_list|()
operator|.
name|activate
argument_list|(
operator|new
name|SessionDAO
argument_list|()
operator|.
name|get
argument_list|(
name|iSessionId
argument_list|)
argument_list|,
name|startTime
argument_list|,
name|endTime
argument_list|,
literal|"true"
operator|.
name|equals
argument_list|(
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.room.availability.solver.waitForSync"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|sLog
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Unable to access room availability service, reason:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|loadRoomAvailability
parameter_list|(
name|RoomAvailabilityInterface
name|ra
parameter_list|)
block|{
name|Date
name|startDate
init|=
literal|null
decl_stmt|,
name|endDate
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|iAllUsedDatePatterns
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatePattern
name|dp
init|=
operator|(
name|DatePattern
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|startDate
operator|==
literal|null
operator|||
name|startDate
operator|.
name|compareTo
argument_list|(
name|dp
operator|.
name|getStartDate
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
name|startDate
operator|=
name|dp
operator|.
name|getStartDate
argument_list|()
expr_stmt|;
if|if
condition|(
name|endDate
operator|==
literal|null
operator|||
name|endDate
operator|.
name|compareTo
argument_list|(
name|dp
operator|.
name|getEndDate
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
name|endDate
operator|=
name|dp
operator|.
name|getEndDate
argument_list|()
expr_stmt|;
block|}
name|Calendar
name|startDateCal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|startDateCal
operator|.
name|setTime
argument_list|(
name|startDate
argument_list|)
expr_stmt|;
name|startDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|startDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|startDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Calendar
name|endDateCal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|endDateCal
operator|.
name|setTime
argument_list|(
name|endDate
argument_list|)
expr_stmt|;
name|endDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|endDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|endDateCal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
literal|59
argument_list|)
expr_stmt|;
name|roomAvailabilityActivate
argument_list|(
name|startDateCal
operator|.
name|getTime
argument_list|()
argument_list|,
name|endDateCal
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|setPhase
argument_list|(
literal|"Loading room availability..."
argument_list|,
name|iRooms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|firstDOY
init|=
name|iSession
operator|.
name|getDayOfYear
argument_list|(
literal|1
argument_list|,
name|iSession
operator|.
name|getStartMonth
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|lastDOY
init|=
name|iSession
operator|.
name|getDayOfYear
argument_list|(
literal|0
argument_list|,
name|iSession
operator|.
name|getEndMonth
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|lastDOY
operator|-
name|firstDOY
decl_stmt|;
name|Calendar
name|c
init|=
name|Calendar
operator|.
name|getInstance
argument_list|(
name|Locale
operator|.
name|US
argument_list|)
decl_stmt|;
name|SimpleDateFormat
name|df
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"MM/dd"
argument_list|)
decl_stmt|;
name|long
name|id
init|=
literal|0
decl_stmt|;
name|int
name|sessionYear
init|=
name|iSession
operator|.
name|getYear
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|iRooms
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|RoomConstraint
name|room
init|=
operator|(
name|RoomConstraint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|iProgress
operator|.
name|incProgress
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|TimeBlock
argument_list|>
name|times
init|=
name|getRoomAvailability
argument_list|(
name|room
argument_list|,
name|startDateCal
operator|.
name|getTime
argument_list|()
argument_list|,
name|endDateCal
operator|.
name|getTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|times
operator|==
literal|null
condition|)
continue|continue;
for|for
control|(
name|TimeBlock
name|time
range|:
name|times
control|)
block|{
name|iProgress
operator|.
name|debug
argument_list|(
name|room
operator|.
name|getName
argument_list|()
operator|+
literal|" not available due to "
operator|+
name|time
argument_list|)
expr_stmt|;
name|int
name|dayCode
init|=
literal|0
decl_stmt|;
name|c
operator|.
name|setTime
argument_list|(
name|time
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|m
init|=
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
decl_stmt|;
name|int
name|d
init|=
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
operator|<
name|sessionYear
condition|)
name|m
operator|-=
literal|12
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
operator|>
name|sessionYear
condition|)
name|m
operator|+=
literal|12
expr_stmt|;
name|BitSet
name|weekCode
init|=
operator|new
name|BitSet
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|iSession
operator|.
name|getDayOfYear
argument_list|(
name|d
argument_list|,
name|m
argument_list|)
operator|-
name|firstDOY
decl_stmt|;
name|weekCode
operator|.
name|set
argument_list|(
name|offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DAY_OF_WEEK
argument_list|)
condition|)
block|{
case|case
name|Calendar
operator|.
name|MONDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_MON
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|TUESDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_TUE
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|WEDNESDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_WED
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|THURSDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_THU
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|FRIDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_FRI
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|SATURDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_SAT
index|]
expr_stmt|;
break|break;
case|case
name|Calendar
operator|.
name|SUNDAY
case|:
name|dayCode
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|Constants
operator|.
name|DAY_SUN
index|]
expr_stmt|;
break|break;
block|}
name|int
name|startSlot
init|=
operator|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|*
literal|60
operator|+
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
operator|-
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|/
name|Constants
operator|.
name|SLOT_LENGTH_MIN
decl_stmt|;
name|c
operator|.
name|setTime
argument_list|(
name|time
operator|.
name|getEndTime
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|endSlot
init|=
operator|(
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|*
literal|60
operator|+
name|c
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|)
operator|-
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|/
name|Constants
operator|.
name|SLOT_LENGTH_MIN
decl_stmt|;
name|int
name|length
init|=
name|endSlot
operator|-
name|startSlot
decl_stmt|;
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
continue|continue;
name|TimeLocation
name|timeLocation
init|=
operator|new
name|TimeLocation
argument_list|(
name|dayCode
argument_list|,
name|startSlot
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|null
argument_list|,
name|df
operator|.
name|format
argument_list|(
name|time
operator|.
name|getStartTime
argument_list|()
argument_list|)
argument_list|,
name|weekCode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Vector
name|timeLocations
init|=
operator|new
name|Vector
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|timeLocations
operator|.
name|addElement
argument_list|(
name|timeLocation
argument_list|)
expr_stmt|;
name|RoomLocation
name|roomLocation
init|=
operator|new
name|RoomLocation
argument_list|(
name|room
operator|.
name|getResourceId
argument_list|()
argument_list|,
name|room
operator|.
name|getName
argument_list|()
argument_list|,
name|room
operator|.
name|getBuildingId
argument_list|()
argument_list|,
literal|0
argument_list|,
name|room
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|room
operator|.
name|getPosX
argument_list|()
argument_list|,
name|room
operator|.
name|getPosY
argument_list|()
argument_list|,
name|room
operator|.
name|getIgnoreTooFar
argument_list|()
argument_list|,
name|room
argument_list|)
decl_stmt|;
name|Vector
name|roomLocations
init|=
operator|new
name|Vector
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|roomLocations
operator|.
name|add
argument_list|(
name|roomLocation
argument_list|)
expr_stmt|;
name|Lecture
name|lecture
init|=
operator|new
name|Lecture
argument_list|(
operator|new
name|Long
argument_list|(
operator|--
name|id
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|time
operator|.
name|getEventName
argument_list|()
argument_list|,
name|timeLocations
argument_list|,
name|roomLocations
argument_list|,
literal|1
argument_list|,
operator|new
name|Placement
argument_list|(
literal|null
argument_list|,
name|timeLocation
argument_list|,
name|roomLocations
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1.0
argument_list|)
decl_stmt|;
name|lecture
operator|.
name|setNote
argument_list|(
name|time
operator|.
name|getEventType
argument_list|()
argument_list|)
expr_stmt|;
name|Placement
name|p
init|=
operator|(
name|Placement
operator|)
name|lecture
operator|.
name|getInitialAssignment
argument_list|()
decl_stmt|;
name|lecture
operator|.
name|setBestAssignment
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lecture
operator|.
name|setCommitted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|room
operator|.
name|setNotAvailable
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|getModel
argument_list|()
operator|.
name|addVariable
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Collection
argument_list|<
name|TimeBlock
argument_list|>
name|getRoomAvailability
parameter_list|(
name|RoomConstraint
name|room
parameter_list|,
name|Date
name|startTime
parameter_list|,
name|Date
name|endTime
parameter_list|)
block|{
name|Collection
argument_list|<
name|TimeBlock
argument_list|>
name|ret
init|=
literal|null
decl_stmt|;
name|String
name|ts
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isRemote
argument_list|()
condition|)
block|{
name|ret
operator|=
operator|(
name|Collection
argument_list|<
name|TimeBlock
argument_list|>
operator|)
name|RemoteSolverServer
operator|.
name|query
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"getClassRoomAvailability"
block|,
name|room
operator|.
name|getResourceId
argument_list|()
block|,
name|startTime
block|,
name|endTime
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iRoomAvailabilityTimeStampIsSet
condition|)
name|ts
operator|=
operator|(
name|String
operator|)
name|RemoteSolverServer
operator|.
name|query
argument_list|(
operator|new
name|Object
index|[]
block|{
literal|"getRoomAvailabilityTimeStamp"
block|,
name|startTime
block|,
name|endTime
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|RoomAvailability
operator|.
name|getInstance
argument_list|()
operator|.
name|getRoomAvailability
argument_list|(
name|LocationDAO
operator|.
name|getInstance
argument_list|()
operator|.
name|get
argument_list|(
name|room
operator|.
name|getResourceId
argument_list|()
argument_list|)
argument_list|,
name|startTime
argument_list|,
name|endTime
argument_list|,
operator|new
name|String
index|[]
block|{
name|RoomAvailabilityInterface
operator|.
name|sClassType
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iRoomAvailabilityTimeStampIsSet
condition|)
name|ts
operator|=
name|RoomAvailability
operator|.
name|getInstance
argument_list|()
operator|.
name|getTimeStamp
argument_list|(
name|startTime
argument_list|,
name|endTime
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|sLog
operator|.
name|error
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|warn
argument_list|(
literal|"Unable to access room availability service, reason:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iRoomAvailabilityTimeStampIsSet
condition|)
block|{
name|iRoomAvailabilityTimeStampIsSet
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|getModel
argument_list|()
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
literal|"RoomAvailability.TimeStamp"
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|iProgress
operator|.
name|info
argument_list|(
literal|"Using room availability that was updated on "
operator|+
name|ts
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iProgress
operator|.
name|error
argument_list|(
literal|"Room availability is not available."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
block|}
end_class

end_unit

