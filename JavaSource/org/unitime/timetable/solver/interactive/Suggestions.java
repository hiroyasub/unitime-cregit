begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.2 - 3.5 (University Timetabling Application)  * Copyright (C) 2008 - 2013, UniTime LLC, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program.  If not, see<http://www.gnu.org/licenses/>.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|interactive
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Lecture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Placement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimeLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimetableModel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|assignment
operator|.
name|Assignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|solver
operator|.
name|Solver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|PreferenceLevel
import|;
end_import

begin_comment
comment|/**  * @author Tomas Muller  */
end_comment

begin_class
specifier|public
class|class
name|Suggestions
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
specifier|transient
name|Solver
name|iSolver
init|=
literal|null
decl_stmt|;
specifier|private
specifier|transient
name|Assignment
argument_list|<
name|Lecture
argument_list|,
name|Placement
argument_list|>
name|iAssignment
init|=
literal|null
decl_stmt|;
specifier|private
specifier|transient
name|TimetableModel
name|iModel
init|=
literal|null
decl_stmt|;
specifier|private
specifier|transient
name|Lecture
name|iLecture
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|iTimeOut
init|=
literal|5000
decl_stmt|;
comment|//5s
specifier|private
name|boolean
name|iSameRoom
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|iSameTime
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|iAllTheSame
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iAllowBreakHard
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|iDepth
init|=
literal|2
decl_stmt|;
specifier|private
name|TreeSet
name|iSuggestions
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
specifier|private
specifier|transient
name|Vector
name|iHints
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|iTimeoutReached
init|=
literal|false
decl_stmt|;
specifier|private
name|long
name|iNrCombinationsConsidered
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|iNrSolutions
init|=
literal|0
decl_stmt|;
specifier|private
name|Suggestion
name|iCurrentSuggestion
init|=
literal|null
decl_stmt|;
specifier|private
name|Suggestion
name|iEmptySuggestion
init|=
literal|null
decl_stmt|;
specifier|private
name|TreeSet
name|iAllAssignments
init|=
literal|null
decl_stmt|;
specifier|private
name|Vector
name|iConfTable
init|=
literal|null
decl_stmt|;
specifier|private
name|long
name|iNrTries
decl_stmt|;
specifier|private
name|Vector
name|iOriginalHints
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|iLimit
init|=
literal|100
decl_stmt|;
specifier|private
name|String
name|iFilterText
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|iTryAllAssignments
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iComputeSuggestions
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iComputeConfTable
init|=
literal|true
decl_stmt|;
specifier|private
name|int
name|iMinRoomSize
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|int
name|iMaxRoomSize
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|Suggestions
parameter_list|(
name|Solver
name|solver
parameter_list|,
name|SuggestionsModel
name|model
parameter_list|)
block|{
name|iSolver
operator|=
name|solver
expr_stmt|;
name|iModel
operator|=
operator|(
name|TimetableModel
operator|)
name|iSolver
operator|.
name|currentSolution
argument_list|()
operator|.
name|getModel
argument_list|()
expr_stmt|;
name|iAssignment
operator|=
name|iSolver
operator|.
name|currentSolution
argument_list|()
operator|.
name|getAssignment
argument_list|()
expr_stmt|;
name|iDepth
operator|=
name|model
operator|.
name|getDepth
argument_list|()
expr_stmt|;
name|iTimeOut
operator|=
name|model
operator|.
name|getTimeout
argument_list|()
expr_stmt|;
name|iAllTheSame
operator|=
name|model
operator|.
name|isAllTheSame
argument_list|()
expr_stmt|;
name|iSameTime
operator|=
operator|(
name|model
operator|.
name|getFilter
argument_list|()
operator|==
name|SuggestionsModel
operator|.
name|sFilterSameTime
operator|)
expr_stmt|;
name|iSameRoom
operator|=
operator|(
name|model
operator|.
name|getFilter
argument_list|()
operator|==
name|SuggestionsModel
operator|.
name|sFilterSameRoom
operator|)
expr_stmt|;
name|iAllowBreakHard
operator|=
name|model
operator|.
name|getAllowBreakHard
argument_list|()
expr_stmt|;
name|iHints
operator|=
operator|new
name|Vector
argument_list|(
name|model
operator|.
name|getHints
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|iOriginalHints
operator|=
name|model
operator|.
name|getHints
argument_list|()
expr_stmt|;
name|iTryAllAssignments
operator|=
name|model
operator|.
name|getDisplayPlacements
argument_list|()
expr_stmt|;
name|iComputeSuggestions
operator|=
name|model
operator|.
name|getDisplaySuggestions
argument_list|()
expr_stmt|;
name|iComputeConfTable
operator|=
name|model
operator|.
name|getDisplayConfTable
argument_list|()
expr_stmt|;
name|iLimit
operator|=
name|model
operator|.
name|getLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|iLimit
operator|<=
literal|0
condition|)
block|{
name|iComputeSuggestions
operator|=
literal|false
expr_stmt|;
name|iTryAllAssignments
operator|=
literal|false
expr_stmt|;
block|}
name|iMinRoomSize
operator|=
name|model
operator|.
name|getMinRoomSize
argument_list|()
expr_stmt|;
name|iMaxRoomSize
operator|=
name|model
operator|.
name|getMaxRoomSize
argument_list|()
expr_stmt|;
name|iFilterText
operator|=
operator|(
name|model
operator|.
name|getFilterText
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|model
operator|.
name|getFilterText
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|toUpperCase
argument_list|()
operator|)
expr_stmt|;
for|for
control|(
name|Lecture
name|lecture
range|:
name|iModel
operator|.
name|variables
argument_list|()
control|)
block|{
if|if
condition|(
name|lecture
operator|.
name|getClassId
argument_list|()
operator|.
name|equals
argument_list|(
name|model
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
block|{
name|iLecture
operator|=
name|lecture
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|Enumeration
name|e
init|=
name|model
operator|.
name|getHints
argument_list|()
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Hint
name|h
init|=
operator|(
name|Hint
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Placement
name|p
init|=
name|h
operator|.
name|getPlacement
argument_list|(
name|iModel
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
continue|continue;
comment|//if (!h.hasInfo()) h.setInfo(iSolver, p);
name|iHints
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iLecture
operator|!=
literal|null
condition|)
name|compute
argument_list|()
expr_stmt|;
block|}
specifier|public
name|boolean
name|match
parameter_list|(
name|Placement
name|p
parameter_list|)
block|{
if|if
condition|(
name|iMinRoomSize
operator|>=
literal|0
operator|&&
name|p
operator|.
name|getRoomSize
argument_list|()
operator|<
name|iMinRoomSize
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|iMaxRoomSize
operator|>=
literal|0
operator|&&
name|p
operator|.
name|getRoomSize
argument_list|()
operator|>
name|iMaxRoomSize
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|iFilterText
operator|==
literal|null
operator|||
name|iFilterText
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|true
return|;
name|StringTokenizer
name|stk
init|=
operator|new
name|StringTokenizer
argument_list|(
name|iFilterText
argument_list|)
decl_stmt|;
while|while
condition|(
name|stk
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|stk
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getName
argument_list|()
operator|.
name|toUpperCase
argument_list|()
operator|.
name|indexOf
argument_list|(
name|token
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|Vector
name|getHints
parameter_list|()
block|{
return|return
name|iOriginalHints
return|;
block|}
specifier|public
name|void
name|compute
parameter_list|()
block|{
if|if
condition|(
name|iComputeSuggestions
condition|)
name|computeSuggestions
argument_list|()
expr_stmt|;
if|if
condition|(
name|iTryAllAssignments
condition|)
name|computeTryAllAssignments
argument_list|()
expr_stmt|;
if|if
condition|(
name|iComputeConfTable
condition|)
name|computeConfTable
argument_list|()
expr_stmt|;
name|iCurrentSuggestion
operator|=
name|tryAssignment
argument_list|(
operator|(
name|Placement
operator|)
literal|null
argument_list|)
expr_stmt|;
name|Hashtable
name|initialAssignments
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Lecture
name|lec
range|:
name|iAssignment
operator|.
name|assignedVariables
argument_list|()
control|)
block|{
name|initialAssignments
operator|.
name|put
argument_list|(
name|lec
argument_list|,
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iEmptySuggestion
operator|=
operator|new
name|Suggestion
argument_list|(
name|iSolver
argument_list|,
name|initialAssignments
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
name|computeNrTries
argument_list|()
expr_stmt|;
block|}
specifier|public
name|TreeSet
name|getSuggestions
parameter_list|()
block|{
return|return
name|iSuggestions
return|;
block|}
specifier|public
name|void
name|computeSuggestions
parameter_list|()
block|{
name|iSuggestions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|iTimeoutReached
operator|=
literal|false
expr_stmt|;
name|iNrCombinationsConsidered
operator|=
literal|0
expr_stmt|;
name|iNrSolutions
operator|=
literal|0
expr_stmt|;
synchronized|synchronized
init|(
name|iSolver
operator|.
name|currentSolution
argument_list|()
init|)
block|{
name|Vector
name|unAssignedVariables
init|=
operator|new
name|Vector
argument_list|(
name|iModel
operator|.
name|nrUnassignedVariables
argument_list|(
name|iAssignment
argument_list|)
argument_list|)
decl_stmt|;
name|Hashtable
name|initialAssignments
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Lecture
name|lec
range|:
name|iAssignment
operator|.
name|assignedVariables
argument_list|()
control|)
block|{
name|initialAssignments
operator|.
name|put
argument_list|(
name|lec
argument_list|,
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Hashtable
name|conflictsToResolve
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Vector
name|resolvedLectures
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|boolean
name|canAssign
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|iHints
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|iHints
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Placement
name|plac
init|=
operator|(
name|Placement
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|plac
operator|.
name|variable
argument_list|()
decl_stmt|;
name|Set
name|conflicts
init|=
name|iModel
operator|.
name|conflictValues
argument_list|(
name|iAssignment
argument_list|,
name|plac
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|conflictPlacement
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|conflictsToResolve
operator|.
name|put
argument_list|(
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|,
name|conflictPlacement
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conflicts
operator|.
name|contains
argument_list|(
name|plac
argument_list|)
condition|)
block|{
name|resolvedLectures
operator|.
name|add
argument_list|(
name|lect
operator|.
name|getClassId
argument_list|()
argument_list|)
expr_stmt|;
name|conflictsToResolve
operator|.
name|remove
argument_list|(
name|lect
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|plac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canAssign
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|canAssign
condition|)
block|{
name|Vector
name|initialLectures
init|=
operator|new
name|Vector
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|resolvedLectures
operator|.
name|contains
argument_list|(
name|iLecture
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
name|initialLectures
operator|.
name|add
argument_list|(
name|iLecture
argument_list|)
expr_stmt|;
name|backtrack
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|initialLectures
argument_list|,
name|resolvedLectures
argument_list|,
name|conflictsToResolve
argument_list|,
name|initialAssignments
argument_list|,
name|iDepth
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Enumeration
name|e
init|=
name|unAssignedVariables
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lect
argument_list|)
operator|!=
literal|null
condition|)
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|lect
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|initialAssignments
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|plac
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|plac
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|plac
operator|.
name|equals
argument_list|(
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lect
argument_list|)
argument_list|)
condition|)
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|plac
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Suggestion
name|tryAssignment
parameter_list|(
name|Hint
name|hint
parameter_list|)
block|{
return|return
name|tryAssignment
argument_list|(
name|hint
operator|.
name|getPlacement
argument_list|(
name|iModel
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|Suggestion
name|tryAssignment
parameter_list|(
name|Placement
name|placement
parameter_list|)
block|{
name|Suggestion
name|ret
init|=
literal|null
decl_stmt|;
name|boolean
name|canAssign
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|iSolver
operator|.
name|currentSolution
argument_list|()
init|)
block|{
name|Vector
name|unAssignedVariables
init|=
operator|new
name|Vector
argument_list|(
name|iModel
operator|.
name|nrUnassignedVariables
argument_list|(
name|iAssignment
argument_list|)
argument_list|)
decl_stmt|;
name|Hashtable
name|initialAssignments
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Lecture
name|lec
range|:
name|iAssignment
operator|.
name|assignedVariables
argument_list|()
control|)
block|{
name|initialAssignments
operator|.
name|put
argument_list|(
name|lec
argument_list|,
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lec
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Hashtable
name|conflictsToResolve
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|Vector
name|resolvedLectures
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
if|if
condition|(
name|iHints
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|iHints
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Placement
name|plac
init|=
operator|(
name|Placement
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|plac
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
name|placement
operator|!=
literal|null
operator|&&
name|placement
operator|.
name|variable
argument_list|()
operator|.
name|equals
argument_list|(
name|lect
argument_list|)
condition|)
continue|continue;
name|Set
name|conflicts
init|=
name|iModel
operator|.
name|conflictValues
argument_list|(
name|iAssignment
argument_list|,
name|plac
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|conflictPlacement
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|conflictsToResolve
operator|.
name|put
argument_list|(
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|,
name|conflictPlacement
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conflicts
operator|.
name|contains
argument_list|(
name|plac
argument_list|)
condition|)
block|{
name|resolvedLectures
operator|.
name|add
argument_list|(
name|lect
operator|.
name|getClassId
argument_list|()
argument_list|)
expr_stmt|;
name|conflictsToResolve
operator|.
name|remove
argument_list|(
name|lect
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|plac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canAssign
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|placement
operator|!=
literal|null
condition|)
block|{
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|placement
operator|.
name|variable
argument_list|()
decl_stmt|;
name|Set
name|conflicts
init|=
name|iModel
operator|.
name|conflictValues
argument_list|(
name|iAssignment
argument_list|,
name|placement
argument_list|)
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|conflictPlacement
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|conflictsToResolve
operator|.
name|put
argument_list|(
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|,
name|conflictPlacement
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|conflictPlacement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conflicts
operator|.
name|contains
argument_list|(
name|placement
argument_list|)
condition|)
block|{
name|resolvedLectures
operator|.
name|add
argument_list|(
name|lect
operator|.
name|getClassId
argument_list|()
argument_list|)
expr_stmt|;
name|conflictsToResolve
operator|.
name|remove
argument_list|(
name|lect
argument_list|)
expr_stmt|;
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|placement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|canAssign
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|ret
operator|=
operator|new
name|Suggestion
argument_list|(
name|iSolver
argument_list|,
name|initialAssignments
argument_list|,
name|resolvedLectures
argument_list|,
name|conflictsToResolve
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ret
operator|.
name|setCanAssign
argument_list|(
name|canAssign
argument_list|)
expr_stmt|;
if|if
condition|(
name|placement
operator|!=
literal|null
condition|)
name|ret
operator|.
name|setHint
argument_list|(
operator|new
name|Hint
argument_list|(
name|iSolver
argument_list|,
name|placement
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iHints
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Enumeration
name|e
init|=
name|iHints
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Placement
name|plac
init|=
operator|(
name|Placement
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|plac
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lect
argument_list|)
operator|!=
literal|null
condition|)
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|lect
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Enumeration
name|e
init|=
name|unAssignedVariables
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lect
argument_list|)
operator|!=
literal|null
condition|)
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|lect
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|placement
operator|!=
literal|null
condition|)
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|placement
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|initialAssignments
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|plac
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|plac
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|plac
operator|.
name|equals
argument_list|(
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lect
argument_list|)
argument_list|)
condition|)
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|plac
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|Suggestion
name|currentSuggestion
parameter_list|()
block|{
return|return
name|iCurrentSuggestion
return|;
block|}
specifier|public
name|Suggestion
name|emptySuggestion
parameter_list|()
block|{
return|return
name|iEmptySuggestion
return|;
block|}
specifier|private
name|TreeSet
argument_list|<
name|PlacementValue
argument_list|>
name|values
parameter_list|(
name|Lecture
name|lecture
parameter_list|)
block|{
name|TreeSet
argument_list|<
name|PlacementValue
argument_list|>
name|vals
init|=
operator|new
name|TreeSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|equals
argument_list|(
name|iLecture
argument_list|)
condition|)
block|{
for|for
control|(
name|Placement
name|p
range|:
operator|(
name|lecture
operator|.
name|allowBreakHard
argument_list|()
operator|||
operator|!
name|iAllowBreakHard
condition|?
name|lecture
operator|.
name|values
argument_list|(
name|iAssignment
argument_list|)
else|:
name|lecture
operator|.
name|computeValues
argument_list|(
name|iAssignment
argument_list|,
literal|true
argument_list|)
operator|)
control|)
block|{
if|if
condition|(
name|match
argument_list|(
name|p
argument_list|)
condition|)
name|vals
operator|.
name|add
argument_list|(
operator|new
name|PlacementValue
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lecture
operator|.
name|allowBreakHard
argument_list|()
operator|||
operator|!
name|iAllowBreakHard
condition|)
block|{
for|for
control|(
name|Placement
name|x
range|:
name|lecture
operator|.
name|values
argument_list|(
name|iAssignment
argument_list|)
control|)
block|{
name|vals
operator|.
name|add
argument_list|(
operator|new
name|PlacementValue
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|Placement
name|x
range|:
name|lecture
operator|.
name|computeValues
argument_list|(
name|iAssignment
argument_list|,
literal|true
argument_list|)
control|)
block|{
name|vals
operator|.
name|add
argument_list|(
operator|new
name|PlacementValue
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|vals
return|;
block|}
specifier|public
name|boolean
name|containsCommited
parameter_list|(
name|TimetableModel
name|model
parameter_list|,
name|Collection
name|values
parameter_list|)
block|{
if|if
condition|(
name|model
operator|.
name|hasConstantVariables
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|values
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|placement
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|placement
operator|.
name|variable
argument_list|()
decl_stmt|;
if|if
condition|(
name|lecture
operator|.
name|isCommitted
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|backtrack
parameter_list|(
name|long
name|startTime
parameter_list|,
name|Vector
name|initialLectures
parameter_list|,
name|Vector
name|resolvedLectures
parameter_list|,
name|Hashtable
name|conflictsToResolve
parameter_list|,
name|Hashtable
name|initialAssignments
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|iNrCombinationsConsidered
operator|++
expr_stmt|;
name|int
name|nrUnassigned
init|=
name|conflictsToResolve
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|initialLectures
operator|==
literal|null
operator|||
name|initialLectures
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|nrUnassigned
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|iSuggestions
operator|.
name|size
argument_list|()
operator|==
name|iLimit
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Suggestion
operator|)
name|iSuggestions
operator|.
name|last
argument_list|()
operator|)
operator|.
name|isBetter
argument_list|(
name|iSolver
argument_list|)
condition|)
return|return;
block|}
name|iSuggestions
operator|.
name|add
argument_list|(
operator|new
name|Suggestion
argument_list|(
name|iSolver
argument_list|,
name|initialAssignments
argument_list|,
name|resolvedLectures
argument_list|,
name|conflictsToResolve
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iNrSolutions
operator|++
expr_stmt|;
if|if
condition|(
name|iSuggestions
operator|.
name|size
argument_list|()
operator|>
name|iLimit
condition|)
name|iSuggestions
operator|.
name|remove
argument_list|(
name|iSuggestions
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|iTimeOut
operator|>
literal|0
operator|&&
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|>
name|iTimeOut
condition|)
block|{
name|iTimeoutReached
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iSuggestions
operator|.
name|size
argument_list|()
operator|==
name|iLimit
operator|&&
operator|(
operator|(
name|Suggestion
operator|)
name|iSuggestions
operator|.
name|last
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
operator|<
name|getBound
argument_list|(
name|conflictsToResolve
argument_list|)
condition|)
block|{
return|return;
comment|//BOUND
block|}
for|for
control|(
name|Enumeration
name|e1
init|=
operator|(
name|initialLectures
operator|!=
literal|null
operator|&&
operator|!
name|initialLectures
operator|.
name|isEmpty
argument_list|()
condition|?
name|initialLectures
operator|.
name|elements
argument_list|()
else|:
name|conflictsToResolve
operator|.
name|keys
argument_list|()
operator|)
init|;
name|e1
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lecture
init|=
operator|(
name|Lecture
operator|)
name|e1
operator|.
name|nextElement
argument_list|()
decl_stmt|;
if|if
condition|(
name|iTimeoutReached
condition|)
break|break;
if|if
condition|(
name|resolvedLectures
operator|.
name|contains
argument_list|(
name|lecture
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
continue|continue;
name|resolvedLectures
operator|.
name|add
argument_list|(
name|lecture
operator|.
name|getClassId
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|e2
init|=
name|values
argument_list|(
name|lecture
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|e2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|PlacementValue
name|placementValue
init|=
operator|(
name|PlacementValue
operator|)
name|e2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|iTimeoutReached
condition|)
break|break;
name|Placement
name|placement
init|=
name|placementValue
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
name|Placement
name|current
init|=
name|iAssignment
operator|.
name|getValue
argument_list|(
name|lecture
argument_list|)
decl_stmt|;
if|if
condition|(
name|placement
operator|.
name|equals
argument_list|(
name|current
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|iAllowBreakHard
operator|&&
name|placement
operator|.
name|isHard
argument_list|(
name|iAssignment
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iSameTime
operator|&&
name|current
operator|!=
literal|null
operator|&&
operator|!
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Placement
operator|)
name|current
operator|)
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iSameRoom
operator|&&
name|current
operator|!=
literal|null
operator|&&
operator|!
name|placement
operator|.
name|sameRooms
argument_list|(
operator|(
name|Placement
operator|)
name|current
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iAllTheSame
operator|&&
name|iSameTime
operator|&&
name|current
operator|==
literal|null
condition|)
block|{
name|Placement
name|ini
init|=
operator|(
name|Placement
operator|)
name|initialAssignments
operator|.
name|get
argument_list|(
name|lecture
argument_list|)
decl_stmt|;
if|if
condition|(
name|ini
operator|!=
literal|null
operator|&&
operator|!
name|placement
operator|.
name|sameTime
argument_list|(
name|ini
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|iAllTheSame
operator|&&
name|iSameRoom
operator|&&
name|current
operator|==
literal|null
condition|)
block|{
name|Placement
name|ini
init|=
operator|(
name|Placement
operator|)
name|initialAssignments
operator|.
name|get
argument_list|(
name|lecture
argument_list|)
decl_stmt|;
if|if
condition|(
name|ini
operator|!=
literal|null
operator|&&
operator|!
name|placement
operator|.
name|sameRooms
argument_list|(
name|ini
argument_list|)
condition|)
continue|continue;
block|}
name|Set
name|conflicts
init|=
name|iModel
operator|.
name|conflictValues
argument_list|(
name|iAssignment
argument_list|,
name|placement
argument_list|)
decl_stmt|;
if|if
condition|(
name|conflicts
operator|!=
literal|null
operator|&&
operator|(
name|nrUnassigned
operator|+
name|conflicts
operator|.
name|size
argument_list|()
operator|>
name|depth
operator|)
condition|)
continue|continue;
if|if
condition|(
name|containsCommited
argument_list|(
name|iModel
argument_list|,
name|conflicts
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|conflicts
operator|.
name|contains
argument_list|(
name|placement
argument_list|)
condition|)
continue|continue;
name|boolean
name|containException
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|conflicts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
operator|!
name|containException
operator|&&
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|c
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|resolvedLectures
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|Lecture
operator|)
name|c
operator|.
name|variable
argument_list|()
operator|)
operator|.
name|getClassId
argument_list|()
argument_list|)
condition|)
name|containException
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|containException
condition|)
continue|continue;
if|if
condition|(
name|conflicts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
operator|!
name|containException
operator|&&
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|c
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|c
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|placement
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
operator|!
name|containException
operator|&&
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|c
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|conflictsToResolve
operator|.
name|put
argument_list|(
name|c
operator|.
name|variable
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|Placement
name|resolvedConf
init|=
operator|(
name|Placement
operator|)
name|conflictsToResolve
operator|.
name|remove
argument_list|(
name|lecture
argument_list|)
decl_stmt|;
name|backtrack
argument_list|(
name|startTime
argument_list|,
literal|null
argument_list|,
name|resolvedLectures
argument_list|,
name|conflictsToResolve
argument_list|,
name|initialAssignments
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|null
condition|)
name|iAssignment
operator|.
name|unassign
argument_list|(
literal|0
argument_list|,
name|lecture
argument_list|)
expr_stmt|;
else|else
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|conflicts
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Placement
name|p
init|=
operator|(
name|Placement
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|iAssignment
operator|.
name|assign
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|conflictsToResolve
operator|.
name|remove
argument_list|(
name|p
operator|.
name|variable
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resolvedConf
operator|!=
literal|null
condition|)
name|conflictsToResolve
operator|.
name|put
argument_list|(
name|lecture
argument_list|,
name|resolvedConf
argument_list|)
expr_stmt|;
block|}
name|resolvedLectures
operator|.
name|remove
argument_list|(
name|lecture
operator|.
name|getClassId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|getTimeoutReached
parameter_list|()
block|{
return|return
name|iTimeoutReached
return|;
block|}
specifier|public
name|long
name|getNrCombinationsConsidered
parameter_list|()
block|{
return|return
name|iNrCombinationsConsidered
return|;
block|}
specifier|public
name|long
name|getNrSolutions
parameter_list|()
block|{
return|return
name|iNrSolutions
return|;
block|}
specifier|public
name|void
name|computeConfTable
parameter_list|()
block|{
name|iConfTable
operator|=
operator|new
name|Vector
argument_list|()
expr_stmt|;
for|for
control|(
name|TimeLocation
name|t
range|:
name|iLecture
operator|.
name|timeLocations
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|iAllowBreakHard
operator|&&
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|PreferenceLevel
operator|.
name|int2prolog
argument_list|(
name|t
operator|.
name|getPreference
argument_list|()
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|t
operator|.
name|getPreference
argument_list|()
operator|>
literal|500
condition|)
continue|continue;
name|iConfTable
operator|.
name|add
argument_list|(
operator|new
name|Suggestion
argument_list|(
name|iSolver
argument_list|,
name|iLecture
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|computeTryAllAssignments
parameter_list|()
block|{
name|iAllAssignments
operator|=
operator|new
name|TreeSet
argument_list|()
expr_stmt|;
name|Placement
name|current
init|=
name|iAssignment
operator|.
name|getValue
argument_list|(
name|iLecture
argument_list|)
decl_stmt|;
for|for
control|(
name|Placement
name|p
range|:
name|iLecture
operator|.
name|values
argument_list|(
name|iAssignment
argument_list|)
control|)
block|{
if|if
condition|(
name|p
operator|.
name|equals
argument_list|(
name|current
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p
operator|.
name|isHard
argument_list|(
name|iAssignment
argument_list|)
operator|&&
operator|!
name|iAllowBreakHard
condition|)
continue|continue;
if|if
condition|(
operator|!
name|match
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iSameTime
operator|&&
name|current
operator|!=
literal|null
operator|&&
operator|!
name|p
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|Placement
operator|)
name|current
operator|)
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iSameRoom
operator|&&
name|current
operator|!=
literal|null
operator|&&
operator|!
name|p
operator|.
name|sameRooms
argument_list|(
operator|(
name|Placement
operator|)
name|current
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|iAllAssignments
operator|.
name|size
argument_list|()
operator|==
name|iLimit
operator|&&
operator|(
operator|(
name|Suggestion
operator|)
name|iAllAssignments
operator|.
name|last
argument_list|()
operator|)
operator|.
name|isBetter
argument_list|(
name|iSolver
argument_list|)
condition|)
continue|continue;
name|Suggestion
name|s
init|=
name|tryAssignment
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|iAllAssignments
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|iAllAssignments
operator|.
name|size
argument_list|()
operator|>
name|iLimit
condition|)
name|iAllAssignments
operator|.
name|remove
argument_list|(
name|iAllAssignments
operator|.
name|last
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|TreeSet
name|tryAllAssignments
parameter_list|()
block|{
return|return
name|iAllAssignments
return|;
block|}
specifier|public
name|long
name|getNrTries
parameter_list|()
block|{
return|return
name|iNrTries
return|;
block|}
specifier|public
name|Vector
name|getConfTable
parameter_list|()
block|{
return|return
name|iConfTable
return|;
block|}
specifier|public
name|void
name|computeNrTries
parameter_list|()
block|{
name|Placement
name|placement
init|=
name|iAssignment
operator|.
name|getValue
argument_list|(
name|iLecture
argument_list|)
decl_stmt|;
if|if
condition|(
name|iSameTime
operator|&&
name|placement
operator|!=
literal|null
condition|)
name|iNrTries
operator|=
name|iLecture
operator|.
name|nrValues
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|-
literal|1
expr_stmt|;
if|else if
condition|(
name|iSameRoom
operator|&&
name|placement
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|placement
operator|.
name|isMultiRoom
argument_list|()
condition|)
block|{
name|iNrTries
operator|=
name|iLecture
operator|.
name|nrValues
argument_list|(
name|placement
operator|.
name|getRoomLocations
argument_list|()
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|iNrTries
operator|=
name|iLecture
operator|.
name|nrValues
argument_list|(
name|placement
operator|.
name|getRoomLocation
argument_list|()
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|iNrTries
operator|=
name|iLecture
operator|.
name|nrValues
argument_list|()
operator|-
operator|(
name|placement
operator|==
literal|null
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Suggestions{\n"
operator|+
literal|"  suggestions = "
operator|+
name|getSuggestions
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  timeoutReached = "
operator|+
name|getTimeoutReached
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  nrCombinationsConsidered = "
operator|+
name|getNrCombinationsConsidered
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  nrSolutions = "
operator|+
name|getNrSolutions
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  currentSuggestion = "
operator|+
name|currentSuggestion
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  tryAssignments = "
operator|+
name|tryAllAssignments
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  nrTries = "
operator|+
name|getNrTries
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  emptySuggestion = "
operator|+
name|emptySuggestion
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  hints = "
operator|+
name|getHints
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"  confTable = "
operator|+
name|getConfTable
argument_list|()
operator|+
literal|"\n"
operator|+
literal|"}"
return|;
block|}
specifier|public
name|double
name|getBound
parameter_list|(
name|Hashtable
name|conflictsToResolve
parameter_list|)
block|{
name|double
name|value
init|=
name|iSolver
operator|.
name|currentSolution
argument_list|()
operator|.
name|getModel
argument_list|()
operator|.
name|getTotalValue
argument_list|(
name|iAssignment
argument_list|)
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|conflictsToResolve
operator|.
name|keys
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Lecture
name|lect
init|=
operator|(
name|Lecture
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|PlacementValue
name|val
init|=
name|values
argument_list|(
name|lect
argument_list|)
operator|.
name|first
argument_list|()
decl_stmt|;
name|value
operator|+=
name|val
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
specifier|public
class|class
name|PlacementValue
implements|implements
name|Comparable
argument_list|<
name|PlacementValue
argument_list|>
block|{
specifier|private
name|Placement
name|iPlacement
decl_stmt|;
specifier|private
name|double
name|iValue
decl_stmt|;
specifier|public
name|PlacementValue
parameter_list|(
name|Placement
name|placement
parameter_list|)
block|{
name|iPlacement
operator|=
name|placement
expr_stmt|;
name|iValue
operator|=
name|placement
operator|.
name|toDouble
argument_list|(
name|iAssignment
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Placement
name|getPlacement
parameter_list|()
block|{
return|return
name|iPlacement
return|;
block|}
specifier|public
name|double
name|getValue
parameter_list|()
block|{
return|return
name|iValue
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|PlacementValue
name|p
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Double
operator|.
name|compare
argument_list|(
name|getValue
argument_list|()
argument_list|,
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|Double
operator|.
name|compare
argument_list|(
name|getPlacement
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|p
operator|.
name|getPlacement
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

