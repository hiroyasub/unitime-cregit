begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.3 (University Timetabling Application)  * Copyright (C) 2011, UniTime LLC, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program.  If not, see<http://www.gnu.org/licenses/>.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|onlinesectioning
operator|.
name|solver
operator|.
name|multicriteria
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|onlinesectioning
operator|.
name|solver
operator|.
name|OnlineSectioningSelection
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|model
operator|.
name|GlobalConstraint
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|DataProperties
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|JProf
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|StudentSectioningModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|constraint
operator|.
name|LinkedSections
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|heuristics
operator|.
name|selection
operator|.
name|BranchBoundSelection
operator|.
name|BranchBoundNeighbour
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Config
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|CourseRequest
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Enrollment
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|FreeTimeRequest
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Request
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Section
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Student
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Subpart
import|;
end_import

begin_class
specifier|public
class|class
name|MultiCriteriaBranchAndBoundSelection
implements|implements
name|OnlineSectioningSelection
block|{
specifier|protected
name|int
name|iTimeout
init|=
literal|1000
decl_stmt|;
specifier|protected
name|StudentSectioningModel
name|iModel
init|=
literal|null
decl_stmt|;
specifier|protected
name|SelectionCriterion
name|iComparator
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|iPriorityWeighting
init|=
literal|true
decl_stmt|;
comment|/** Student */
specifier|protected
name|Student
name|iStudent
decl_stmt|;
comment|/** Start time */
specifier|protected
name|long
name|iT0
decl_stmt|;
comment|/** End time */
specifier|protected
name|long
name|iT1
decl_stmt|;
comment|/** Was timeout reached */
specifier|protected
name|boolean
name|iTimeoutReached
decl_stmt|;
comment|/** Current assignment */
specifier|protected
name|Enrollment
index|[]
name|iAssignment
decl_stmt|;
comment|/** Best assignment */
specifier|protected
name|Enrollment
index|[]
name|iBestAssignment
decl_stmt|;
comment|/** Value cache */
specifier|protected
name|HashMap
argument_list|<
name|CourseRequest
argument_list|,
name|List
argument_list|<
name|Enrollment
argument_list|>
argument_list|>
name|iValues
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|FreeTimeRequest
argument_list|>
name|iRequiredFreeTimes
decl_stmt|;
specifier|private
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Set
argument_list|<
name|Section
argument_list|>
argument_list|>
name|iPreferredSections
decl_stmt|;
specifier|private
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Config
argument_list|>
name|iRequiredConfig
init|=
operator|new
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Config
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Hashtable
argument_list|<
name|Subpart
argument_list|,
name|Section
argument_list|>
argument_list|>
name|iRequiredSection
init|=
operator|new
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Hashtable
argument_list|<
name|Subpart
argument_list|,
name|Section
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|MultiCriteriaBranchAndBoundSelection
parameter_list|(
name|DataProperties
name|config
parameter_list|)
block|{
name|iTimeout
operator|=
name|config
operator|.
name|getPropertyInt
argument_list|(
literal|"Neighbour.BranchAndBoundTimeout"
argument_list|,
name|iTimeout
argument_list|)
expr_stmt|;
name|iPriorityWeighting
operator|=
name|config
operator|.
name|getPropertyBoolean
argument_list|(
literal|"StudentWeights.PriorityWeighting"
argument_list|,
name|iPriorityWeighting
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setModel
parameter_list|(
name|StudentSectioningModel
name|model
parameter_list|)
block|{
name|iModel
operator|=
name|model
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setPreferredSections
parameter_list|(
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Set
argument_list|<
name|Section
argument_list|>
argument_list|>
name|preferredSections
parameter_list|)
block|{
name|iPreferredSections
operator|=
name|preferredSections
expr_stmt|;
block|}
specifier|public
name|void
name|setTimeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|iTimeout
operator|=
name|timeout
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRequiredSections
parameter_list|(
name|Hashtable
argument_list|<
name|CourseRequest
argument_list|,
name|Set
argument_list|<
name|Section
argument_list|>
argument_list|>
name|requiredSections
parameter_list|)
block|{
if|if
condition|(
name|requiredSections
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|CourseRequest
argument_list|,
name|Set
argument_list|<
name|Section
argument_list|>
argument_list|>
name|entry
range|:
name|requiredSections
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Hashtable
argument_list|<
name|Subpart
argument_list|,
name|Section
argument_list|>
name|subSection
init|=
operator|new
name|Hashtable
argument_list|<
name|Subpart
argument_list|,
name|Section
argument_list|>
argument_list|()
decl_stmt|;
name|iRequiredSection
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|subSection
argument_list|)
expr_stmt|;
for|for
control|(
name|Section
name|section
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
if|if
condition|(
name|subSection
operator|.
name|isEmpty
argument_list|()
condition|)
name|iRequiredConfig
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|section
operator|.
name|getSubpart
argument_list|()
operator|.
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
name|subSection
operator|.
name|put
argument_list|(
name|section
operator|.
name|getSubpart
argument_list|()
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|setRequiredFreeTimes
parameter_list|(
name|Set
argument_list|<
name|FreeTimeRequest
argument_list|>
name|requiredFreeTimes
parameter_list|)
block|{
name|iRequiredFreeTimes
operator|=
name|requiredFreeTimes
expr_stmt|;
block|}
specifier|public
name|BranchBoundNeighbour
name|select
parameter_list|(
name|Student
name|student
parameter_list|,
name|SelectionCriterion
name|comparator
parameter_list|)
block|{
name|iStudent
operator|=
name|student
expr_stmt|;
name|iComparator
operator|=
name|comparator
expr_stmt|;
return|return
name|select
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|BranchBoundNeighbour
name|select
parameter_list|(
name|Student
name|student
parameter_list|)
block|{
name|SelectionCriterion
name|comparator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|iPriorityWeighting
condition|)
name|comparator
operator|=
operator|new
name|OnlineSectioningCriterion
argument_list|(
name|student
argument_list|,
name|iModel
argument_list|,
name|iPreferredSections
argument_list|)
expr_stmt|;
else|else
name|comparator
operator|=
operator|new
name|EqualWeightCriterion
argument_list|(
name|student
argument_list|,
name|iModel
argument_list|,
name|iPreferredSections
argument_list|)
expr_stmt|;
return|return
name|select
argument_list|(
name|student
argument_list|,
name|comparator
argument_list|)
return|;
block|}
comment|/**      * Execute branch& bound, return the best found schedule for the      * selected student.      */
specifier|public
name|BranchBoundNeighbour
name|select
parameter_list|()
block|{
name|iT0
operator|=
name|JProf
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|iTimeoutReached
operator|=
literal|false
expr_stmt|;
name|iAssignment
operator|=
operator|new
name|Enrollment
index|[
name|iStudent
operator|.
name|getRequests
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|iBestAssignment
operator|=
literal|null
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Request
name|r
range|:
name|iStudent
operator|.
name|getRequests
argument_list|()
control|)
name|iAssignment
index|[
name|i
operator|++
index|]
operator|=
name|r
operator|.
name|getAssignment
argument_list|()
expr_stmt|;
name|saveBest
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iAssignment
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iAssignment
index|[
name|j
index|]
operator|=
literal|null
expr_stmt|;
name|iValues
operator|=
operator|new
name|HashMap
argument_list|<
name|CourseRequest
argument_list|,
name|List
argument_list|<
name|Enrollment
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|backTrack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|iT1
operator|=
name|JProf
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
if|if
condition|(
name|iBestAssignment
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
operator|new
name|BranchBoundNeighbour
argument_list|(
name|iStudent
argument_list|,
name|iComparator
operator|.
name|getTotalWeight
argument_list|(
name|iBestAssignment
argument_list|)
argument_list|,
name|iBestAssignment
argument_list|)
return|;
block|}
comment|/** Was timeout reached */
specifier|public
name|boolean
name|isTimeoutReached
parameter_list|()
block|{
return|return
name|iTimeoutReached
return|;
block|}
comment|/** Time (in milliseconds) the branch& bound did run */
specifier|public
name|long
name|getTime
parameter_list|()
block|{
return|return
name|iT1
operator|-
name|iT0
return|;
block|}
comment|/** Save the current schedule as the best */
specifier|public
name|void
name|saveBest
parameter_list|()
block|{
if|if
condition|(
name|iBestAssignment
operator|==
literal|null
condition|)
name|iBestAssignment
operator|=
operator|new
name|Enrollment
index|[
name|iAssignment
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iAssignment
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|iBestAssignment
index|[
name|i
index|]
operator|=
name|iAssignment
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/** True if the enrollment is conflicting */
specifier|public
name|boolean
name|inConflict
parameter_list|(
specifier|final
name|int
name|idx
parameter_list|,
specifier|final
name|Enrollment
name|enrollment
parameter_list|)
block|{
for|for
control|(
name|GlobalConstraint
argument_list|<
name|Request
argument_list|,
name|Enrollment
argument_list|>
name|constraint
range|:
name|enrollment
operator|.
name|variable
argument_list|()
operator|.
name|getModel
argument_list|()
operator|.
name|globalConstraints
argument_list|()
control|)
if|if
condition|(
name|constraint
operator|.
name|inConflict
argument_list|(
name|enrollment
argument_list|)
condition|)
return|return
literal|true
return|;
for|for
control|(
name|LinkedSections
name|linkedSections
range|:
name|iStudent
operator|.
name|getLinkedSections
argument_list|()
control|)
block|{
if|if
condition|(
name|linkedSections
operator|.
name|inConflict
argument_list|(
name|enrollment
argument_list|,
operator|new
name|LinkedSections
operator|.
name|Assignment
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Enrollment
name|getEnrollment
parameter_list|(
name|Request
name|request
parameter_list|,
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
name|index
operator|==
name|idx
condition|?
name|enrollment
else|:
name|iAssignment
index|[
name|index
index|]
operator|)
return|;
block|}
block|}
block_content|)
block|!= null
block_content|)
block|return true
function|;
block|}
end_class

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iAssignment
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iAssignment
index|[
name|i
index|]
operator|!=
literal|null
operator|&&
name|i
operator|!=
name|idx
operator|&&
name|iAssignment
index|[
name|i
index|]
operator|.
name|isOverlapping
argument_list|(
name|enrollment
argument_list|)
condition|)
return|return
literal|true
return|;
end_for

begin_return
return|return
operator|!
name|isAllowed
argument_list|(
name|idx
argument_list|,
name|enrollment
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/** True if the given request can be assigned */
end_comment

begin_function
unit|public
name|boolean
name|canAssign
parameter_list|(
name|Request
name|request
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|request
operator|.
name|isAlternative
argument_list|()
operator|||
name|iAssignment
index|[
name|idx
index|]
operator|!=
literal|null
condition|)
return|return
literal|true
return|;
name|int
name|alt
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|Request
argument_list|>
name|e
init|=
name|iStudent
operator|.
name|getRequests
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|e
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Request
name|r
init|=
name|e
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|equals
argument_list|(
name|request
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|r
operator|.
name|isAlternative
argument_list|()
condition|)
block|{
if|if
condition|(
name|iAssignment
index|[
name|i
index|]
operator|!=
literal|null
operator|||
operator|(
name|r
operator|instanceof
name|CourseRequest
operator|&&
operator|(
operator|(
name|CourseRequest
operator|)
name|r
operator|)
operator|.
name|isWaitlist
argument_list|()
operator|)
condition|)
name|alt
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|instanceof
name|CourseRequest
operator|&&
operator|!
operator|(
operator|(
name|CourseRequest
operator|)
name|r
operator|)
operator|.
name|isWaitlist
argument_list|()
operator|&&
name|iAssignment
index|[
name|i
index|]
operator|==
literal|null
condition|)
name|alt
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|alt
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|public
name|boolean
name|isAllowed
parameter_list|(
name|int
name|idx
parameter_list|,
name|Enrollment
name|enrollment
parameter_list|)
block|{
if|if
condition|(
name|enrollment
operator|.
name|isCourseRequest
argument_list|()
condition|)
block|{
name|CourseRequest
name|request
init|=
operator|(
name|CourseRequest
operator|)
name|enrollment
operator|.
name|getRequest
argument_list|()
decl_stmt|;
name|Config
name|reqConfig
init|=
name|iRequiredConfig
operator|.
name|get
argument_list|(
name|request
argument_list|)
decl_stmt|;
if|if
condition|(
name|reqConfig
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|reqConfig
operator|.
name|equals
argument_list|(
name|enrollment
operator|.
name|getConfig
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
name|Hashtable
argument_list|<
name|Subpart
argument_list|,
name|Section
argument_list|>
name|reqSections
init|=
name|iRequiredSection
operator|.
name|get
argument_list|(
name|request
argument_list|)
decl_stmt|;
for|for
control|(
name|Section
name|section
range|:
name|enrollment
operator|.
name|getSections
argument_list|()
control|)
block|{
name|Section
name|reqSection
init|=
name|reqSections
operator|.
name|get
argument_list|(
name|section
operator|.
name|getSubpart
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reqSection
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
operator|!
name|section
operator|.
name|equals
argument_list|(
name|reqSection
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
if|else if
condition|(
name|iRequiredFreeTimes
operator|.
name|contains
argument_list|(
name|enrollment
operator|.
name|getRequest
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|enrollment
operator|.
name|getAssignments
argument_list|()
operator|==
literal|null
operator|||
name|enrollment
operator|.
name|getAssignments
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/** Returns true if the given request can be left unassigned */
end_comment

begin_function
specifier|protected
name|boolean
name|canLeaveUnassigned
parameter_list|(
name|Request
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|instanceof
name|CourseRequest
condition|)
block|{
if|if
condition|(
name|iRequiredConfig
operator|.
name|get
argument_list|(
name|request
argument_list|)
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
block|}
if|else if
condition|(
name|iRequiredFreeTimes
operator|.
name|contains
argument_list|(
name|request
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function

begin_comment
comment|/** Returns list of available enrollments for a course request */
end_comment

begin_function
specifier|protected
name|List
argument_list|<
name|Enrollment
argument_list|>
name|values
parameter_list|(
specifier|final
name|CourseRequest
name|request
parameter_list|)
block|{
name|List
argument_list|<
name|Enrollment
argument_list|>
name|values
init|=
name|request
operator|.
name|getAvaiableEnrollments
argument_list|()
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|values
argument_list|,
name|iComparator
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_comment
comment|/** branch& bound search */
end_comment

begin_function
specifier|public
name|void
name|backTrack
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|iTimeout
operator|>
literal|0
operator|&&
operator|(
name|JProf
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|iT0
operator|)
operator|>
name|iTimeout
condition|)
block|{
name|iTimeoutReached
operator|=
literal|true
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|idx
operator|==
name|iAssignment
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|iBestAssignment
operator|==
literal|null
operator|||
name|iComparator
operator|.
name|compare
argument_list|(
name|iAssignment
argument_list|,
name|iBestAssignment
argument_list|)
operator|<
literal|0
condition|)
name|saveBest
argument_list|()
expr_stmt|;
return|return;
block|}
if|else if
condition|(
name|iBestAssignment
operator|!=
literal|null
operator|&&
operator|!
name|iComparator
operator|.
name|canImprove
argument_list|(
name|idx
argument_list|,
name|iAssignment
argument_list|,
name|iBestAssignment
argument_list|)
condition|)
block|{
return|return;
block|}
name|Request
name|request
init|=
name|iStudent
operator|.
name|getRequests
argument_list|()
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|canAssign
argument_list|(
name|request
argument_list|,
name|idx
argument_list|)
condition|)
block|{
name|backTrack
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|List
argument_list|<
name|Enrollment
argument_list|>
name|values
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|request
operator|instanceof
name|CourseRequest
condition|)
block|{
name|CourseRequest
name|courseRequest
init|=
operator|(
name|CourseRequest
operator|)
name|request
decl_stmt|;
if|if
condition|(
operator|!
name|courseRequest
operator|.
name|getSelectedChoices
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|values
operator|=
name|courseRequest
operator|.
name|getSelectedEnrollments
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
literal|null
operator|&&
operator|!
name|values
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|boolean
name|hasNoConflictValue
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Enrollment
name|enrollment
range|:
name|values
control|)
block|{
if|if
condition|(
name|inConflict
argument_list|(
name|idx
argument_list|,
name|enrollment
argument_list|)
condition|)
continue|continue;
name|hasNoConflictValue
operator|=
literal|true
expr_stmt|;
name|iAssignment
index|[
name|idx
index|]
operator|=
name|enrollment
expr_stmt|;
name|backTrack
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|iAssignment
index|[
name|idx
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|hasNoConflictValue
condition|)
return|return;
block|}
block|}
name|values
operator|=
name|iValues
operator|.
name|get
argument_list|(
name|courseRequest
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|==
literal|null
condition|)
block|{
name|values
operator|=
name|values
argument_list|(
name|courseRequest
argument_list|)
expr_stmt|;
name|iValues
operator|.
name|put
argument_list|(
name|courseRequest
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|values
operator|=
name|request
operator|.
name|computeEnrollments
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Enrollment
name|enrollment
range|:
name|values
control|)
block|{
if|if
condition|(
name|inConflict
argument_list|(
name|idx
argument_list|,
name|enrollment
argument_list|)
condition|)
continue|continue;
name|iAssignment
index|[
name|idx
index|]
operator|=
name|enrollment
expr_stmt|;
name|backTrack
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
name|iAssignment
index|[
name|idx
index|]
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|canLeaveUnassigned
argument_list|(
name|request
argument_list|)
condition|)
name|backTrack
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_interface
specifier|public
interface|interface
name|SelectionCriterion
extends|extends
name|Comparator
argument_list|<
name|Enrollment
argument_list|>
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Enrollment
index|[]
name|current
parameter_list|,
name|Enrollment
index|[]
name|best
parameter_list|)
function_decl|;
specifier|public
name|boolean
name|canImprove
parameter_list|(
name|int
name|idx
parameter_list|,
name|Enrollment
index|[]
name|current
parameter_list|,
name|Enrollment
index|[]
name|best
parameter_list|)
function_decl|;
specifier|public
name|double
name|getTotalWeight
parameter_list|(
name|Enrollment
index|[]
name|assignment
parameter_list|)
function_decl|;
block|}
end_interface

unit|}
end_unit

