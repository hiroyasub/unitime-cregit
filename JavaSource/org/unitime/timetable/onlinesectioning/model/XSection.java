begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to The Apereo Foundation under one or more contributor license  * agreements. See the NOTICE file distributed with this work for  * additional information regarding copyright ownership.  *  * The Apereo Foundation licenses this file to you under the Apache License,  * Version 2.0 (the "License"); you may not use this file except in  * compliance with the License. You may obtain a copy of the License at:  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  * See the License for the specific language governing permissions and  * limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|onlinesectioning
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Externalizable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Lecture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Placement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|RoomLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimeLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|DistanceMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Instructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Section
import|;
end_import

begin_import
import|import
name|org
operator|.
name|cpsolver
operator|.
name|studentsct
operator|.
name|model
operator|.
name|Unavailability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|infinispan
operator|.
name|commons
operator|.
name|marshall
operator|.
name|Externalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|infinispan
operator|.
name|commons
operator|.
name|marshall
operator|.
name|SerializeWith
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Assignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|ClassInstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Class_
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|CourseOffering
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DatePattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|DepartmentalInstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|PreferenceLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|RoomPref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|TeachingClassRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|onlinesectioning
operator|.
name|OnlineSectioningHelper
import|;
end_import

begin_comment
comment|/**  * @author Tomas Muller  */
end_comment

begin_class
annotation|@
name|SerializeWith
argument_list|(
name|XSection
operator|.
name|XSectionSerializer
operator|.
name|class
argument_list|)
specifier|public
class|class
name|XSection
implements|implements
name|Serializable
implements|,
name|Comparable
argument_list|<
name|XSection
argument_list|>
implements|,
name|Externalizable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
name|Long
name|iUniqueId
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|iName
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|iNameByCourse
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Long
name|iSubpartId
init|=
literal|null
decl_stmt|;
specifier|private
name|Long
name|iParentId
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|iLimit
init|=
literal|0
decl_stmt|;
specifier|private
name|String
name|iNote
init|=
literal|null
decl_stmt|;
specifier|private
name|XTime
name|iTime
init|=
literal|null
decl_stmt|;
specifier|private
name|List
argument_list|<
name|XRoom
argument_list|>
name|iRooms
init|=
operator|new
name|ArrayList
argument_list|<
name|XRoom
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|XInstructor
argument_list|>
name|iInstructors
init|=
operator|new
name|ArrayList
argument_list|<
name|XInstructor
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|iAllowOverlap
init|=
literal|false
decl_stmt|;
specifier|private
name|String
name|iInstructionalType
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|iSubpartName
init|=
literal|null
decl_stmt|;
specifier|private
name|String
name|iExternalId
init|=
literal|null
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|iExternalIdByCourse
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|iEnabledForScheduling
init|=
literal|true
decl_stmt|;
specifier|private
name|boolean
name|iCancelled
init|=
literal|false
decl_stmt|;
specifier|public
name|XSection
parameter_list|()
block|{
block|}
specifier|public
name|XSection
parameter_list|(
name|ObjectInput
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|readExternal
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
specifier|public
name|XSection
parameter_list|(
name|Class_
name|clazz
parameter_list|,
name|OnlineSectioningHelper
name|helper
parameter_list|)
block|{
name|iUniqueId
operator|=
name|clazz
operator|.
name|getUniqueId
argument_list|()
expr_stmt|;
name|iAllowOverlap
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|isStudentAllowOverlap
argument_list|()
expr_stmt|;
name|iName
operator|=
operator|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|==
literal|null
condition|?
name|clazz
operator|.
name|getSectionNumber
argument_list|(
name|helper
operator|.
name|getHibSession
argument_list|()
argument_list|)
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartSuffix
argument_list|(
name|helper
operator|.
name|getHibSession
argument_list|()
argument_list|)
else|:
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|)
expr_stmt|;
name|iInstructionalType
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItypeDesc
argument_list|()
expr_stmt|;
name|iSubpartName
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
operator|.
name|getAbbv
argument_list|()
operator|.
name|trim
argument_list|()
expr_stmt|;
name|Assignment
name|assignment
init|=
name|clazz
operator|.
name|getCommittedAssignment
argument_list|()
decl_stmt|;
name|iEnabledForScheduling
operator|=
name|clazz
operator|.
name|isEnabledForStudentScheduling
argument_list|()
expr_stmt|;
name|iCancelled
operator|=
name|clazz
operator|.
name|isCancelled
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|clazz
operator|.
name|isEnabledForStudentScheduling
argument_list|()
condition|)
block|{
name|iLimit
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|isUnlimitedEnrollment
argument_list|()
condition|)
block|{
name|iLimit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|iLimit
operator|=
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
expr_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getExpectedCapacity
argument_list|()
operator|<
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
operator|&&
name|assignment
operator|!=
literal|null
operator|&&
operator|!
name|assignment
operator|.
name|getRooms
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|roomSize
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|Location
name|room
range|:
name|assignment
operator|.
name|getRooms
argument_list|()
control|)
name|roomSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|roomSize
argument_list|,
name|room
operator|.
name|getCapacity
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|room
operator|.
name|getCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|roomLimit
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|roomSize
operator|/
operator|(
name|clazz
operator|.
name|getRoomRatio
argument_list|()
operator|==
literal|null
condition|?
literal|1.0f
else|:
name|clazz
operator|.
name|getRoomRatio
argument_list|()
operator|)
argument_list|)
decl_stmt|;
name|iLimit
operator|=
name|Math
operator|.
name|min
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|clazz
operator|.
name|getExpectedCapacity
argument_list|()
argument_list|,
name|roomLimit
argument_list|)
argument_list|,
name|clazz
operator|.
name|getMaxExpectedCapacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iLimit
operator|>=
literal|9999
condition|)
name|iLimit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|iParentId
operator|=
operator|(
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|)
expr_stmt|;
name|iSubpartId
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getUniqueId
argument_list|()
expr_stmt|;
name|iNote
operator|=
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
expr_stmt|;
name|iExternalId
operator|=
name|clazz
operator|.
name|getExternalUniqueId
argument_list|()
expr_stmt|;
if|if
condition|(
name|iExternalId
operator|==
literal|null
condition|)
name|iExternalId
operator|=
name|clazz
operator|.
name|getClassLabel
argument_list|()
expr_stmt|;
for|for
control|(
name|CourseOffering
name|course
range|:
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getCourseOfferings
argument_list|()
control|)
block|{
name|iNameByCourse
operator|.
name|put
argument_list|(
name|course
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|clazz
operator|.
name|getClassSuffix
argument_list|(
name|course
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|extId
init|=
name|clazz
operator|.
name|getExternalId
argument_list|(
name|course
argument_list|)
decl_stmt|;
if|if
condition|(
name|extId
operator|==
literal|null
condition|)
name|extId
operator|=
name|clazz
operator|.
name|getClassLabel
argument_list|(
name|course
argument_list|)
expr_stmt|;
name|iExternalIdByCourse
operator|.
name|put
argument_list|(
name|course
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|extId
argument_list|)
expr_stmt|;
block|}
name|iNameByCourse
operator|.
name|put
argument_list|(
operator|-
literal|1l
argument_list|,
name|clazz
operator|.
name|getSectionNumberString
argument_list|(
name|helper
operator|.
name|getHibSession
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment
operator|!=
literal|null
condition|)
block|{
name|iTime
operator|=
operator|new
name|XTime
argument_list|(
name|assignment
argument_list|,
name|helper
operator|.
name|getExactTimeConversion
argument_list|()
argument_list|,
name|helper
operator|.
name|getDatePatternFormat
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Location
name|room
range|:
name|assignment
operator|.
name|getRooms
argument_list|()
control|)
name|iRooms
operator|.
name|add
argument_list|(
operator|new
name|XRoom
argument_list|(
name|room
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|i
init|=
name|clazz
operator|.
name|effectivePreferences
argument_list|(
name|RoomPref
operator|.
name|class
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RoomPref
name|p
init|=
operator|(
name|RoomPref
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|p
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
block|{
name|iRooms
operator|.
name|add
argument_list|(
operator|new
name|XRoom
argument_list|(
name|p
operator|.
name|getRoom
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|DatePattern
name|dp
init|=
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
decl_stmt|;
if|if
condition|(
name|dp
operator|!=
literal|null
condition|)
name|iTime
operator|=
operator|new
name|XTime
argument_list|(
name|dp
argument_list|,
name|helper
operator|.
name|getDatePatternFormat
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ClassInstructor
name|ci
range|:
name|clazz
operator|.
name|getClassInstructors
argument_list|()
control|)
block|{
name|iInstructors
operator|.
name|add
argument_list|(
operator|new
name|XInstructor
argument_list|(
name|ci
argument_list|,
name|helper
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TeachingClassRequest
name|tcr
range|:
name|clazz
operator|.
name|getTeachingRequests
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tcr
operator|.
name|isAssignInstructor
argument_list|()
operator|&&
name|tcr
operator|.
name|getTeachingRequest
argument_list|()
operator|.
name|isCommitted
argument_list|()
condition|)
block|{
for|for
control|(
name|DepartmentalInstructor
name|di
range|:
name|tcr
operator|.
name|getTeachingRequest
argument_list|()
operator|.
name|getAssignedInstructors
argument_list|()
control|)
name|iInstructors
operator|.
name|add
argument_list|(
operator|new
name|XInstructor
argument_list|(
name|di
argument_list|,
name|tcr
argument_list|,
name|helper
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|XSection
parameter_list|(
name|Section
name|section
parameter_list|)
block|{
name|iUniqueId
operator|=
name|section
operator|.
name|getId
argument_list|()
expr_stmt|;
name|iAllowOverlap
operator|=
name|section
operator|.
name|getSubpart
argument_list|()
operator|.
name|isAllowOverlap
argument_list|()
expr_stmt|;
name|iName
operator|=
name|section
operator|.
name|getName
argument_list|()
expr_stmt|;
name|iNameByCourse
operator|=
name|section
operator|.
name|getNameByCourse
argument_list|()
expr_stmt|;
name|iSubpartName
operator|=
name|section
operator|.
name|getSubpart
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|iLimit
operator|=
name|section
operator|.
name|getLimit
argument_list|()
expr_stmt|;
name|iParentId
operator|=
operator|(
name|section
operator|.
name|getParent
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|section
operator|.
name|getParent
argument_list|()
operator|.
name|getId
argument_list|()
operator|)
expr_stmt|;
name|iSubpartId
operator|=
name|section
operator|.
name|getSubpart
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
name|iInstructionalType
operator|=
name|section
operator|.
name|getSubpart
argument_list|()
operator|.
name|getInstructionalType
argument_list|()
expr_stmt|;
name|iNote
operator|=
name|section
operator|.
name|getNote
argument_list|()
expr_stmt|;
name|iTime
operator|=
name|section
operator|.
name|getTime
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|XTime
argument_list|(
name|section
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|iCancelled
operator|=
name|section
operator|.
name|isCancelled
argument_list|()
expr_stmt|;
if|if
condition|(
name|section
operator|.
name|getNrRooms
argument_list|()
operator|>
literal|0
condition|)
for|for
control|(
name|RoomLocation
name|room
range|:
name|section
operator|.
name|getRooms
argument_list|()
control|)
name|iRooms
operator|.
name|add
argument_list|(
operator|new
name|XRoom
argument_list|(
name|room
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|.
name|hasInstructors
argument_list|()
condition|)
block|{
for|for
control|(
name|Instructor
name|instructor
range|:
name|section
operator|.
name|getInstructors
argument_list|()
control|)
block|{
name|iInstructors
operator|.
name|add
argument_list|(
operator|new
name|XInstructor
argument_list|(
name|instructor
operator|.
name|getId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getExternalId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getName
argument_list|()
argument_list|,
name|instructor
operator|.
name|getEmail
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Unavailability
name|u
range|:
name|section
operator|.
name|getUnavailabilities
argument_list|()
control|)
block|{
if|if
condition|(
name|u
operator|.
name|getId
argument_list|()
operator|==
name|section
operator|.
name|getId
argument_list|()
condition|)
name|iInstructors
operator|.
name|add
argument_list|(
operator|new
name|XInstructor
argument_list|(
name|u
operator|.
name|getStudent
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|u
operator|.
name|getStudent
argument_list|()
operator|.
name|getExternalId
argument_list|()
argument_list|,
name|u
operator|.
name|getStudent
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|u
operator|.
name|isAllowOverlap
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** For testing only! */
annotation|@
name|Deprecated
specifier|public
name|XSection
parameter_list|(
name|String
name|externalId
parameter_list|)
block|{
name|iExternalId
operator|=
name|externalId
expr_stmt|;
block|}
comment|/** Section id */
specifier|public
name|Long
name|getSectionId
parameter_list|()
block|{
return|return
name|iUniqueId
return|;
block|}
comment|/**      * Section limit. This is defines the maximal number of students that can be      * enrolled into this section at the same time. It is -1 in the case of an      * unlimited section      */
specifier|public
name|int
name|getLimit
parameter_list|()
block|{
return|return
name|iLimit
return|;
block|}
comment|/** Section name */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|iName
return|;
block|}
comment|/** Scheduling subpart to which this section belongs */
specifier|public
name|Long
name|getSubpartId
parameter_list|()
block|{
return|return
name|iSubpartId
return|;
block|}
comment|/**      * Parent section of this section (can be null). If there is a parent      * section defined, a student that is enrolled in this section has to be      * enrolled in the parent section as well. Also, the same relation needs to      * be defined between subpart of this section and the subpart of the parent      * section.      */
specifier|public
name|Long
name|getParentId
parameter_list|()
block|{
return|return
name|iParentId
return|;
block|}
comment|/** Time placement of the section. */
specifier|public
name|XTime
name|getTime
parameter_list|()
block|{
return|return
name|iTime
return|;
block|}
comment|/** Number of rooms in which the section meet. */
specifier|public
name|int
name|getNrRooms
parameter_list|()
block|{
return|return
operator|(
name|iRooms
operator|==
literal|null
condition|?
literal|0
else|:
name|iRooms
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
comment|/**      * Room placement -- list of      * {@link org.cpsolver.coursett.model.RoomLocation}      */
specifier|public
name|List
argument_list|<
name|XRoom
argument_list|>
name|getRooms
parameter_list|()
block|{
return|return
name|iRooms
return|;
block|}
specifier|public
name|String
name|toRoomString
parameter_list|(
name|String
name|delim
parameter_list|)
block|{
name|String
name|ret
init|=
literal|""
decl_stmt|;
for|for
control|(
name|XRoom
name|room
range|:
name|iRooms
control|)
block|{
if|if
condition|(
operator|!
name|ret
operator|.
name|isEmpty
argument_list|()
condition|)
name|ret
operator|+=
name|delim
expr_stmt|;
name|ret
operator|+=
name|room
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getSubpartName
argument_list|()
operator|+
literal|" "
operator|+
name|getName
argument_list|()
operator|+
literal|" "
operator|+
operator|(
name|getTime
argument_list|()
operator|==
literal|null
condition|?
literal|"Arrange Hours"
else|:
name|getTime
argument_list|()
operator|.
name|toString
argument_list|()
operator|)
operator|+
operator|(
name|getNrRooms
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
operator|+
name|toRoomString
argument_list|(
literal|", "
argument_list|)
operator|)
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|(
name|Long
name|coruseId
parameter_list|)
block|{
return|return
name|getSubpartName
argument_list|()
operator|+
literal|" "
operator|+
name|getName
argument_list|(
name|coruseId
argument_list|)
operator|+
literal|" "
operator|+
operator|(
name|getTime
argument_list|()
operator|==
literal|null
condition|?
literal|"Arrange Hours"
else|:
name|getTime
argument_list|()
operator|.
name|toString
argument_list|()
operator|)
operator|+
operator|(
name|getNrRooms
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
operator|+
name|toRoomString
argument_list|(
literal|", "
argument_list|)
operator|)
return|;
block|}
comment|/**      * Return course-dependent section name      */
specifier|public
name|String
name|getName
parameter_list|(
name|long
name|courseId
parameter_list|)
block|{
if|if
condition|(
name|iNameByCourse
operator|==
literal|null
condition|)
return|return
name|getName
argument_list|()
return|;
name|String
name|name
init|=
name|iNameByCourse
operator|.
name|get
argument_list|(
name|courseId
argument_list|)
decl_stmt|;
return|return
operator|(
name|name
operator|==
literal|null
condition|?
name|getName
argument_list|()
else|:
name|name
operator|)
return|;
block|}
comment|/**      * Return course-dependent external id      */
specifier|public
name|String
name|getExternalId
parameter_list|(
name|long
name|courseId
parameter_list|)
block|{
if|if
condition|(
name|iExternalIdByCourse
operator|==
literal|null
condition|)
return|return
name|iExternalId
return|;
name|String
name|externalId
init|=
name|iExternalIdByCourse
operator|.
name|get
argument_list|(
name|courseId
argument_list|)
decl_stmt|;
return|return
operator|(
name|externalId
operator|==
literal|null
condition|?
name|iExternalId
else|:
name|externalId
operator|)
return|;
block|}
comment|/**      * Return course-dependent section names      */
specifier|public
name|Map
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|getNameByCourse
parameter_list|()
block|{
return|return
name|iNameByCourse
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
operator|||
operator|!
operator|(
name|o
operator|instanceof
name|XSection
operator|)
condition|)
return|return
literal|false
return|;
return|return
name|getSectionId
argument_list|()
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|XSection
operator|)
name|o
operator|)
operator|.
name|getSectionId
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
operator|(
name|getSectionId
argument_list|()
operator|^
operator|(
name|getSectionId
argument_list|()
operator|>>>
literal|32
operator|)
operator|)
return|;
block|}
comment|/**      * Section note      */
specifier|public
name|String
name|getNote
parameter_list|()
block|{
return|return
name|iNote
return|;
block|}
comment|/**      * Instructors      */
specifier|public
name|List
argument_list|<
name|XInstructor
argument_list|>
name|getAllInstructors
parameter_list|()
block|{
return|return
name|iInstructors
return|;
block|}
comment|/**      * Instructors (only those that can be displayed)      */
specifier|public
name|List
argument_list|<
name|XInstructor
argument_list|>
name|getInstructors
parameter_list|()
block|{
name|List
argument_list|<
name|XInstructor
argument_list|>
name|instructors
init|=
operator|new
name|ArrayList
argument_list|<
name|XInstructor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|XInstructor
name|instructor
range|:
name|iInstructors
control|)
if|if
condition|(
name|instructor
operator|.
name|isAllowDisplay
argument_list|()
condition|)
name|instructors
operator|.
name|add
argument_list|(
name|instructor
argument_list|)
expr_stmt|;
return|return
name|instructors
return|;
block|}
annotation|@
name|Deprecated
specifier|public
name|String
name|getInstructorIds
parameter_list|()
block|{
if|if
condition|(
name|iInstructors
operator|==
literal|null
operator|||
name|iInstructors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|StringBuffer
name|ret
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|XInstructor
name|instructor
range|:
name|iInstructors
control|)
block|{
if|if
condition|(
name|ret
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|ret
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|instructor
operator|.
name|getIntructorId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Deprecated
specifier|public
name|String
name|getInstructorNames
parameter_list|()
block|{
if|if
condition|(
name|iInstructors
operator|==
literal|null
operator|||
name|iInstructors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|StringBuffer
name|ret
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|XInstructor
name|instructor
range|:
name|iInstructors
control|)
block|{
if|if
condition|(
name|ret
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|ret
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|append
argument_list|(
name|instructor
operator|.
name|getName
argument_list|()
operator|+
literal|"|"
operator|+
operator|(
name|instructor
operator|.
name|getEmail
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|instructor
operator|.
name|getEmail
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Returns true if student conflicts between this section and the given one are to be ignored      */
specifier|public
name|boolean
name|isToIgnoreStudentConflictsWith
parameter_list|(
name|Collection
argument_list|<
name|XDistribution
argument_list|>
name|distributions
parameter_list|,
name|Long
name|sectionId
parameter_list|)
block|{
if|if
condition|(
name|distributions
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|XDistribution
name|distribution
range|:
name|distributions
control|)
if|if
condition|(
name|distribution
operator|.
name|getDistributionType
argument_list|()
operator|==
name|XDistributionType
operator|.
name|IngoreConflicts
operator|&&
name|distribution
operator|.
name|getSectionIds
argument_list|()
operator|.
name|contains
argument_list|(
name|getSectionId
argument_list|()
argument_list|)
operator|&&
name|distribution
operator|.
name|getSectionIds
argument_list|()
operator|.
name|contains
argument_list|(
name|sectionId
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|XSection
name|section
parameter_list|)
block|{
return|return
name|getSectionId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|section
operator|.
name|getSectionId
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|int
name|getDistanceInMinutes
parameter_list|(
name|DistanceMetric
name|m
parameter_list|,
name|List
argument_list|<
name|XRoom
argument_list|>
name|other
parameter_list|)
block|{
name|int
name|dist
init|=
literal|0
decl_stmt|;
for|for
control|(
name|XRoom
name|r1
range|:
name|getRooms
argument_list|()
control|)
for|for
control|(
name|XRoom
name|r2
range|:
name|other
control|)
block|{
name|dist
operator|=
name|Math
operator|.
name|max
argument_list|(
name|dist
argument_list|,
name|r1
operator|.
name|getDistanceInMinutes
argument_list|(
name|m
argument_list|,
name|r2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dist
return|;
block|}
specifier|public
name|int
name|getDistanceInMinutes
parameter_list|(
name|XSection
name|other
parameter_list|,
name|DistanceMetric
name|m
parameter_list|)
block|{
if|if
condition|(
name|getNrRooms
argument_list|()
operator|==
literal|0
operator|||
name|other
operator|.
name|getNrRooms
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|XTime
name|t1
init|=
name|getTime
argument_list|()
decl_stmt|;
name|XTime
name|t2
init|=
name|other
operator|.
name|getTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|t1
operator|==
literal|null
operator|||
name|t2
operator|==
literal|null
operator|||
operator|!
name|t1
operator|.
name|shareDays
argument_list|(
name|t2
argument_list|)
operator|||
operator|!
name|t1
operator|.
name|shareWeeks
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
name|int
name|a1
init|=
name|t1
operator|.
name|getSlot
argument_list|()
decl_stmt|,
name|a2
init|=
name|t2
operator|.
name|getSlot
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|doComputeDistanceConflictsBetweenNonBTBClasses
argument_list|()
condition|)
block|{
if|if
condition|(
name|a1
operator|+
name|t1
operator|.
name|getLength
argument_list|()
operator|<=
name|a2
condition|)
block|{
name|int
name|dist
init|=
name|getDistanceInMinutes
argument_list|(
name|m
argument_list|,
name|other
operator|.
name|getRooms
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|>
name|t1
operator|.
name|getBreakTime
argument_list|()
operator|+
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|*
operator|(
name|a2
operator|-
name|a1
operator|-
name|t1
operator|.
name|getLength
argument_list|()
operator|)
condition|)
return|return
name|dist
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|a1
operator|+
name|t1
operator|.
name|getLength
argument_list|()
operator|==
name|a2
condition|)
return|return
name|getDistanceInMinutes
argument_list|(
name|m
argument_list|,
name|other
operator|.
name|getRooms
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/** Return true if overlaps are allowed, but the number of overlapping slots should be minimized. */
specifier|public
name|boolean
name|isAllowOverlap
parameter_list|()
block|{
return|return
name|iAllowOverlap
return|;
block|}
specifier|public
name|String
name|getSubpartName
parameter_list|()
block|{
return|return
name|iSubpartName
return|;
block|}
specifier|public
name|String
name|getInstructionalType
parameter_list|()
block|{
return|return
name|iInstructionalType
return|;
block|}
specifier|public
name|boolean
name|isEnabledForScheduling
parameter_list|()
block|{
return|return
name|iEnabledForScheduling
return|;
block|}
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
name|iCancelled
return|;
block|}
comment|/**      * True, if this section overlaps with the given assignment in time and      * space      */
specifier|public
name|boolean
name|isOverlapping
parameter_list|(
name|Collection
argument_list|<
name|XDistribution
argument_list|>
name|distributions
parameter_list|,
name|XSection
name|other
parameter_list|)
block|{
if|if
condition|(
name|isAllowOverlap
argument_list|()
operator|||
name|other
operator|.
name|isAllowOverlap
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getTime
argument_list|()
operator|==
literal|null
operator|||
name|other
operator|.
name|getTime
argument_list|()
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|isToIgnoreStudentConflictsWith
argument_list|(
name|distributions
argument_list|,
name|other
operator|.
name|getSectionId
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
name|getTime
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|other
operator|.
name|getTime
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * True, if this section overlaps with one of the given set of assignments      * in time and space      */
specifier|public
name|boolean
name|isOverlapping
parameter_list|(
name|Collection
argument_list|<
name|XDistribution
argument_list|>
name|distributions
parameter_list|,
name|Collection
argument_list|<
name|XSection
argument_list|>
name|assignments
parameter_list|)
block|{
if|if
condition|(
name|isAllowOverlap
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getTime
argument_list|()
operator|==
literal|null
operator|||
name|assignments
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|XSection
name|assignment
range|:
name|assignments
control|)
block|{
if|if
condition|(
name|assignment
operator|.
name|isAllowOverlap
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|assignment
operator|.
name|getTime
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
if|if
condition|(
name|isToIgnoreStudentConflictsWith
argument_list|(
name|distributions
argument_list|,
name|assignment
operator|.
name|getSectionId
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|getTime
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|assignment
operator|.
name|getTime
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|Placement
name|toPlacement
parameter_list|()
block|{
if|if
condition|(
name|getTime
argument_list|()
operator|==
literal|null
operator|||
name|getTime
argument_list|()
operator|.
name|getDays
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|RoomLocation
argument_list|>
name|rooms
init|=
operator|new
name|ArrayList
argument_list|<
name|RoomLocation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|XRoom
name|r
range|:
name|getRooms
argument_list|()
control|)
name|rooms
operator|.
name|add
argument_list|(
operator|new
name|RoomLocation
argument_list|(
name|r
operator|.
name|getUniqueId
argument_list|()
argument_list|,
name|r
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|r
operator|.
name|getX
argument_list|()
argument_list|,
name|r
operator|.
name|getY
argument_list|()
argument_list|,
name|r
operator|.
name|getIgnoreTooFar
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|Placement
argument_list|(
operator|new
name|Lecture
argument_list|(
name|getSectionId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|getSubpartId
argument_list|()
argument_list|,
name|getName
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|TimeLocation
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|RoomLocation
argument_list|>
argument_list|()
argument_list|,
name|getNrRooms
argument_list|()
argument_list|,
literal|null
argument_list|,
name|getLimit
argument_list|()
argument_list|,
name|getLimit
argument_list|()
argument_list|,
literal|1.0
argument_list|)
argument_list|,
name|getTime
argument_list|()
operator|.
name|toTimeLocation
argument_list|()
argument_list|,
name|rooms
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|Instructor
argument_list|>
name|toInstructors
parameter_list|()
block|{
if|if
condition|(
name|getInstructors
argument_list|()
operator|==
literal|null
operator|||
name|getInstructors
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|Instructor
argument_list|>
name|instructors
init|=
operator|new
name|ArrayList
argument_list|<
name|Instructor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|XInstructor
name|instructor
range|:
name|getInstructors
argument_list|()
control|)
name|instructors
operator|.
name|add
argument_list|(
operator|new
name|Instructor
argument_list|(
name|instructor
operator|.
name|getIntructorId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getExternalId
argument_list|()
argument_list|,
name|instructor
operator|.
name|getName
argument_list|()
argument_list|,
name|instructor
operator|.
name|getEmail
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|instructors
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|readExternal
parameter_list|(
name|ObjectInput
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|iUniqueId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|iName
operator|=
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|int
name|nrNames
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|iNameByCourse
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nrNames
condition|;
name|i
operator|++
control|)
name|iNameByCourse
operator|.
name|put
argument_list|(
name|in
operator|.
name|readLong
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
name|iSubpartId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|iParentId
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
if|if
condition|(
name|iParentId
operator|<
literal|0
condition|)
name|iParentId
operator|=
literal|null
expr_stmt|;
name|iLimit
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|iNote
operator|=
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|iTime
operator|=
operator|(
name|in
operator|.
name|readBoolean
argument_list|()
condition|?
operator|new
name|XTime
argument_list|(
name|in
argument_list|)
else|:
literal|null
operator|)
expr_stmt|;
name|int
name|nrRooms
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|iRooms
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nrRooms
condition|;
name|i
operator|++
control|)
name|iRooms
operator|.
name|add
argument_list|(
operator|new
name|XRoom
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|nrInstructors
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|iInstructors
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nrInstructors
condition|;
name|i
operator|++
control|)
name|iInstructors
operator|.
name|add
argument_list|(
operator|new
name|XInstructor
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|iAllowOverlap
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|iInstructionalType
operator|=
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|iSubpartName
operator|=
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|iExternalId
operator|=
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
name|int
name|nrExtIds
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|iExternalIdByCourse
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nrExtIds
condition|;
name|i
operator|++
control|)
name|iExternalIdByCourse
operator|.
name|put
argument_list|(
name|in
operator|.
name|readLong
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|in
operator|.
name|readObject
argument_list|()
argument_list|)
expr_stmt|;
name|iEnabledForScheduling
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|iCancelled
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeExternal
parameter_list|(
name|ObjectOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|iUniqueId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|iName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|iNameByCourse
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|iNameByCourse
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeLong
argument_list|(
name|iSubpartId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeLong
argument_list|(
name|iParentId
operator|==
literal|null
condition|?
operator|-
literal|1l
else|:
name|iParentId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|iLimit
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|iNote
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|iTime
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|iTime
operator|!=
literal|null
condition|)
name|iTime
operator|.
name|writeExternal
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|iRooms
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|XRoom
name|room
range|:
name|iRooms
control|)
name|room
operator|.
name|writeExternal
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|iInstructors
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|XInstructor
name|instructor
range|:
name|iInstructors
control|)
name|instructor
operator|.
name|writeExternal
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|iAllowOverlap
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|iInstructionalType
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|iSubpartName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|iExternalId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|iExternalIdByCourse
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|iExternalIdByCourse
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeObject
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeBoolean
argument_list|(
name|iEnabledForScheduling
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|iCancelled
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
class|class
name|XSectionSerializer
implements|implements
name|Externalizer
argument_list|<
name|XSection
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|writeObject
parameter_list|(
name|ObjectOutput
name|output
parameter_list|,
name|XSection
name|object
parameter_list|)
throws|throws
name|IOException
block|{
name|object
operator|.
name|writeExternal
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|XSection
name|readObject
parameter_list|(
name|ObjectInput
name|input
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
return|return
operator|new
name|XSection
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

