begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.0 (University Course Timetabling& Student Sectioning Application)  * Copyright (C) 2007, UniTime.org, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program; if not, write to the Free Software Foundation, Inc.,  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DecimalFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|SessionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hibernate
operator|.
name|criterion
operator|.
name|Restrictions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|commons
operator|.
name|Debug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|commons
operator|.
name|Email
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|commons
operator|.
name|User
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|ApplicationProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|form
operator|.
name|ListSolutionsForm
operator|.
name|InfoComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|base
operator|.
name|BaseSolution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|comparators
operator|.
name|ClassComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|comparators
operator|.
name|DivSecAssignmentComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|SolutionDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|dao
operator|.
name|SolutionInfoDAO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|ClassAssignmentProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|ui
operator|.
name|AssignmentPreferenceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|ui
operator|.
name|PropertiesInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|ui
operator|.
name|TimetableInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|solver
operator|.
name|ui
operator|.
name|TimetableInfoFileProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|Placement
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|CSVFile
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|DataProperties
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|ifs
operator|.
name|util
operator|.
name|CSVFile
operator|.
name|CSVField
import|;
end_import

begin_class
specifier|public
class|class
name|Solution
extends|extends
name|BaseSolution
implements|implements
name|ClassAssignmentProxy
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
specifier|static
name|Log
name|sLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Solution
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|DecimalFormat
name|sSufixFormat
init|=
operator|new
name|DecimalFormat
argument_list|(
literal|"000"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
name|boolean
name|DEBUG
init|=
literal|false
decl_stmt|;
comment|/*[CONSTRUCTOR MARKER BEGIN]*/
specifier|public
name|Solution
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/** 	 * Constructor for primary key 	 */
specifier|public
name|Solution
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|Long
name|uniqueId
parameter_list|)
block|{
name|super
argument_list|(
name|uniqueId
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Constructor for required fields 	 */
specifier|public
name|Solution
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|Long
name|uniqueId
parameter_list|,
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
operator|.
name|SolverGroup
name|owner
parameter_list|,
name|java
operator|.
name|util
operator|.
name|Date
name|created
parameter_list|,
name|java
operator|.
name|lang
operator|.
name|Boolean
name|valid
parameter_list|,
name|java
operator|.
name|lang
operator|.
name|Boolean
name|commited
parameter_list|)
block|{
name|super
argument_list|(
name|uniqueId
argument_list|,
name|owner
argument_list|,
name|created
argument_list|,
name|valid
argument_list|,
name|commited
argument_list|)
expr_stmt|;
block|}
comment|/*[CONSTRUCTOR MARKER END]*/
specifier|public
name|SolutionInfo
name|getSolutionInfo
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
literal|"GlobalInfo"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|getGlobalInfo
argument_list|()
return|;
return|return
operator|(
name|SolutionInfo
operator|)
operator|(
operator|new
name|SolutionInfoDAO
argument_list|()
operator|)
operator|.
name|getSession
argument_list|()
operator|.
name|createQuery
argument_list|(
literal|"select si from SolutionInfo si where si.definition.name=:name and si.solution.uniqueId=:solutionId"
argument_list|)
operator|.
name|setString
argument_list|(
literal|"name"
argument_list|,
name|name
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|uniqueResult
argument_list|()
return|;
comment|/* 		org.hibernate.Session session = (new SolutionInfoDAO()).getSession(); 		SolverInfoDef def = SolverInfoDef.findByName(session,name); 		if (def==null) return null; 		return (SolutionInfo)session.createCriteria(SolutionInfo.class).add(Restrictions.eq("definition",def)).add(Restrictions.eq("solution",this)).setCacheable(true).uniqueResult(); 		*/
block|}
specifier|public
name|TimetableInfo
name|getInfo
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|Exception
block|{
name|SolutionInfo
name|sinfo
init|=
name|getSolutionInfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sinfo
operator|==
literal|null
condition|)
return|return
literal|null
return|;
return|return
name|sinfo
operator|.
name|getInfo
argument_list|()
return|;
block|}
comment|//NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 	private void removeCommitJenrl(org.hibernate.Session hibSession, Assignment assignment, ConstraintInfo cinfo, JenrlInfo jenrl, Hashtable solverInfos) throws Exception { 		Assignment otherAssignment = null; 		for (Iterator i=cinfo.getAssignments().iterator();i.hasNext();) { 			Assignment a = (Assignment)i.next(); 			if (!assignment.equals(a)) { 				otherAssignment = a; break; 			} 		} 		if (otherAssignment==null) return; 		if (DEBUG) { 			sLog.debug( 					assignment.getSolution().getUniqueId()+","+assignment.getClassName()+","+assignment.getPlacement().getName()+","+ 					otherAssignment.getSolution().getUniqueId()+","+otherAssignment.getClassName()+","+otherAssignment.getPlacement().getName()+","+ 					(-jenrl.getJenrl())); 		} 		for (Iterator j=otherAssignment.getAssignmentInfo().iterator();j.hasNext();) { 			AssignmentInfo aInfo = (AssignmentInfo)j.next(); 			if (!"AssignmentInfo".equals(aInfo.getDefinition().getName())) continue; 			AssignmentPreferenceInfo assignmentInfo = (AssignmentPreferenceInfo)aInfo.getInfo(); 			assignmentInfo.setNrStudentConflicts(assignmentInfo.getNrStudentConflicts()-(int)jenrl.getJenrl()); 			aInfo.setInfo(assignmentInfo); 			hibSession.saveOrUpdate(aInfo); 			if (DEBUG) sLog.debug("   aInfo["+otherAssignment.getClassName()+"]-="+((int)jenrl.getJenrl())+" (total:"+assignmentInfo.getNrStudentConflicts()+")"); 		} 		 		SolutionInfo sInfo = (SolutionInfo)solverInfos.get(otherAssignment.getSolution().getUniqueId()); 		if (sInfo == null) { 			sInfo = otherAssignment.getSolution().getSolutionInfo("GlobalInfo"); 			if (sInfo!=null) 				solverInfos.put(otherAssignment.getSolution().getUniqueId(), sInfo); 		} 		 		if (sInfo!=null) { 			PropertiesInfo propInfo = (PropertiesInfo)sInfo.getInfo(); 			String conf = propInfo.getProperty("Student conflicts"); 			int studentConf = Integer.parseInt(conf.substring(0,conf.indexOf(' '))); 			int commitedStart = conf.indexOf("committed:")+"committed:".length(); 			int commitedEnd = conf.indexOf(',',commitedStart); 			int commitedConf = Integer.parseInt(conf.substring(commitedStart,commitedEnd)); 			String newConf = (studentConf-(int)jenrl.getJenrl())+" [committed:"+(commitedConf-(int)jenrl.getJenrl())+conf.substring(commitedEnd); 			propInfo.setProperty("Student conflicts", newConf); 			sInfo.setInfo(propInfo); 			if (DEBUG) sLog.debug("   sInfo["+otherAssignment.getSolution().getOwner().getName()+"]-="+((int)jenrl.getJenrl())+" (total:"+(commitedConf-(int)jenrl.getJenrl())+")"); 		} 			 		if (!otherAssignment.getSolution().isCommited().booleanValue()) { 			if (DEBUG) sLog.debug("   -jInfo["+assignment.getClassName()+","+otherAssignment.getClassName()+"]="+((JenrlInfo)cinfo.getInfo()).getJenrl()); 			for (Iterator i=cinfo.getAssignments().iterator();i.hasNext();) { 				Assignment a = (Assignment)i.next(); 				a.getConstraintInfo().remove(cinfo); 				hibSession.saveOrUpdate(a); 			} 			hibSession.delete(cinfo); 		} 	} 	 	private void addCommitJenrl(org.hibernate.Session hibSession, Assignment assignment, Assignment otherAssignment, int jenrl, SolverInfoDef defJenrlInfo, Hashtable solverInfos) throws Exception { 		if (DEBUG) { 			sLog.debug( 					assignment.getSolution().getUniqueId()+","+assignment.getClassName()+","+assignment.getPlacement().getName()+","+ 					otherAssignment.getSolution().getUniqueId()+","+otherAssignment.getClassName()+","+otherAssignment.getPlacement().getName()+","+ 					jenrl); 		} 		if (!otherAssignment.getSolution().isCommited().booleanValue()) { 			JenrlInfo jInfo = new JenrlInfo(); 			jInfo.setJenrl(jenrl); 			jInfo.setIsCommited(true); 			jInfo.setIsDistance(!assignment.getTimeLocation().hasIntersection(otherAssignment.getTimeLocation())); 			ConstraintInfo constraintInfo = new ConstraintInfo(); 			constraintInfo.setInfo(jInfo); 			constraintInfo.setDefinition(defJenrlInfo); 			constraintInfo.setOpt("C"+(jInfo.isSatisfied()?"S":"")+(jInfo.isHard()?"H":"")+(jInfo.isDistance()?"D":"")+(jInfo.isFixed()?"F":"")); 			HashSet jAssignments = new HashSet(); 			jAssignments.add(assignment); 			jAssignments.add(otherAssignment); 			constraintInfo.setAssignments(jAssignments); 			hibSession.saveOrUpdate(constraintInfo); 			assignment.getConstraintInfo().add(constraintInfo); 			hibSession.saveOrUpdate(assignment); 			otherAssignment.getConstraintInfo().add(constraintInfo); 			hibSession.saveOrUpdate(otherAssignment); 			if (DEBUG) sLog.debug("   +jInfo["+assignment.getClassName()+","+otherAssignment.getClassName()+"]="+jInfo.getJenrl()); 		} 		 		for (Iterator j=otherAssignment.getAssignmentInfo().iterator();j.hasNext();) { 			AssignmentInfo aInfo = (AssignmentInfo)j.next(); 			if (!"AssignmentInfo".equals(aInfo.getDefinition().getName())) continue; 			AssignmentPreferenceInfo assignmentInfo = (AssignmentPreferenceInfo)aInfo.getInfo(); 			assignmentInfo.setNrStudentConflicts(assignmentInfo.getNrStudentConflicts()+jenrl); 			aInfo.setInfo(assignmentInfo); 			hibSession.saveOrUpdate(aInfo); 			if (DEBUG) sLog.debug("   aInfo["+otherAssignment.getClassName()+"]+="+jenrl+" (total:"+assignmentInfo.getNrStudentConflicts()+")"); 		} 		 		SolutionInfo sInfo = (SolutionInfo)solverInfos.get(otherAssignment.getSolution().getUniqueId()); 		if (sInfo == null) { 			sInfo = otherAssignment.getSolution().getSolutionInfo("GlobalInfo"); 			if (sInfo!=null) 				solverInfos.put(otherAssignment.getSolution().getUniqueId(), sInfo); 		}  		if (sInfo!=null) { 			PropertiesInfo propInfo = (PropertiesInfo)sInfo.getInfo(); 			String conf = propInfo.getProperty("Student conflicts"); 			String newConf = conf; 			 			int studentConf = Integer.parseInt(conf.substring(0,conf.indexOf(' '))); 			int commitedStart = conf.indexOf("committed:"); 			int commitedEnd = conf.indexOf(',',commitedStart); 			int commitedConf = 0; 			if (commitedStart>=0) { 				commitedConf = Integer.parseInt(conf.substring(commitedStart+"committed:".length(),commitedEnd)); 				newConf = (studentConf+jenrl)+" [committed:"+(commitedConf+jenrl)+conf.substring(commitedEnd); 			} else { 				commitedEnd = conf.indexOf('[')+1; 				newConf = (studentConf+jenrl)+" [committed:"+(commitedConf+jenrl)+", "+conf.substring(commitedEnd); 			} 			if (DEBUG) sLog.debug("   sInfo["+otherAssignment.getSolution().getOwner().getName()+"]+="+jenrl+" (total:"+(commitedConf+jenrl)+")"); 			propInfo.setProperty("Student conflicts", newConf); 			sInfo.setInfo(propInfo); 		} 	} 	*/
specifier|public
name|void
name|uncommitSolution
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
throws|throws
name|Exception
block|{
name|uncommitSolution
argument_list|(
name|hibSession
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|uncommitSolution
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|String
name|sendNotificationPuid
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|DEBUG
condition|)
name|sLog
operator|.
name|debug
argument_list|(
literal|"uncommit["
operator|+
name|getUniqueId
argument_list|()
operator|+
literal|","
operator|+
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] -------------------------------------------------------"
argument_list|)
expr_stmt|;
name|setCommitDate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setCommited
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
comment|//NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 		Hashtable solverInfos = new Hashtable(); 		Iterator jenrlInfos =  			hibSession.createQuery( 				"select distinct a, c from " + 				"ConstraintInfo c inner join c.assignments a where " + 				"c.definition.name='JenrlInfo' and c.opt like '%C%' and a.solution=:solutionId") 				.setInteger("solutionId",getUniqueId().intValue()) 				.iterate(); 		while (jenrlInfos.hasNext()) { 			Object[] next = (Object[])jenrlInfos.next();  			Assignment assignment = (Assignment)next[0]; 			ConstraintInfo cinfo = (ConstraintInfo)next[1]; 			JenrlInfo jenrl = (JenrlInfo)cinfo.getInfo(); 			removeCommitJenrl(hibSession,assignment,cinfo,jenrl,solverInfos); 		} 		 		for (Iterator i=solverInfos.values().iterator();i.hasNext();) { 			SolverInfo sInfo = (SolverInfo)i.next(); 			hibSession.saveOrUpdate(sInfo); 		} 		*/
name|hibSession
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"Event"
argument_list|,
literal|"select e.uniqueId from Event e inner join e.relatedCourses r, Assignment a where "
operator|+
literal|"r.ownerId=a.clazz.uniqueId and r.ownerType="
operator|+
name|ExamOwner
operator|.
name|sOwnerTypeClass
operator|+
literal|" and e.eventType.reference='"
operator|+
name|EventType
operator|.
name|sEventTypeClass
operator|+
literal|"' and "
operator|+
literal|"a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|removeDivSecNumbers
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendNotificationPuid
operator|!=
literal|null
condition|)
name|sendNotification
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|sendNotificationPuid
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|commitSolution
parameter_list|(
name|Vector
name|messages
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|commitSolution
argument_list|(
name|messages
argument_list|,
name|hibSession
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|shareRooms
parameter_list|(
name|Assignment
name|a1
parameter_list|,
name|Assignment
name|a2
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a1
operator|.
name|getPlacement
argument_list|()
operator|.
name|sameRooms
argument_list|(
name|a2
operator|.
name|getPlacement
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Iterator
name|i
init|=
name|a1
operator|.
name|getClazz
argument_list|()
operator|.
name|getDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distObj
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|DistributionPref
name|dp
init|=
name|distObj
operator|.
name|getDistributionPref
argument_list|()
decl_stmt|;
name|String
name|ref
init|=
name|dp
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"MEET_WITH"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
literal|"CAN_SHARE_ROOM"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|dp
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Iterator
name|j
init|=
name|dp
operator|.
name|getDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distObj2
init|=
operator|(
name|DistributionObject
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distObj2
operator|.
name|getPrefGroup
argument_list|()
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|getClazz
argument_list|()
argument_list|)
operator|||
name|distObj2
operator|.
name|getPrefGroup
argument_list|()
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|a1
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distObj
init|=
operator|(
name|DistributionObject
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|DistributionPref
name|dp
init|=
name|distObj
operator|.
name|getDistributionPref
argument_list|()
decl_stmt|;
name|String
name|ref
init|=
name|dp
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"MEET_WITH"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
literal|"CAN_SHARE_ROOM"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|dp
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Iterator
name|j
init|=
name|dp
operator|.
name|getDistributionObjects
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionObject
name|distObj2
init|=
operator|(
name|DistributionObject
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|distObj2
operator|.
name|getPrefGroup
argument_list|()
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|getClazz
argument_list|()
argument_list|)
operator|||
name|distObj2
operator|.
name|getPrefGroup
argument_list|()
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|getClazz
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|a1
operator|.
name|getInstructors
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instr
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|instr
operator|.
name|getDistributionPreferences
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DistributionPref
name|dp
init|=
operator|(
name|DistributionPref
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|ref
init|=
name|dp
operator|.
name|getDistributionType
argument_list|()
operator|.
name|getReference
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
literal|"MEET_WITH"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
operator|&&
operator|!
literal|"CAN_SHARE_ROOM"
operator|.
name|equals
argument_list|(
name|ref
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|dp
operator|.
name|getPrefLevel
argument_list|()
operator|.
name|getPrefProlog
argument_list|()
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Iterator
name|k
init|=
name|DepartmentalInstructor
operator|.
name|getAllForInstructor
argument_list|(
name|instr
argument_list|,
name|instr
operator|.
name|getDepartment
argument_list|()
operator|.
name|getSession
argument_list|()
operator|.
name|getUniqueId
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|inst2
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|l
init|=
name|inst2
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|l
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ClassInstructor
name|ci
init|=
operator|(
name|ClassInstructor
operator|)
name|l
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|ci
operator|.
name|getClassInstructing
argument_list|()
operator|.
name|equals
argument_list|(
name|a2
operator|.
name|getClazz
argument_list|()
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|commitSolution
parameter_list|(
name|Vector
name|messages
parameter_list|,
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|String
name|sendNotificationPuid
parameter_list|)
throws|throws
name|Exception
block|{
name|List
name|solutions
init|=
name|hibSession
operator|.
name|createCriteria
argument_list|(
name|Solution
operator|.
name|class
argument_list|)
operator|.
name|add
argument_list|(
name|Restrictions
operator|.
name|eq
argument_list|(
literal|"owner"
argument_list|,
name|getOwner
argument_list|()
argument_list|)
argument_list|)
operator|.
name|list
argument_list|()
decl_stmt|;
name|Solution
name|uncommittedSolution
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|solutions
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Solution
name|s
init|=
operator|(
name|Solution
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|this
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|s
operator|.
name|isCommited
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|uncommittedSolution
operator|=
name|s
expr_stmt|;
name|s
operator|.
name|uncommitSolution
argument_list|(
name|hibSession
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
condition|)
name|sLog
operator|.
name|debug
argument_list|(
literal|"commit["
operator|+
name|getUniqueId
argument_list|()
operator|+
literal|","
operator|+
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] -------------------------------------------------------"
argument_list|)
expr_stmt|;
name|Query
name|q
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct r from Assignment a, Assignment as xa, Location as r "
operator|+
literal|"where a.solution.uniqueId=:solutionId and r in elements(a.rooms) "
operator|+
literal|"and xa.solution.commited=true and xa.solution.owner.session.uniqueId=:sessionId and xa.solution.owner.uniqueId!=:ownerId and r in elements(xa.rooms)"
argument_list|)
decl_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"ownerId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getSession
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|rooms
init|=
name|q
operator|.
name|iterate
argument_list|()
decl_stmt|;
name|boolean
name|isOK
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|rooms
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Location
name|room
init|=
operator|(
name|Location
operator|)
name|rooms
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|room
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|!=
literal|null
operator|&&
name|room
operator|.
name|isIgnoreRoomCheck
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
continue|continue;
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from Location r, Assignment as a "
operator|+
literal|"where r.uniqueId=:roomId and a in elements(r.assignments) and a.solution.commited=true and a.solution.owner.uniqueId!=:ownerId"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"roomId"
argument_list|,
name|room
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"ownerId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|List
name|commitedAssignments
init|=
name|q
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|commitedAssignments
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from Location r, Assignment as a "
operator|+
literal|"where r.uniqueId=:roomId and a in elements(r.assignments) and a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"roomId"
argument_list|,
name|room
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|assignments
init|=
name|q
operator|.
name|iterate
argument_list|()
decl_stmt|;
while|while
condition|(
name|assignments
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|assignments
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|commitedAssignments
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|b
init|=
operator|(
name|Assignment
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|b
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|&&
operator|!
name|shareRooms
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|messages
operator|.
name|addElement
argument_list|(
literal|"Class "
operator|+
name|a
operator|.
name|getClassName
argument_list|()
operator|+
literal|" "
operator|+
name|a
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" overlaps with "
operator|+
name|b
operator|.
name|getClassName
argument_list|()
operator|+
literal|" "
operator|+
name|b
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" (room "
operator|+
name|room
operator|.
name|getLabel
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|isOK
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct i from Assignment a, Assignment as xa, DepartmentalInstructor as i "
operator|+
literal|"where a.solution.uniqueId=:solutionId and i in elements(a.instructors) "
operator|+
literal|"and xa.solution.commited=true and xa.solution.owner.session.uniqueId=:sessionId and xa.solution.owner.uniqueId!=:ownerId and i in elements(xa.instructors)"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"ownerId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getSession
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|instructors
init|=
name|q
operator|.
name|iterate
argument_list|()
decl_stmt|;
while|while
condition|(
name|instructors
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|instructors
operator|.
name|next
argument_list|()
decl_stmt|;
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from DepartmentalInstructor i, Assignment as a "
operator|+
literal|"where i.uniqueId=:instructorId and a in elements(i.assignments) and a.solution.commited=true and a.solution.owner.uniqueId!=:ownerId"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"instructorId"
argument_list|,
name|instructor
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setLong
argument_list|(
literal|"ownerId"
argument_list|,
name|getOwner
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|List
name|commitedAssignments
init|=
name|q
operator|.
name|list
argument_list|()
decl_stmt|;
if|if
condition|(
name|commitedAssignments
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|q
operator|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select distinct a from DepartmentalInstructor i, Assignment as a "
operator|+
literal|"where i.uniqueId=:instructorId and a in elements(i.assignments) and a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"instructorId"
argument_list|,
name|instructor
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
name|assignments
init|=
name|q
operator|.
name|iterate
argument_list|()
decl_stmt|;
while|while
condition|(
name|assignments
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|assignments
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|commitedAssignments
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|b
init|=
operator|(
name|Assignment
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|hasIntersection
argument_list|(
name|b
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|&&
operator|!
name|shareRooms
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|messages
operator|.
name|addElement
argument_list|(
literal|"Class "
operator|+
name|a
operator|.
name|getClassName
argument_list|()
operator|+
literal|" "
operator|+
name|a
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" overlaps with "
operator|+
name|b
operator|.
name|getClassName
argument_list|()
operator|+
literal|" "
operator|+
name|b
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" (instructor "
operator|+
name|instructor
operator|.
name|nameLastNameFirst
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|isOK
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isOK
condition|)
block|{
if|if
condition|(
name|sendNotificationPuid
operator|!=
literal|null
condition|)
name|sendNotification
argument_list|(
name|uncommittedSolution
argument_list|,
name|this
argument_list|,
name|sendNotificationPuid
argument_list|,
literal|false
argument_list|,
name|messages
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 		SolverInfoDef defJenrlInfo = SolverInfoDef.findByName(hibSession,"JenrlInfo"); 		Hashtable solverInfos = new Hashtable(); 		AssignmentDAO adao = new AssignmentDAO();  		q = hibSession.createQuery( 				"select a.uniqueId, oa.uniqueId, count(*) from "+ 				"Solution s inner join s.assignments a inner join s.studentEnrollments as e, "+ 				"Solution os inner join os.assignments oa inner join os.studentEnrollments as oe "+ 				"where "+ 				"s.uniqueId=:solutionId and os.owner.session.uniqueId=:sessionId and os.owner.uniqueId!=:ownerId and "+ 				"a.clazz=e.clazz and oa.clazz=oe.clazz and a.clazz.schedulingSubpart!=oa.clazz.schedulingSubpart and e.studentId=oe.studentId "+ 				"group by a.uniqueId, oa.uniqueId"); 		q.setLong("ownerId",getOwner().getUniqueId().longValue()); 		q.setInteger("solutionId",getUniqueId().intValue()); 		q.setLong("sessionId",getOwner().getSession().getUniqueId().longValue()); 		Iterator otherAssignments = q.iterate(); 		while (otherAssignments.hasNext()) { 			Object[] result = (Object[])otherAssignments.next(); 			Assignment assignment = adao.get((Integer)result[0],hibSession); 			Assignment otherAssignment = adao.get((Integer)result[1],hibSession); 			int jenrl = ((Number)result[2]).intValue(); 			 			if (assignment==null || otherAssignment==null || jenrl==0 || !assignment.isInConflict(otherAssignment)) continue; 			addCommitJenrl(hibSession, assignment, otherAssignment, jenrl, defJenrlInfo, solverInfos);         }	 		 		for (Iterator i=solverInfos.values().iterator();i.hasNext();) { 			SolverInfo sInfo = (SolverInfo)i.next(); 			hibSession.saveOrUpdate(sInfo); 		} 		*/
name|setCommitDate
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
name|setCommited
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|createDivSecNumbers
argument_list|(
name|hibSession
argument_list|,
name|messages
argument_list|)
expr_stmt|;
name|EventContact
name|contact
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|sendNotificationPuid
operator|!=
literal|null
condition|)
block|{
name|contact
operator|=
name|EventContact
operator|.
name|findByExternalUniqueId
argument_list|(
name|sendNotificationPuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|contact
operator|==
literal|null
condition|)
block|{
name|TimetableManager
name|manager
init|=
name|TimetableManager
operator|.
name|findByExternalId
argument_list|(
name|sendNotificationPuid
argument_list|)
decl_stmt|;
name|contact
operator|=
operator|new
name|EventContact
argument_list|()
expr_stmt|;
name|contact
operator|.
name|setFirstName
argument_list|(
name|manager
operator|.
name|getFirstName
argument_list|()
argument_list|)
expr_stmt|;
name|contact
operator|.
name|setMiddleName
argument_list|(
name|manager
operator|.
name|getMiddleName
argument_list|()
argument_list|)
expr_stmt|;
name|contact
operator|.
name|setLastName
argument_list|(
name|manager
operator|.
name|getLastName
argument_list|()
argument_list|)
expr_stmt|;
name|contact
operator|.
name|setExternalUniqueId
argument_list|(
name|manager
operator|.
name|getExternalUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|contact
operator|.
name|setEmailAddress
argument_list|(
name|manager
operator|.
name|getEmailAddress
argument_list|()
argument_list|)
expr_stmt|;
name|contact
operator|.
name|setPhone
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|save
argument_list|(
name|contact
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|getAssignments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
name|a
operator|.
name|generateCommittedEvent
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|!=
literal|null
condition|)
block|{
name|event
operator|.
name|setMainContact
argument_list|(
name|contact
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|save
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendNotificationPuid
operator|!=
literal|null
condition|)
name|sendNotification
argument_list|(
name|uncommittedSolution
argument_list|,
name|this
argument_list|,
name|sendNotificationPuid
argument_list|,
literal|true
argument_list|,
name|messages
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|void
name|sendNotification
parameter_list|(
name|Solution
name|uncommittedSolution
parameter_list|,
name|Solution
name|committedSolution
parameter_list|,
name|String
name|puid
parameter_list|,
name|boolean
name|success
parameter_list|,
name|Vector
name|messages
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
operator|!
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
operator|(
name|String
operator|)
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.notif.commit.enabled"
argument_list|,
literal|"true"
argument_list|)
argument_list|)
condition|)
return|return;
comment|//email notification disabled
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"MM/dd/yy hh:mmaa"
argument_list|)
decl_stmt|;
name|SolverGroup
name|owner
init|=
operator|(
name|uncommittedSolution
operator|==
literal|null
condition|?
name|committedSolution
else|:
name|uncommittedSolution
operator|)
operator|.
name|getOwner
argument_list|()
decl_stmt|;
name|String
name|subject
init|=
literal|"Solution "
operator|+
operator|(
name|committedSolution
operator|!=
literal|null
condition|?
name|uncommittedSolution
operator|!=
literal|null
condition|?
literal|"recommitted"
else|:
literal|"committed"
else|:
literal|"uncommitted"
operator|)
operator|+
literal|" for "
operator|+
name|owner
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|subject
operator|=
literal|"Failed to "
operator|+
operator|(
name|committedSolution
operator|!=
literal|null
condition|?
name|uncommittedSolution
operator|!=
literal|null
condition|?
literal|"recommit"
else|:
literal|"commit"
else|:
literal|"uncommit"
operator|)
operator|+
literal|" a solution for "
operator|+
name|owner
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|String
name|mail
init|=
name|subject
decl_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
if|if
condition|(
name|messages
operator|!=
literal|null
operator|&&
operator|!
name|messages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|mail
operator|+=
literal|"Message(s): ----------------- \r\n"
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|messages
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|m
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|mail
operator|+=
name|m
operator|+
literal|"\r\n"
expr_stmt|;
block|}
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
block|}
if|if
condition|(
name|committedSolution
operator|!=
literal|null
condition|)
block|{
name|mail
operator|+=
literal|"Committed solution info: -------------- \r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Created: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
name|committedSolution
operator|.
name|getCreated
argument_list|()
argument_list|)
operator|+
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Owner: "
operator|+
name|committedSolution
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
if|if
condition|(
name|committedSolution
operator|.
name|getCommitDate
argument_list|()
operator|!=
literal|null
condition|)
name|mail
operator|+=
literal|"Commited: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
name|committedSolution
operator|.
name|getCommitDate
argument_list|()
argument_list|)
operator|+
literal|"\r\n"
expr_stmt|;
if|if
condition|(
name|committedSolution
operator|.
name|getNote
argument_list|()
operator|!=
literal|null
operator|&&
name|committedSolution
operator|.
name|getNote
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|mail
operator|+=
literal|"Note: "
operator|+
name|committedSolution
operator|.
name|getNote
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
name|PropertiesInfo
name|globalInfo
init|=
operator|(
name|PropertiesInfo
operator|)
name|committedSolution
operator|.
name|getInfo
argument_list|(
literal|"GlobalInfo"
argument_list|)
decl_stmt|;
name|Vector
name|infos
init|=
operator|new
name|Vector
argument_list|(
name|globalInfo
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|infos
argument_list|,
operator|new
name|InfoComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|infos
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|String
name|value
init|=
operator|(
name|String
operator|)
name|globalInfo
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mail
operator|+=
name|key
operator|+
literal|": "
operator|+
name|value
operator|+
literal|"\r\n"
expr_stmt|;
block|}
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
block|}
if|if
condition|(
name|uncommittedSolution
operator|!=
literal|null
condition|)
block|{
name|mail
operator|+=
literal|"Uncommitted solution info: -------------- \r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Created: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
name|uncommittedSolution
operator|.
name|getCreated
argument_list|()
argument_list|)
operator|+
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Owner: "
operator|+
name|uncommittedSolution
operator|.
name|getOwner
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
if|if
condition|(
name|uncommittedSolution
operator|.
name|getNote
argument_list|()
operator|!=
literal|null
operator|&&
name|uncommittedSolution
operator|.
name|getNote
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|mail
operator|+=
literal|"Note: "
operator|+
name|uncommittedSolution
operator|.
name|getNote
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
name|PropertiesInfo
name|globalInfo
init|=
operator|(
name|PropertiesInfo
operator|)
name|uncommittedSolution
operator|.
name|getInfo
argument_list|(
literal|"GlobalInfo"
argument_list|)
decl_stmt|;
name|Vector
name|infos
init|=
operator|new
name|Vector
argument_list|(
name|globalInfo
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|infos
argument_list|,
operator|new
name|InfoComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|infos
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|String
name|value
init|=
operator|(
name|String
operator|)
name|globalInfo
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mail
operator|+=
name|key
operator|+
literal|": "
operator|+
name|value
operator|+
literal|"\r\n"
expr_stmt|;
block|}
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
block|}
name|TimetableManager
name|mgr
init|=
name|TimetableManager
operator|.
name|findByExternalId
argument_list|(
name|puid
argument_list|)
decl_stmt|;
name|Session
name|session
init|=
name|owner
operator|.
name|getSession
argument_list|()
decl_stmt|;
name|mail
operator|+=
literal|"Manager info -------------- \r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Name: "
operator|+
name|mgr
operator|.
name|getName
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
comment|//mail += "PUID: "+mgr.getPuid()+"\r\n";
name|mail
operator|+=
literal|"Email: "
operator|+
name|mgr
operator|.
name|getEmailAddress
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Session info -------------- \r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Session Term: "
operator|+
name|owner
operator|.
name|getSession
argument_list|()
operator|.
name|getAcademicYearTerm
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Session Initiative: "
operator|+
name|owner
operator|.
name|getSession
argument_list|()
operator|.
name|getAcademicInitiative
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Departments (from solver group): \r\n"
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|owner
operator|.
name|getDepartments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Department
name|d
init|=
operator|(
name|Department
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|mail
operator|+=
literal|"  "
operator|+
name|d
operator|.
name|getLabel
argument_list|()
operator|+
literal|"\r\n"
expr_stmt|;
block|}
name|mail
operator|+=
literal|"\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Application info -------------- \r\n"
expr_stmt|;
name|mail
operator|+=
literal|"Version: "
operator|+
name|Constants
operator|.
name|VERSION
operator|+
literal|"."
operator|+
name|Constants
operator|.
name|BLD_NUMBER
operator|+
literal|" ("
operator|+
name|Constants
operator|.
name|REL_DATE
operator|+
literal|")\r\n"
expr_stmt|;
name|mail
operator|+=
literal|"TimeStamp: "
operator|+
operator|(
operator|new
name|Date
argument_list|()
operator|)
expr_stmt|;
name|Email
name|email
init|=
operator|new
name|Email
argument_list|()
decl_stmt|;
name|email
operator|.
name|sendMail
argument_list|(
operator|(
name|String
operator|)
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.smtp.host"
argument_list|,
literal|"smtp.purdue.edu"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.smtp.domain"
argument_list|,
literal|"smtp.purdue.edu"
argument_list|)
argument_list|,
operator|(
name|String
operator|)
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.inquiry.sender"
argument_list|,
literal|"smasops@purdue.edu"
argument_list|)
argument_list|,
name|mgr
operator|.
name|getEmailAddress
argument_list|()
argument_list|,
operator|(
name|String
operator|)
name|ApplicationProperties
operator|.
name|getProperty
argument_list|(
literal|"tmtbl.inquiry.email"
argument_list|,
literal|"smasops@purdue.edu"
argument_list|)
argument_list|,
literal|"Timetabling (Solution commit): "
operator|+
name|subject
argument_list|,
name|mail
argument_list|,
operator|new
name|Vector
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|sLog
operator|.
name|error
argument_list|(
literal|"Unable to send solution commit/uncommit notification, reason: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|export
parameter_list|(
name|CSVFile
name|file
parameter_list|,
name|User
name|user
parameter_list|)
block|{
name|String
name|instructorFormat
init|=
name|Settings
operator|.
name|getSettingValue
argument_list|(
name|user
argument_list|,
name|Constants
operator|.
name|SETTINGS_INSTRUCTOR_NAME_FORMAT
argument_list|)
decl_stmt|;
name|file
operator|.
name|setSeparator
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|file
operator|.
name|setQuotationMark
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|isCommited
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|file
operator|.
name|setHeader
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
literal|"COURSE"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"ITYPE"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SECTION"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SUFFIX"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"DIV-SEC"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"DATE_PATTERN"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"DAY"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"START_TIME"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"END_TIME"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"ROOM"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"INSTRUCTOR"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SCHEDULE_NOTE"
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|.
name|setHeader
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
literal|"COURSE"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"ITYPE"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SECTION"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SUFFIX"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"DATE_PATTERN"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"DAY"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"START_TIME"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"END_TIME"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"ROOM"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"INSTRUCTOR"
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|"SCHEDULE_NOTE"
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
name|Vector
name|assignments
init|=
operator|new
name|Vector
argument_list|(
name|getAssignments
argument_list|()
argument_list|)
decl_stmt|;
name|assignments
operator|.
name|addAll
argument_list|(
name|getOwner
argument_list|()
operator|.
name|getNotAssignedClasses
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|assignments
argument_list|,
operator|new
name|ClassOrAssignmentComparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|assignments
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Assignment
condition|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|o
decl_stmt|;
name|Class_
name|clazz
init|=
name|assignment
operator|.
name|getClazz
argument_list|()
decl_stmt|;
name|Vector
name|leads
init|=
name|clazz
operator|.
name|getLeadInstructors
argument_list|()
decl_stmt|;
name|StringBuffer
name|leadsSb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|leads
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|leadsSb
operator|.
name|append
argument_list|(
name|instructor
operator|.
name|getName
argument_list|(
name|instructorFormat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
name|leadsSb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
name|Placement
name|placement
init|=
name|assignment
operator|.
name|getPlacement
argument_list|()
decl_stmt|;
if|if
condition|(
name|isCommited
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|file
operator|.
name|addLine
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getCourseName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getItypeDesc
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSectionNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getDivSecNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getDayHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getStartTimeHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getEndTimeHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getRoomName
argument_list|(
literal|","
argument_list|)
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|leadsSb
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|.
name|addLine
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getCourseName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getItypeDesc
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSectionNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getDayHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getStartTimeHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getTimeLocation
argument_list|()
operator|.
name|getEndTimeHeader
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|placement
operator|.
name|getRoomName
argument_list|(
literal|","
argument_list|)
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|leadsSb
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|o
decl_stmt|;
name|Vector
name|leads
init|=
name|clazz
operator|.
name|getLeadInstructors
argument_list|()
decl_stmt|;
name|StringBuffer
name|leadsSb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|leads
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|DepartmentalInstructor
name|instructor
init|=
operator|(
name|DepartmentalInstructor
operator|)
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|leadsSb
operator|.
name|append
argument_list|(
name|instructor
operator|.
name|getName
argument_list|(
name|instructorFormat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|)
name|leadsSb
operator|.
name|append
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isCommited
argument_list|()
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|file
operator|.
name|addLine
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getCourseName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getItypeDesc
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSectionNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getDivSecNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|leadsSb
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|.
name|addLine
argument_list|(
operator|new
name|CSVField
index|[]
block|{
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getCourseName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getItypeDesc
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSectionNumber
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartSuffix
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|effectiveDatePattern
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
literal|""
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|leadsSb
argument_list|)
block|,
operator|new
name|CSVField
argument_list|(
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|clazz
operator|.
name|getSchedulePrintNote
argument_list|()
argument_list|)
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|ClassOrAssignmentComparator
implements|implements
name|Comparator
block|{
name|ClassComparator
name|cc
init|=
operator|new
name|ClassComparator
argument_list|(
name|ClassComparator
operator|.
name|COMPARE_BY_HIERARCHY
argument_list|)
decl_stmt|;
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|==
literal|null
operator|||
name|o2
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|Class_
name|c1
init|=
operator|(
name|o1
operator|instanceof
name|Class_
condition|?
operator|(
name|Class_
operator|)
name|o1
else|:
operator|(
operator|(
name|Assignment
operator|)
name|o1
operator|)
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
name|Class_
name|c2
init|=
operator|(
name|o2
operator|instanceof
name|Class_
condition|?
operator|(
name|Class_
operator|)
name|o2
else|:
operator|(
operator|(
name|Assignment
operator|)
name|o2
operator|)
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
return|return
name|cc
operator|.
name|compare
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|deleteObjects
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|String
name|objectName
parameter_list|,
name|String
name|idQuery
parameter_list|)
block|{
name|Iterator
name|idIterator
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
name|idQuery
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|iterate
argument_list|()
decl_stmt|;
name|StringBuffer
name|ids
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|idIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ids
operator|.
name|append
argument_list|(
name|idIterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|100
condition|)
block|{
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete "
operator|+
name|objectName
operator|+
literal|" as x where x.uniqueId in ("
operator|+
name|ids
operator|+
literal|")"
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|ids
operator|=
operator|new
name|StringBuffer
argument_list|()
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
if|else if
condition|(
name|idIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ids
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete "
operator|+
name|objectName
operator|+
literal|" as x where x.uniqueId in ("
operator|+
name|ids
operator|+
literal|")"
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|delete
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
comment|// NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 		Iterator i = hibSession.createQuery( 				"select distinct c, oa from "+ 				"ConstraintInfo c inner join c.assignments a, Assignment oa "+ 				"where "+ 				"a.solution.uniqueId=:solutionId and oa.solution.uniqueId!=:solutionId and oa in elements ( c.assignments) ") 				.setInteger("solutionId",getUniqueId().intValue()) 				.iterate(); 		while (i.hasNext()) { 			Object[] next = (Object[])i.next(); 			ConstraintInfo c = (ConstraintInfo)next[0]; 			Assignment oa = (Assignment)next[1]; 			oa.getConstraintInfo().remove(c); 			hibSession.saveOrUpdate(oa); 		} 		*/
try|try
block|{
name|SolutionInfo
name|solutionInfo
init|=
name|getSolutionInfo
argument_list|(
literal|"CBSInfo"
argument_list|)
decl_stmt|;
if|if
condition|(
name|solutionInfo
operator|!=
literal|null
condition|)
name|solutionInfo
operator|.
name|delete
argument_list|(
name|hibSession
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Debug
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete StudentEnrollment x where x.solution.uniqueId=:solutionId "
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete JointEnrollment x where x.solution.uniqueId=:solutionId "
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"Event"
argument_list|,
literal|"select e.uniqueId from Event e inner join e.relatedCourses r, Assignment a where "
operator|+
literal|"r.ownerId=a.clazz.uniqueId and r.ownerType="
operator|+
name|ExamOwner
operator|.
name|sOwnerTypeClass
operator|+
literal|" and e.eventType.reference='"
operator|+
name|EventType
operator|.
name|sEventTypeClass
operator|+
literal|"' and "
operator|+
literal|"a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select a.uniqueId from AssignmentInfo a where a.assignment.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select s.uniqueId from SolutionInfo s where s.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select c.uniqueId from ConstraintInfo c inner join c.assignments a where a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete Assignment x where x.solution.uniqueId=:solutionId "
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverParameter"
argument_list|,
literal|"select p.uniqueId from Solution s inner join s.parameters p where s.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|delete
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|empty
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|TimetableInfoFileProxy
name|proxy
parameter_list|)
block|{
comment|// NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 		Iterator i = hibSession.createQuery( 				"select distinct c, oa from "+ 				"ConstraintInfo c inner join c.assignments a, Assignment oa "+ 				"where "+ 				"a.solution.uniqueId=:solutionId and oa.solution.uniqueId!=:solutionId and oa in elements ( c.assignments) ") 				.setInteger("solutionId",getUniqueId().intValue()) 				.iterate(); 		while (i.hasNext()) { 			Object[] next = (Object[])i.next(); 			ConstraintInfo c = (ConstraintInfo)next[0]; 			Assignment oa = (Assignment)next[1]; 			oa.getConstraintInfo().remove(c); 			hibSession.saveOrUpdate(oa); 		} 		*/
try|try
block|{
name|SolutionInfo
name|solutionInfo
init|=
name|getSolutionInfo
argument_list|(
literal|"CBSInfo"
argument_list|)
decl_stmt|;
if|if
condition|(
name|solutionInfo
operator|!=
literal|null
condition|)
name|solutionInfo
operator|.
name|delete
argument_list|(
name|hibSession
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Debug
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete StudentEnrollment x where x in "
operator|+
literal|" ( select s from StudentEnrollment s where s.solution.uniqueId=:solutionId ) "
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete JointEnrollment x where x in "
operator|+
literal|" ( select j from JointEnrollment j where j.solution.uniqueId=:solutionId ) "
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"Event"
argument_list|,
literal|"select e.uniqueId from Event e inner join e.relatedCourses r, Assignment a where "
operator|+
literal|"r.ownerId=a.clazz.uniqueId and r.ownerType="
operator|+
name|ExamOwner
operator|.
name|sOwnerTypeClass
operator|+
literal|" and e.eventType.reference='"
operator|+
name|EventType
operator|.
name|sEventTypeClass
operator|+
literal|"' and "
operator|+
literal|"a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select a.uniqueId from AssignmentInfo a where a.assignment.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select s.uniqueId from SolutionInfo s where s.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverInfo"
argument_list|,
literal|"select c.uniqueId from ConstraintInfo c inner join c.assignments a where a.solution.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"delete Assignment x where x in "
operator|+
literal|" ( select a from Assignment a where a.solution.uniqueId=:solutionId ) "
argument_list|)
operator|.
name|setInteger
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
operator|.
name|executeUpdate
argument_list|()
expr_stmt|;
name|deleteObjects
argument_list|(
name|hibSession
argument_list|,
literal|"SolverParameter"
argument_list|,
literal|"select p.uniqueId from Solution s inner join s.parameters p where s.uniqueId=:solutionId"
argument_list|)
expr_stmt|;
name|setAssignments
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setSolutionInfo
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setJointEnrollments
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setStudentEnrollments
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setParameters
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|saveOrUpdate
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|flush
argument_list|()
expr_stmt|;
name|hibSession
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|updateCommittedStudentEnrollmentInfos
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
throws|throws
name|Exception
block|{
name|SolutionInfo
name|sInfo
init|=
name|getSolutionInfo
argument_list|(
literal|"GlobalInfo"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sInfo
operator|!=
literal|null
condition|)
block|{
name|PropertiesInfo
name|propInfo
init|=
operator|(
name|PropertiesInfo
operator|)
name|sInfo
operator|.
name|getInfo
argument_list|()
decl_stmt|;
name|String
name|conf
init|=
name|propInfo
operator|.
name|getProperty
argument_list|(
literal|"Student conflicts"
argument_list|)
decl_stmt|;
name|int
name|studentConf
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|conf
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|conf
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|indexOf
argument_list|(
literal|"committed:"
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|commitedStart
init|=
name|conf
operator|.
name|indexOf
argument_list|(
literal|"committed:"
argument_list|)
operator|+
literal|"committed:"
operator|.
name|length
argument_list|()
decl_stmt|;
name|int
name|commitedEnd
init|=
name|conf
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|commitedStart
argument_list|)
decl_stmt|;
name|int
name|commitedConf
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|conf
operator|.
name|substring
argument_list|(
name|commitedStart
argument_list|,
name|commitedEnd
argument_list|)
argument_list|)
decl_stmt|;
comment|//String newConf = (studentConf-commitedConf)+" [committed:"+0+conf.substring(commitedEnd);
name|String
name|newConf
init|=
operator|(
name|studentConf
operator|-
name|commitedConf
operator|)
operator|+
literal|" ["
operator|+
name|conf
operator|.
name|substring
argument_list|(
name|commitedEnd
operator|+
literal|2
argument_list|)
decl_stmt|;
name|propInfo
operator|.
name|setProperty
argument_list|(
literal|"Student conflicts"
argument_list|,
name|newConf
argument_list|)
expr_stmt|;
block|}
name|sInfo
operator|.
name|setInfo
argument_list|(
name|propInfo
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|saveOrUpdate
argument_list|(
name|sInfo
argument_list|)
expr_stmt|;
block|}
comment|//NOTE: In order to decrease the amount of interaction between solutions persistance of committed student conflicts was disabled
comment|/* 		if (getAssignments()!=null) { 			for (Iterator i=getAssignments().iterator();i.hasNext();) { 				Assignment a = (Assignment)i.next(); 				for (Iterator j=a.getAssignmentInfo().iterator();j.hasNext();) { 					AssignmentInfo aInfo = (AssignmentInfo)j.next(); 					if (!"AssignmentInfo".equals(aInfo.getDefinition().getName())) continue; 					AssignmentPreferenceInfo assignmentInfo = (AssignmentPreferenceInfo)aInfo.getInfo(); 					assignmentInfo.setNrStudentConflicts(assignmentInfo.getNrStudentConflicts()-assignmentInfo.getNrCommitedStudentConflicts()); 					assignmentInfo.setNrCommitedStudentConflicts(0); 					aInfo.setInfo(assignmentInfo); 					hibSession.saveOrUpdate(aInfo); 				} 				for (Iterator j=a.getConstraintInfos("JenrlInfo").iterator();j.hasNext();) { 					ConstraintInfo c = (ConstraintInfo)j.next(); 					boolean isCommittedInfo = false; 					for (Iterator k=c.getAssignments().iterator();k.hasNext();) { 						Assignment oa = (Assignment)k.next(); 						if (!oa.getSolution().equals(this)) { 							oa.getConstraintInfo().remove(c); 							hibSession.saveOrUpdate(oa); 							isCommittedInfo = true; 						} 					} 					if (isCommittedInfo) { 						a.getConstraintInfo().remove(c); 						hibSession.saveOrUpdate(a); 						hibSession.delete(c); 					} 				} 			} 		} 		 		SolverInfoDef defJenrlInfo = SolverInfoDef.findByName(hibSession,"JenrlInfo"); 		Hashtable solverInfos = new Hashtable(); 		AssignmentDAO adao = new AssignmentDAO();  		Query q = hibSession.createQuery( 				"select a.uniqueId, oa.uniqueId, count(*) from "+ 				"Solution s inner join s.assignments a inner join s.studentEnrollments as e, "+ 				"Solution os inner join os.assignments oa inner join os.studentEnrollments as oe "+ 				"where "+ 				"s.uniqueId=:solutionId and os.owner.session.uniqueId=:sessionId and os.owner.uniqueId!=:ownerId and os.commited=true and "+ 				"a.clazz=e.clazz and oa.clazz=oe.clazz and a.clazz.schedulingSubpart!=oa.clazz.schedulingSubpart and e.studentId=oe.studentId "+ 				"group by a.uniqueId, oa.uniqueId"); 		q.setLong("ownerId",getOwner().getUniqueId().longValue()); 		q.setInteger("solutionId",getUniqueId().intValue()); 		q.setLong("sessionId",getOwner().getSession().getUniqueId().longValue()); 		Iterator otherAssignments = q.iterate(); 		while (otherAssignments.hasNext()) { 			Object[] result = (Object[])otherAssignments.next(); 			Assignment assignment = adao.get((Integer)result[0],hibSession); 			Assignment otherAssignment = adao.get((Integer)result[1],hibSession); 			int jenrl = ((Number)result[2]).intValue(); 			 			if (assignment==null || otherAssignment==null || jenrl==0 || !assignment.isInConflict(otherAssignment)) continue; 			addCommitJenrl(hibSession, otherAssignment, assignment, jenrl, defJenrlInfo, solverInfos);         } 		 		for (Iterator i=solverInfos.values().iterator();i.hasNext();) { 			SolverInfo solverInfo = (SolverInfo)i.next(); 			hibSession.saveOrUpdate(solverInfo); 		} 		*/
block|}
specifier|public
name|Session
name|getSession
parameter_list|()
block|{
return|return
name|getOwner
argument_list|()
operator|.
name|getSession
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|Collection
name|findBySessionId
parameter_list|(
name|Long
name|sessionId
parameter_list|)
block|{
return|return
operator|(
operator|new
name|SolutionDAO
argument_list|()
operator|)
operator|.
name|getSession
argument_list|()
operator|.
name|createQuery
argument_list|(
literal|"select s from Solution s where s.owner.session.uniqueId=:sessionId"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|sessionId
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
comment|//setCacheable(true).
name|list
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|Collection
name|findBySessionIdAndManagerId
parameter_list|(
name|Long
name|sessionId
parameter_list|,
name|Long
name|managerId
parameter_list|)
block|{
return|return
operator|(
operator|new
name|SolutionDAO
argument_list|()
operator|)
operator|.
name|getSession
argument_list|()
operator|.
name|createQuery
argument_list|(
literal|"select s from Solution s inner join s.owner sg inner join sg.timetableManagers m where sg.session.uniqueId=:sessionId and m.uniqueId=:managerId"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"sessionId"
argument_list|,
name|sessionId
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"managerId"
argument_list|,
name|managerId
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
comment|//setCacheable(true).
name|list
argument_list|()
return|;
block|}
specifier|private
name|HashSet
name|takenDivisionNumbers
parameter_list|(
name|SchedulingSubpart
name|subpart
parameter_list|)
block|{
name|HashSet
name|divNums
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|InstructionalOffering
name|offering
init|=
name|subpart
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
decl_stmt|;
name|ItypeDesc
name|itype
init|=
name|subpart
operator|.
name|getItype
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|offering
operator|.
name|getInstrOfferingConfigs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstrOfferingConfig
name|cfg
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|cfg
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|s
init|=
operator|(
name|SchedulingSubpart
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|getItype
argument_list|()
operator|.
name|equals
argument_list|(
name|itype
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Iterator
name|k
init|=
name|s
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|Integer
name|divNum
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|divNums
operator|.
name|add
argument_list|(
name|divNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|divNums
return|;
block|}
specifier|public
name|void
name|createDivSecNumbers
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|,
name|Vector
name|messages
parameter_list|)
block|{
name|Vector
name|assignments
init|=
operator|new
name|Vector
argument_list|(
name|getAssignments
argument_list|()
argument_list|)
decl_stmt|;
name|assignments
operator|.
name|addAll
argument_list|(
operator|new
name|SolutionDAO
argument_list|()
operator|.
name|getSession
argument_list|()
operator|.
name|createQuery
argument_list|(
literal|"select distinct c from Class_ c, Solution s inner join s.owner.departments d "
operator|+
literal|"where s.uniqueId = :solutionId and c.managingDept=d and "
operator|+
literal|"c.uniqueId not in (select a.clazz.uniqueId from s.assignments a)"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|list
argument_list|()
argument_list|)
expr_stmt|;
name|HashSet
name|relatedOfferings
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|assignments
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
name|relatedOfferings
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|relatedOfferings
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstructionalOffering
name|io
init|=
operator|(
name|InstructionalOffering
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|io
operator|.
name|getInstrOfferingConfigs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstrOfferingConfig
name|ioc
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|k
init|=
name|ioc
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|l
init|=
name|subpart
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|l
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|l
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|getOwner
argument_list|()
operator|.
name|getDepartments
argument_list|()
operator|.
name|contains
argument_list|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
argument_list|)
condition|)
block|{
name|Assignment
name|assignment
init|=
name|clazz
operator|.
name|getCommittedAssignment
argument_list|()
decl_stmt|;
name|assignments
operator|.
name|add
argument_list|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Object
operator|)
name|clazz
else|:
operator|(
name|Object
operator|)
name|assignment
argument_list|)
expr_stmt|;
name|clazz
operator|.
name|setClassSuffix
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|DivSecAssignmentComparator
name|cmp
init|=
operator|new
name|DivSecAssignmentComparator
argument_list|(
name|this
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|assignments
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|Assignment
name|lastAssignment
init|=
literal|null
decl_stmt|;
name|SchedulingSubpart
name|lastSubpart
init|=
literal|null
decl_stmt|;
name|Class_
name|lastClazz
init|=
literal|null
decl_stmt|;
name|int
name|divNum
init|=
literal|1
decl_stmt|,
name|secNum
init|=
literal|0
decl_stmt|;
name|HashSet
name|takenDivNums
init|=
literal|null
decl_stmt|;
name|HashSet
name|recompute
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|assignments
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
operator|&&
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|lastSubpart
operator|==
literal|null
operator|||
operator|!
name|lastSubpart
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
block|{
name|takenDivNums
operator|=
name|takenDivisionNumbers
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
literal|null
expr_stmt|;
name|lastSubpart
operator|=
literal|null
expr_stmt|;
name|lastClazz
operator|=
literal|null
expr_stmt|;
block|}
name|int
name|nrClasses
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getNrClasses
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|lastAssignment
operator|!=
literal|null
operator|&&
name|assignment
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nrClasses
operator|>=
literal|100
operator|&&
name|cmp
operator|.
name|compareTimeLocations
argument_list|(
name|lastAssignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|assignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|lastAssignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|assignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lastClazz
operator|!=
literal|null
operator|&&
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|equals
argument_list|(
name|lastClazz
operator|.
name|getParentClass
argument_list|()
argument_list|)
operator|&&
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getDivSecNumber
argument_list|()
operator|!=
literal|null
operator|&&
name|lastClazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getDivSecNumber
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cmp
operator|.
name|compareTimeLocations
argument_list|(
name|lastAssignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|assignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|lastAssignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|assignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|==
literal|0
operator|&&
name|clazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getDivSecNumber
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|.
name|equals
argument_list|(
name|lastClazz
operator|.
name|getParentClass
argument_list|()
operator|.
name|getDivSecNumber
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
condition|)
block|{
name|secNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|secNum
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|lastClazz
operator|!=
literal|null
condition|)
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|=
literal|1
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|divNum
operator|==
literal|100
operator|&&
name|secNum
operator|==
literal|1
condition|)
block|{
name|sLog
operator|.
name|warn
argument_list|(
literal|"Division number exceeded 99 for scheduling subpart "
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartLabel
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getInstrOfferingConfigs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstrOfferingConfig
name|cfg
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|cfg
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|subpart
operator|.
name|getItype
argument_list|()
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
argument_list|)
condition|)
name|recompute
operator|.
name|add
argument_list|(
name|subpart
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|clazz
operator|.
name|setClassSuffix
argument_list|(
name|sSufixFormat
operator|.
name|format
argument_list|(
name|divNum
argument_list|)
operator|+
name|sSufixFormat
operator|.
name|format
argument_list|(
name|secNum
argument_list|)
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
name|assignment
expr_stmt|;
name|lastSubpart
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
expr_stmt|;
name|lastClazz
operator|=
name|clazz
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recompute
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HashSet
name|recompute2
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|assignments
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|recompute
operator|.
name|contains
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
block|{
name|clazz
operator|.
name|setClassSuffix
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|cmp
operator|=
operator|new
name|DivSecAssignmentComparator
argument_list|(
name|this
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|assignments
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
literal|null
expr_stmt|;
name|lastSubpart
operator|=
literal|null
expr_stmt|;
name|lastClazz
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|assignments
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|lastSubpart
operator|==
literal|null
operator|||
operator|!
name|lastSubpart
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
block|{
name|takenDivNums
operator|=
name|takenDivisionNumbers
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
literal|null
expr_stmt|;
name|lastSubpart
operator|=
literal|null
expr_stmt|;
name|lastClazz
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|lastAssignment
operator|!=
literal|null
operator|&&
name|assignment
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cmp
operator|.
name|compareTimeLocations
argument_list|(
name|lastAssignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|assignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|lastAssignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|assignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|lastClazz
operator|!=
literal|null
condition|)
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|=
literal|1
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|divNum
operator|==
literal|100
operator|&&
name|secNum
operator|==
literal|1
condition|)
block|{
name|sLog
operator|.
name|warn
argument_list|(
literal|"Division number still (fallback) exceeded 99 for scheduling subpart "
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartLabel
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
operator|.
name|getInstrOfferingConfigs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstrOfferingConfig
name|cfg
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|cfg
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|j
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|subpart
operator|.
name|getItype
argument_list|()
operator|.
name|equals
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getItype
argument_list|()
argument_list|)
condition|)
name|recompute2
operator|.
name|add
argument_list|(
name|subpart
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|clazz
operator|.
name|setClassSuffix
argument_list|(
name|sSufixFormat
operator|.
name|format
argument_list|(
name|divNum
argument_list|)
operator|+
name|sSufixFormat
operator|.
name|format
argument_list|(
name|secNum
argument_list|)
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
name|assignment
expr_stmt|;
name|lastSubpart
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
expr_stmt|;
name|lastClazz
operator|=
name|clazz
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recompute2
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Iterator
name|i
init|=
name|assignments
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|recompute2
operator|.
name|contains
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
condition|)
block|{
name|clazz
operator|.
name|setClassSuffix
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|cmp
operator|=
operator|new
name|DivSecAssignmentComparator
argument_list|(
name|this
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|assignments
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
literal|null
expr_stmt|;
name|lastSubpart
operator|=
literal|null
expr_stmt|;
name|lastClazz
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|assignments
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
control|)
block|{
name|Object
name|o
init|=
name|e
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|o
operator|instanceof
name|Assignment
condition|?
operator|(
name|Assignment
operator|)
name|o
else|:
literal|null
operator|)
decl_stmt|;
name|Class_
name|clazz
init|=
operator|(
name|assignment
operator|==
literal|null
condition|?
operator|(
name|Class_
operator|)
name|o
else|:
name|assignment
operator|.
name|getClazz
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|lastSubpart
operator|==
literal|null
operator|||
name|cmp
operator|.
name|compareSchedulingSubparts
argument_list|(
name|lastSubpart
argument_list|,
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|takenDivNums
operator|=
name|takenDivisionNumbers
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
literal|null
expr_stmt|;
name|lastSubpart
operator|=
literal|null
expr_stmt|;
name|lastClazz
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|lastAssignment
operator|!=
literal|null
operator|&&
name|assignment
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|cmp
operator|.
name|compareTimeLocations
argument_list|(
name|lastAssignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|assignment
operator|.
name|getClazz
argument_list|()
argument_list|,
name|lastAssignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|,
name|assignment
operator|.
name|getTimeLocation
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
block|}
if|else if
condition|(
name|lastClazz
operator|!=
literal|null
condition|)
block|{
name|divNum
operator|++
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
else|else
block|{
name|divNum
operator|=
literal|1
expr_stmt|;
name|secNum
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|takenDivNums
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|divNum
argument_list|)
argument_list|)
condition|)
name|divNum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|divNum
operator|==
literal|100
operator|&&
name|secNum
operator|==
literal|1
condition|)
block|{
name|messages
operator|.
name|add
argument_list|(
literal|"Division number exceeded 99 for scheduling subpart "
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartLabel
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|sLog
operator|.
name|warn
argument_list|(
literal|"Division number still (fallback2) exceeded 99 for scheduling subpart "
operator|+
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
operator|.
name|getSchedulingSubpartLabel
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
name|clazz
operator|.
name|setClassSuffix
argument_list|(
name|sSufixFormat
operator|.
name|format
argument_list|(
name|divNum
argument_list|)
operator|+
name|sSufixFormat
operator|.
name|format
argument_list|(
name|secNum
argument_list|)
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|lastAssignment
operator|=
name|assignment
expr_stmt|;
name|lastSubpart
operator|=
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
expr_stmt|;
name|lastClazz
operator|=
name|clazz
expr_stmt|;
block|}
block|}
block|}
comment|/*         lastSubpart = null;         TreeSet otherClasses = new TreeSet(new ClassComparator(ClassComparator.COMPARE_BY_HIERARCHY));         otherClasses.addAll(new SolutionDAO().getSession().createQuery(                 "select distinct c from Class_ c, Solution s inner join s.owner.departments d "+                 "where s.uniqueId = :solutionId and c.managingDept=d and "+                 "c.uniqueId not in (select a.clazz.uniqueId from s.assignments a) order by c.schedulingSubpart.uniqueId, c.sectionNumberCache").                 setLong("solutionId", getUniqueId().longValue()).                 list());                  for (Iterator i=otherClasses.iterator();i.hasNext();) {             Class_ clazz = (Class_)i.next();                          if (clazz.getParentClass()!=null&& clazz.getSchedulingSubpart().getItype().equals(clazz.getParentClass().getSchedulingSubpart().getItype()))                 continue;              if (clazz.getClassSuffix()!=null) {                 sLog.warn("This is odd, class "+clazz.getClassLabel()+" already has a div-sec number "+clazz.getClassSuffix()+".");                 continue;             }                          if (lastSubpart==null || !lastSubpart.equals(clazz.getSchedulingSubpart())) {                 takenDivNums = takenDivisionNumbers(clazz.getSchedulingSubpart());             }             divNum = 1;             while (takenDivNums.contains(new Integer(divNum)))                 divNum++;             if (divNum==100) {                 messages.add("Division number exceeded 99 for scheduling subpart "+clazz.getSchedulingSubpart().getSchedulingSubpartLabel()+".");             }             clazz.setClassSuffix(sSufixFormat.format(divNum)+sSufixFormat.format(1));             takenDivNums.add(new Integer(divNum));             lastSubpart = clazz.getSchedulingSubpart();             hibSession.update(clazz);         }         */
block|}
specifier|public
name|void
name|removeDivSecNumbers
parameter_list|(
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
parameter_list|)
block|{
name|HashSet
name|classes
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|getAssignments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|assignment
init|=
operator|(
name|Assignment
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Class_
name|clazz
init|=
name|assignment
operator|.
name|getClazz
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
operator|||
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|classes
operator|.
name|add
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
name|HashSet
name|subparts2fix
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
name|HashSet
name|classes2update
init|=
operator|new
name|HashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|classes
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|divNum
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|clazz
operator|.
name|setClassSuffix
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|subparts2fix
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
name|List
name|otherClasses
init|=
operator|new
name|SolutionDAO
argument_list|()
operator|.
name|getSession
argument_list|()
operator|.
name|createQuery
argument_list|(
literal|"select distinct c from Class_ c, Solution s inner join s.owner.departments d "
operator|+
literal|"where s.uniqueId = :solutionId and c.managingDept=d and "
operator|+
literal|"c.uniqueId not in (select a.clazz.uniqueId from s.assignments a)"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"solutionId"
argument_list|,
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|list
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|otherClasses
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|clazz
operator|.
name|setClassSuffix
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|subparts2fix
operator|.
name|add
argument_list|(
name|clazz
operator|.
name|getSchedulingSubpart
argument_list|()
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Iterator
name|i
init|=
name|subparts2fix
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|subpart
init|=
operator|(
name|SchedulingSubpart
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|TreeSet
name|takenDivNums
init|=
operator|new
name|TreeSet
argument_list|(
name|takenDivisionNumbers
argument_list|(
name|subpart
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dec
init|=
literal|0
decl_stmt|,
name|lastDiv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
name|j
init|=
name|takenDivNums
operator|.
name|iterator
argument_list|()
init|;
name|j
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|int
name|div
init|=
operator|(
operator|(
name|Integer
operator|)
name|j
operator|.
name|next
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|dec
operator|+=
operator|(
name|div
operator|-
name|lastDiv
operator|-
literal|1
operator|)
expr_stmt|;
name|lastDiv
operator|=
name|div
expr_stmt|;
if|if
condition|(
name|dec
operator|>
literal|0
condition|)
block|{
name|sLog
operator|.
name|debug
argument_list|(
name|subpart
operator|.
name|getSchedulingSubpartLabel
argument_list|()
operator|+
literal|": "
operator|+
name|div
operator|+
literal|"->"
operator|+
operator|(
name|div
operator|-
name|dec
operator|)
argument_list|)
expr_stmt|;
name|InstructionalOffering
name|offering
init|=
name|subpart
operator|.
name|getInstrOfferingConfig
argument_list|()
operator|.
name|getInstructionalOffering
argument_list|()
decl_stmt|;
name|ItypeDesc
name|itype
init|=
name|subpart
operator|.
name|getItype
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i1
init|=
name|offering
operator|.
name|getInstrOfferingConfigs
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i1
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|InstrOfferingConfig
name|cfg
init|=
operator|(
name|InstrOfferingConfig
operator|)
name|i1
operator|.
name|next
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i2
init|=
name|cfg
operator|.
name|getSchedulingSubparts
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i2
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SchedulingSubpart
name|s
init|=
operator|(
name|SchedulingSubpart
operator|)
name|i2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|.
name|getItype
argument_list|()
operator|.
name|equals
argument_list|(
name|itype
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|Iterator
name|i3
init|=
name|s
operator|.
name|getClasses
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i3
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Class_
name|clazz
init|=
operator|(
name|Class_
operator|)
name|i3
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|==
literal|null
condition|)
continue|continue;
name|int
name|clazzDivNum
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|clazzSecNum
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|clazz
operator|.
name|getClassSuffix
argument_list|()
operator|.
name|substring
argument_list|(
literal|3
argument_list|,
literal|6
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazzDivNum
operator|==
name|div
condition|)
block|{
name|clazz
operator|.
name|setClassSuffix
argument_list|(
name|sSufixFormat
operator|.
name|format
argument_list|(
name|clazzDivNum
operator|-
name|dec
argument_list|)
operator|+
name|sSufixFormat
operator|.
name|format
argument_list|(
name|clazzSecNum
argument_list|)
argument_list|)
expr_stmt|;
name|hibSession
operator|.
name|update
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
specifier|transient
name|Hashtable
name|iAssignmentTable
init|=
literal|null
decl_stmt|;
specifier|public
name|Assignment
name|getAssignment
parameter_list|(
name|Long
name|classId
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|iAssignmentTable
operator|==
literal|null
condition|)
block|{
name|iAssignmentTable
operator|=
operator|new
name|Hashtable
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|getAssignments
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Assignment
name|a
init|=
operator|(
name|Assignment
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|iAssignmentTable
operator|.
name|put
argument_list|(
name|a
operator|.
name|getClassId
argument_list|()
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|Assignment
operator|)
name|iAssignmentTable
operator|.
name|get
argument_list|(
name|classId
argument_list|)
return|;
block|}
specifier|public
name|Assignment
name|getAssignment
parameter_list|(
name|Class_
name|clazz
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|getOwner
argument_list|()
operator|.
name|getDepartments
argument_list|()
operator|.
name|contains
argument_list|(
name|clazz
operator|.
name|getManagingDept
argument_list|()
argument_list|)
condition|)
return|return
name|clazz
operator|.
name|getCommittedAssignment
argument_list|()
return|;
return|return
name|getAssignment
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|AssignmentPreferenceInfo
name|getAssignmentInfo
parameter_list|(
name|Class_
name|clazz
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|getAssignmentInfo
argument_list|(
name|clazz
operator|.
name|getUniqueId
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|AssignmentPreferenceInfo
name|getAssignmentInfo
parameter_list|(
name|Long
name|classId
parameter_list|)
throws|throws
name|Exception
block|{
name|Assignment
name|a
init|=
name|getAssignment
argument_list|(
name|classId
argument_list|)
decl_stmt|;
return|return
operator|(
name|a
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AssignmentPreferenceInfo
operator|)
name|a
operator|.
name|getAssignmentInfo
argument_list|(
literal|"AssignmentInfo"
argument_list|)
operator|)
return|;
block|}
specifier|public
name|Hashtable
name|getAssignmentTable
parameter_list|(
name|Collection
name|classesOrClassIds
parameter_list|)
throws|throws
name|Exception
block|{
name|Hashtable
name|assignments
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|classesOrClassIds
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|classOrClassId
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Assignment
name|assignment
init|=
operator|(
name|classOrClassId
operator|instanceof
name|Class_
condition|?
name|getAssignment
argument_list|(
operator|(
name|Class_
operator|)
name|classOrClassId
argument_list|)
else|:
name|getAssignment
argument_list|(
operator|(
name|Long
operator|)
name|classOrClassId
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|assignment
operator|!=
literal|null
condition|)
name|assignments
operator|.
name|put
argument_list|(
name|classOrClassId
operator|instanceof
name|Class_
condition|?
operator|(
operator|(
name|Class_
operator|)
name|classOrClassId
operator|)
operator|.
name|getUniqueId
argument_list|()
else|:
operator|(
name|Long
operator|)
name|classOrClassId
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
block|}
return|return
name|assignments
return|;
block|}
specifier|public
name|Hashtable
name|getAssignmentInfoTable
parameter_list|(
name|Collection
name|classesOrClassIds
parameter_list|)
throws|throws
name|Exception
block|{
name|Hashtable
name|infos
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|classesOrClassIds
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|classOrClassId
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|AssignmentPreferenceInfo
name|info
init|=
operator|(
name|classOrClassId
operator|instanceof
name|Class_
condition|?
name|getAssignmentInfo
argument_list|(
operator|(
name|Class_
operator|)
name|classOrClassId
argument_list|)
else|:
name|getAssignmentInfo
argument_list|(
operator|(
name|Long
operator|)
name|classOrClassId
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
name|infos
operator|.
name|put
argument_list|(
name|classOrClassId
operator|instanceof
name|Class_
condition|?
operator|(
operator|(
name|Class_
operator|)
name|classOrClassId
operator|)
operator|.
name|getUniqueId
argument_list|()
else|:
operator|(
name|Long
operator|)
name|classOrClassId
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|infos
return|;
block|}
specifier|private
specifier|transient
name|DataProperties
name|iPropertiesCache
init|=
literal|null
decl_stmt|;
specifier|public
specifier|synchronized
name|DataProperties
name|getProperties
parameter_list|()
block|{
if|if
condition|(
name|iPropertiesCache
operator|==
literal|null
condition|)
block|{
name|iPropertiesCache
operator|=
operator|new
name|DataProperties
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|getParameters
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SolverParameter
name|p
init|=
operator|(
name|SolverParameter
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|iPropertiesCache
operator|.
name|setProperty
argument_list|(
name|p
operator|.
name|getDefinition
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|p
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|iPropertiesCache
return|;
block|}
specifier|public
specifier|static
name|void
name|refreshSolution
parameter_list|(
name|Long
name|solutionId
parameter_list|)
block|{
name|SolutionDAO
name|dao
init|=
operator|new
name|SolutionDAO
argument_list|()
decl_stmt|;
name|org
operator|.
name|hibernate
operator|.
name|Session
name|hibSession
init|=
name|dao
operator|.
name|getSession
argument_list|()
decl_stmt|;
name|SessionFactory
name|hibSessionFactory
init|=
name|hibSession
operator|.
name|getSessionFactory
argument_list|()
decl_stmt|;
name|hibSessionFactory
operator|.
name|evict
argument_list|(
name|Solution
operator|.
name|class
argument_list|,
name|solutionId
argument_list|)
expr_stmt|;
name|hibSessionFactory
operator|.
name|evictCollection
argument_list|(
name|Solution
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".parameters"
argument_list|,
name|solutionId
argument_list|)
expr_stmt|;
name|hibSessionFactory
operator|.
name|evictCollection
argument_list|(
name|Solution
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".assignments"
argument_list|,
name|solutionId
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|hibSession
operator|.
name|createQuery
argument_list|(
literal|"select c.uniqueId from "
operator|+
literal|"Class_ c, Solution s where s.uniqueId=:solutionId and "
operator|+
literal|"c.managingDept.uniqueId in (s.owner.departments.uniqueId)"
argument_list|)
operator|.
name|setLong
argument_list|(
literal|"solutionId"
argument_list|,
name|solutionId
operator|.
name|longValue
argument_list|()
argument_list|)
operator|.
name|iterate
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Number
name|classId
init|=
operator|(
name|Number
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|hibSession
operator|.
name|getSessionFactory
argument_list|()
operator|.
name|evict
argument_list|(
name|Class_
operator|.
name|class
argument_list|,
name|classId
argument_list|)
expr_stmt|;
name|hibSessionFactory
operator|.
name|evictCollection
argument_list|(
name|Class_
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".assignments"
argument_list|,
name|classId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

