begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * UniTime 3.2 (University Timetabling Application)  * Copyright (C) 2008 - 2010, UniTime LLC, and individual contributors  * as indicated by the @authors tag.  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 3 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License along  * with this program.  If not, see<http://www.gnu.org/licenses/>.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|model
package|;
end_package

begin_import
import|import
name|java
operator|.
name|awt
operator|.
name|Color
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|unitime
operator|.
name|timetable
operator|.
name|webutil
operator|.
name|RequiredTimeTableModel
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|model
operator|.
name|TimeLocation
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|preference
operator|.
name|MinMaxPreferenceCombination
import|;
end_import

begin_import
import|import
name|net
operator|.
name|sf
operator|.
name|cpsolver
operator|.
name|coursett
operator|.
name|preference
operator|.
name|PreferenceCombination
import|;
end_import

begin_class
specifier|public
class|class
name|TimePatternModel
implements|implements
name|RequiredTimeTableModel
block|{
specifier|private
name|TimePattern
name|iTimePattern
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|iDefaultSelection
init|=
literal|0
decl_stmt|;
specifier|protected
name|String
name|iDays
index|[]
init|=
literal|null
decl_stmt|;
specifier|protected
name|int
name|iDayCodes
index|[]
init|=
literal|null
decl_stmt|;
specifier|protected
name|int
name|iMinutes
index|[]
init|=
literal|null
decl_stmt|;
specifier|protected
name|String
name|iPreferences
index|[]
index|[]
decl_stmt|;
specifier|protected
name|String
name|iPref
init|=
literal|null
decl_stmt|;
specifier|protected
name|boolean
name|iAllowHard
init|=
literal|true
decl_stmt|;
specifier|protected
name|int
name|iBreakTime
init|=
literal|0
decl_stmt|;
specifier|protected
name|TimeLocation
name|iAssignment
init|=
literal|null
decl_stmt|;
specifier|protected
name|TimePatternModel
parameter_list|(
name|TimePattern
name|pattern
parameter_list|,
name|TimeLocation
name|assignment
parameter_list|,
name|boolean
name|allowHard
parameter_list|)
block|{
name|iTimePattern
operator|=
name|pattern
expr_stmt|;
name|iAssignment
operator|=
name|assignment
expr_stmt|;
name|iAllowHard
operator|=
name|allowHard
expr_stmt|;
name|iBreakTime
operator|=
operator|(
name|pattern
operator|==
literal|null
condition|?
literal|0
else|:
name|pattern
operator|.
name|getBreakTime
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|iTimePattern
operator|==
literal|null
operator|||
name|iTimePattern
operator|.
name|getUniqueId
argument_list|()
operator|==
literal|null
operator|||
name|iTimePattern
operator|.
name|getUniqueId
argument_list|()
operator|.
name|longValue
argument_list|()
operator|<
literal|0
condition|)
block|{
name|iTimePattern
operator|=
literal|null
expr_stmt|;
name|iDays
operator|=
operator|new
name|String
index|[
name|Constants
operator|.
name|NR_DAYS
index|]
expr_stmt|;
name|iDayCodes
operator|=
operator|new
name|int
index|[
name|Constants
operator|.
name|NR_DAYS
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|NR_DAYS
condition|;
name|i
operator|++
control|)
block|{
name|iDayCodes
index|[
name|i
index|]
operator|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
expr_stmt|;
name|iDays
index|[
name|i
index|]
operator|=
name|Constants
operator|.
name|DAY_NAME
index|[
name|i
index|]
expr_stmt|;
block|}
name|iMinutes
operator|=
operator|new
name|int
index|[
name|Constants
operator|.
name|SLOTS_PER_DAY
operator|/
literal|6
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|SLOTS_PER_DAY
operator|/
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|iMinutes
index|[
name|i
index|]
operator|=
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|+
operator|(
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|*
literal|6
operator|*
name|i
operator|)
expr_stmt|;
block|}
name|iPreferences
operator|=
operator|new
name|String
index|[
name|Constants
operator|.
name|NR_DAYS
index|]
index|[
name|Constants
operator|.
name|SLOTS_PER_DAY
operator|/
literal|6
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iPreferences
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iPreferences
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|PreferenceLevel
operator|.
name|sNeutral
expr_stmt|;
block|}
else|else
block|{
name|Vector
name|days
init|=
operator|new
name|Vector
argument_list|(
name|pattern
operator|.
name|getDays
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|days
argument_list|)
expr_stmt|;
name|iDays
operator|=
operator|new
name|String
index|[
name|days
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|iDayCodes
operator|=
operator|new
name|int
index|[
name|days
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|days
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|dayCode
init|=
operator|(
operator|(
name|TimePatternDays
operator|)
name|e
operator|.
name|nextElement
argument_list|()
operator|)
operator|.
name|getDayCode
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|iDayCodes
index|[
name|idx
index|]
operator|=
name|dayCode
expr_stmt|;
name|iDays
index|[
name|idx
index|]
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
operator|&
name|dayCode
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pattern
operator|.
name|getNrMeetings
argument_list|()
operator|.
name|intValue
argument_list|()
operator|<=
literal|1
condition|)
name|iDays
index|[
name|idx
index|]
operator|+=
name|Constants
operator|.
name|DAY_NAME
index|[
name|i
index|]
expr_stmt|;
else|else
name|iDays
index|[
name|idx
index|]
operator|+=
name|Constants
operator|.
name|DAY_NAMES_SHORT
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|Vector
name|times
init|=
operator|new
name|Vector
argument_list|(
name|pattern
operator|.
name|getTimes
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|times
argument_list|)
expr_stmt|;
name|iMinutes
operator|=
operator|new
name|int
index|[
name|times
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Enumeration
name|e
init|=
name|times
operator|.
name|elements
argument_list|()
init|;
name|e
operator|.
name|hasMoreElements
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|startSlot
init|=
operator|(
operator|(
name|TimePatternTime
operator|)
name|e
operator|.
name|nextElement
argument_list|()
operator|)
operator|.
name|getStartSlot
argument_list|()
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|iMinutes
index|[
name|idx
index|]
operator|=
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|+
operator|(
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|*
name|startSlot
operator|)
expr_stmt|;
block|}
name|iPreferences
operator|=
operator|new
name|String
index|[
name|days
operator|.
name|size
argument_list|()
index|]
index|[
name|times
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iPreferences
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iPreferences
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|PreferenceLevel
operator|.
name|sNeutral
expr_stmt|;
block|}
block|}
comment|/** 1x30 time pattern */
specifier|protected
name|TimePatternModel
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TimePattern
name|getTimePattern
parameter_list|()
block|{
return|return
name|iTimePattern
return|;
block|}
specifier|public
name|int
name|getNrMeetings
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
name|Constants
operator|.
name|NR_DAYS
else|:
name|iTimePattern
operator|.
name|getNrMeetings
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
return|;
block|}
specifier|public
name|int
name|getSlotsPerMtg
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
literal|6
else|:
name|iTimePattern
operator|.
name|getSlotsPerMtg
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
return|;
block|}
specifier|public
name|int
name|getMinPerMtg
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
literal|6
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
else|:
name|iTimePattern
operator|.
name|getMinPerMtg
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
return|;
block|}
specifier|public
name|int
name|getType
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
name|TimePattern
operator|.
name|sTypeStandard
else|:
name|iTimePattern
operator|.
name|getType
argument_list|()
operator|.
name|intValue
argument_list|()
operator|)
return|;
block|}
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
literal|null
else|:
name|iTimePattern
operator|.
name|getName
argument_list|()
operator|)
return|;
block|}
specifier|public
name|int
name|getDayCode
parameter_list|(
name|int
name|day
parameter_list|)
block|{
return|return
name|iDayCodes
index|[
name|day
index|]
return|;
block|}
specifier|public
name|String
name|getDayHeader
parameter_list|(
name|int
name|day
parameter_list|)
block|{
return|return
name|iDays
index|[
name|day
index|]
return|;
block|}
specifier|public
name|int
name|getHour
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|iMinutes
index|[
name|time
index|]
operator|/
literal|60
return|;
block|}
specifier|public
name|int
name|getMinute
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|iMinutes
index|[
name|time
index|]
operator|%
literal|60
return|;
block|}
specifier|public
name|int
name|getNrDays
parameter_list|()
block|{
return|return
name|iDays
operator|.
name|length
return|;
block|}
specifier|public
name|int
name|getNrTimes
parameter_list|()
block|{
return|return
name|iMinutes
operator|.
name|length
return|;
block|}
specifier|public
name|String
name|getPreference
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
return|return
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
return|;
block|}
specifier|public
name|String
name|getStartTime
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|Constants
operator|.
name|toTime
argument_list|(
name|iMinutes
index|[
name|time
index|]
argument_list|)
return|;
block|}
specifier|public
name|String
name|getEndTime
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|Constants
operator|.
name|toTime
argument_list|(
name|iMinutes
index|[
name|time
index|]
operator|+
name|getSlotsPerMtg
argument_list|()
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|-
name|iBreakTime
argument_list|)
return|;
block|}
specifier|public
name|String
name|getTimeHeaderShort
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|Constants
operator|.
name|toTime
argument_list|(
name|iMinutes
index|[
name|time
index|]
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|int
name|slot2min
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
return|return
operator|(
name|slot
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|+
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|%
literal|60
return|;
block|}
specifier|public
specifier|static
name|int
name|slot2hour
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
return|return
operator|(
name|slot
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|+
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|/
literal|60
return|;
block|}
specifier|public
specifier|static
name|int
name|time2slot
parameter_list|(
name|int
name|hour
parameter_list|,
name|int
name|min
parameter_list|)
block|{
return|return
operator|(
name|hour
operator|*
literal|60
operator|+
name|min
operator|)
operator|/
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|-
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
return|;
block|}
specifier|public
name|void
name|setDefaults
parameter_list|(
name|User
name|user
parameter_list|)
throws|throws
name|Exception
block|{
name|long
name|startMin
init|=
literal|7
operator|*
literal|60
operator|+
literal|30
decl_stmt|;
name|long
name|endMin
init|=
operator|(
name|getMinPerMtg
argument_list|()
operator|<=
literal|90
condition|?
literal|16
operator|*
literal|60
operator|+
literal|30
else|:
name|getMinPerMtg
argument_list|()
operator|<=
literal|120
condition|?
literal|15
operator|*
literal|60
operator|+
literal|30
else|:
literal|15
operator|*
literal|60
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|iMinutes
index|[
name|j
index|]
operator|<=
name|startMin
condition|?
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
else|:
name|iMinutes
index|[
name|j
index|]
operator|>=
name|endMin
condition|?
name|PreferenceLevel
operator|.
name|sDiscouraged
else|:
name|PreferenceLevel
operator|.
name|sNeutral
operator|)
expr_stmt|;
block|}
specifier|public
name|boolean
name|setPreferenceUsingDayCodeStartSlot
parameter_list|(
name|int
name|dayCode
parameter_list|,
name|int
name|startSlot
parameter_list|,
name|String
name|pref
parameter_list|)
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
block|{
name|iPref
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|dayCode
argument_list|)
operator|+
literal|","
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|startSlot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|true
operator|)
return|;
block|}
else|else
block|{
name|int
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|time
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDayCodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iDayCodes
index|[
name|i
index|]
operator|==
name|dayCode
condition|)
block|{
name|day
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|+
operator|(
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|*
name|startSlot
operator|)
operator|)
operator|==
name|iMinutes
index|[
name|i
index|]
condition|)
block|{
name|time
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|time
operator|<
literal|0
operator|||
name|day
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|false
operator|)
return|;
block|}
else|else
block|{
name|setPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|,
name|pref
argument_list|)
expr_stmt|;
return|return
operator|(
literal|true
operator|)
return|;
block|}
block|}
block|}
specifier|public
name|void
name|setPreference
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|,
name|PreferenceLevel
name|pref
parameter_list|)
block|{
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
operator|=
name|pref
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setPreference
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|,
name|String
name|prefProlog
parameter_list|)
block|{
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
operator|=
name|prefProlog
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|PreferenceLevel
operator|.
name|sNeutral
expr_stmt|;
block|}
specifier|public
name|Vector
name|getSlots
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
name|Vector
name|slots
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|int
name|dayCode
init|=
name|iDayCodes
index|[
name|day
index|]
decl_stmt|;
name|int
name|slot
init|=
name|getStartSlot
argument_list|(
name|time
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dayCode
operator|&
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|int
name|s
init|=
name|slot
operator|+
name|i
operator|*
name|Constants
operator|.
name|SLOTS_PER_DAY
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|getSlotsPerMtg
argument_list|()
condition|;
name|j
operator|++
control|)
name|slots
operator|.
name|addElement
argument_list|(
operator|new
name|Integer
argument_list|(
name|s
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|slots
return|;
block|}
specifier|public
name|int
name|getStartSlot
parameter_list|(
name|int
name|time
parameter_list|)
block|{
return|return
name|time2slot
argument_list|(
literal|0
argument_list|,
name|iMinutes
index|[
name|time
index|]
argument_list|)
return|;
block|}
specifier|public
name|java
operator|.
name|util
operator|.
name|Collection
name|getStartSlots
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
name|Vector
name|slots
init|=
operator|new
name|Vector
argument_list|()
decl_stmt|;
name|int
name|dayCode
init|=
name|iDayCodes
index|[
name|day
index|]
decl_stmt|;
name|int
name|slot
init|=
name|getStartSlot
argument_list|(
name|time
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dayCode
operator|&
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|slots
operator|.
name|addElement
argument_list|(
operator|new
name|Integer
argument_list|(
name|slot
operator|+
name|i
operator|*
name|Constants
operator|.
name|SLOTS_PER_DAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|slots
return|;
block|}
specifier|public
name|String
name|getText
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
return|return
name|getDayHeader
argument_list|(
name|day
argument_list|)
operator|+
literal|" "
operator|+
name|getTimeHeaderShort
argument_list|(
name|time
argument_list|)
return|;
block|}
specifier|public
name|String
name|getPreferences
parameter_list|()
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
return|return
name|iPref
return|;
name|StringBuffer
name|pref
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|pref
operator|.
name|append
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2char
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pref
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|String
name|xChars
init|=
literal|"0123456789abcdefghijklmnopqrstuvwxyz -"
decl_stmt|;
specifier|public
name|String
name|getPreferencesHex
parameter_list|()
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
return|return
name|iPref
return|;
name|int
index|[]
name|limit
init|=
name|getSelectionLimits
argument_list|(
name|getDefaultSelection
argument_list|()
argument_list|)
decl_stmt|;
name|BigInteger
name|idn
init|=
operator|new
name|BigInteger
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PreferenceLevel
argument_list|>
name|prefs
init|=
name|PreferenceLevel
operator|.
name|getPreferenceLevelList
argument_list|()
decl_stmt|;
name|BigInteger
name|mx
init|=
operator|new
name|BigInteger
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|prefs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
name|limit
index|[
literal|2
index|]
init|;
name|d
operator|<=
name|limit
index|[
literal|3
index|]
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
name|limit
index|[
literal|0
index|]
init|;
name|t
operator|<=
name|limit
index|[
literal|1
index|]
condition|;
name|t
operator|++
control|)
block|{
name|BigInteger
name|add
init|=
operator|new
name|BigInteger
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|prefs
operator|.
name|indexOf
argument_list|(
name|PreferenceLevel
operator|.
name|getPreferenceLevel
argument_list|(
name|getPreference
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|idn
operator|=
name|idn
operator|.
name|multiply
argument_list|(
name|mx
argument_list|)
operator|.
name|add
argument_list|(
name|add
argument_list|)
expr_stmt|;
block|}
name|StringBuffer
name|s
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|BigInteger
name|radix
init|=
operator|new
name|BigInteger
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|xChars
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|idn
operator|.
name|bitLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|int
name|x
init|=
name|idn
operator|.
name|mod
argument_list|(
name|radix
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|idn
operator|=
name|idn
operator|.
name|divide
argument_list|(
name|radix
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|xChars
operator|.
name|charAt
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|setPreferences
parameter_list|(
name|String
name|pref
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
block|{
name|iPref
operator|=
name|pref
expr_stmt|;
block|}
else|else
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|pref
operator|==
literal|null
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|PreferenceLevel
operator|.
name|char2prolog
argument_list|(
name|pref
operator|.
name|charAt
argument_list|(
name|idx
operator|++
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IndexOutOfBoundsException
name|e
parameter_list|)
block|{
block|}
block|}
specifier|public
specifier|static
name|double
name|sDefaultDecreaseFactor
init|=
literal|0.77
decl_stmt|;
specifier|public
name|String
name|getFieldText
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|round
argument_list|(
name|getNormalizedPreference
argument_list|(
name|day
argument_list|,
name|time
argument_list|,
name|sDefaultDecreaseFactor
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|double
name|getNormalizedPreference
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|,
name|double
name|decreaseFactor
parameter_list|)
block|{
if|if
condition|(
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
condition|)
return|return
literal|100.0
return|;
name|int
name|pref
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|iPreferences
index|[
name|day
index|]
index|[
name|time
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|pref
operator|==
literal|0
condition|)
return|return
literal|0.0
return|;
name|double
name|nrOfPreferences
init|=
literal|0
decl_stmt|;
comment|// case A -- constant increment (except of 1x50, where 1/2 is taken)
name|double
name|increment
init|=
operator|(
name|getMinPerMtg
argument_list|()
operator|<=
literal|30
condition|?
literal|0.5
else|:
literal|1.0
operator|)
decl_stmt|;
comment|//case B -- proportional increment
comment|//double increment = 10.0/getNrTimes();
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|nrOfPreferencesThisDay
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|p
init|=
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equalsIgnoreCase
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equalsIgnoreCase
argument_list|(
name|p
argument_list|)
operator|||
name|Integer
operator|.
name|parseInt
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|nrOfPreferencesThisDay
operator|+=
name|increment
expr_stmt|;
block|}
name|nrOfPreferences
operator|=
name|Math
operator|.
name|max
argument_list|(
name|nrOfPreferences
argument_list|,
name|nrOfPreferencesThisDay
argument_list|)
expr_stmt|;
block|}
comment|//double norm = Math.max(1.0,Math.round(11.0 - nrOfPreferences));
name|double
name|norm
init|=
name|Math
operator|.
name|max
argument_list|(
literal|1.0
argument_list|,
name|Math
operator|.
name|round
argument_list|(
literal|10.0
operator|*
name|Math
operator|.
name|pow
argument_list|(
name|decreaseFactor
argument_list|,
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|nrOfPreferences
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|sign
init|=
operator|(
name|pref
operator|<
literal|0
condition|?
operator|-
literal|1.0
else|:
literal|1.0
operator|)
decl_stmt|;
name|double
name|mux
init|=
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|pref
argument_list|)
operator|==
literal|1
condition|?
literal|1.0
else|:
literal|4.0
operator|)
decl_stmt|;
return|return
name|sign
operator|*
name|norm
operator|*
name|mux
return|;
block|}
specifier|public
name|int
name|countPreferences
parameter_list|(
name|String
name|prologPref
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
name|prologPref
argument_list|)
condition|)
name|ret
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|public
name|boolean
name|isDefault
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|equals
argument_list|(
name|getDefaultPreference
argument_list|()
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Assignment
name|assignment
parameter_list|)
block|{
if|if
condition|(
name|assignment
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|startSlots
index|[]
init|=
name|assignment
operator|.
name|getStartSlots
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|day
init|=
literal|0
init|;
name|day
operator|<
name|iDays
operator|.
name|length
condition|;
name|day
operator|++
control|)
block|{
for|for
control|(
name|int
name|time
init|=
literal|0
init|;
name|time
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|time
operator|++
control|)
block|{
name|int
name|slot
init|=
name|getStartSlot
argument_list|(
name|time
argument_list|)
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|boolean
name|equal
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|equal
operator|&&
operator|(
name|i
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|iDayCodes
index|[
name|day
index|]
operator|&
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
operator|)
operator|==
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
condition|)
block|{
name|int
name|s
init|=
name|slot
operator|+
operator|(
name|i
operator|*
name|Constants
operator|.
name|SLOTS_PER_DAY
operator|)
decl_stmt|;
if|if
condition|(
name|startSlots
index|[
name|j
index|]
operator|!=
name|s
condition|)
block|{
name|equal
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|equal
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|long
name|getTime
parameter_list|(
name|int
name|time
parameter_list|)
block|{
name|Calendar
name|cal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|cal
operator|.
name|clear
argument_list|()
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
name|iMinutes
index|[
name|time
index|]
operator|/
literal|60
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
name|iMinutes
index|[
name|time
index|]
operator|%
literal|60
argument_list|)
expr_stmt|;
return|return
name|cal
operator|.
name|getTimeInMillis
argument_list|()
return|;
block|}
specifier|public
name|void
name|setInOldFormat
parameter_list|(
name|String
name|inDays
parameter_list|,
name|Date
name|startTime
parameter_list|,
name|Date
name|endTime
parameter_list|,
name|PreferenceLevel
name|pref
parameter_list|)
block|{
name|int
name|days
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|inDays
argument_list|,
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|days
operator|&
name|iDayCodes
index|[
name|i
index|]
operator|)
operator|==
name|iDayCodes
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|endTime
operator|==
literal|null
operator|)
operator|&&
operator|(
name|startTime
operator|.
name|getTime
argument_list|()
operator|==
name|getTime
argument_list|(
name|j
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|endTime
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|startTime
operator|.
name|getTime
argument_list|()
operator|<=
name|getTime
argument_list|(
name|j
argument_list|)
operator|)
operator|&&
operator|(
name|endTime
operator|.
name|getTime
argument_list|()
operator|>=
name|getTime
argument_list|(
name|j
argument_list|)
operator|)
operator|)
condition|)
block|{
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|pref
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
block|{
if|if
condition|(
name|iPref
operator|==
literal|null
condition|)
return|return
literal|"not set"
return|;
name|int
name|days
init|=
name|getExactDays
argument_list|()
decl_stmt|;
name|int
name|startSlot
init|=
name|getExactStartSlot
argument_list|()
decl_stmt|;
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
operator|&
name|days
operator|)
operator|!=
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|DAY_NAMES_SHORT
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|toTime
argument_list|(
name|startSlot
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|+
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
name|boolean
name|canMergeDays
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|canMergeDays
operator|&&
name|i
operator|+
literal|1
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|canMergeDays
operator|&&
name|j
operator|<
name|iDays
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|iDayCodes
index|[
name|i
index|]
operator|&
name|iDayCodes
index|[
name|j
index|]
operator|)
operator|!=
literal|0
condition|)
name|canMergeDays
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|boolean
name|out
index|[]
index|[]
init|=
operator|new
name|boolean
index|[
name|iDays
operator|.
name|length
index|]
index|[
name|iMinutes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
name|out
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDays
operator|.
name|length
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|out
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
continue|continue;
name|out
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sNeutral
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
name|int
name|endDay
init|=
name|i
decl_stmt|,
name|endTime
init|=
name|j
decl_stmt|;
while|while
condition|(
name|endTime
operator|+
literal|1
operator|<
name|iMinutes
operator|.
name|length
operator|&&
operator|!
name|out
index|[
name|i
index|]
index|[
name|endTime
operator|+
literal|1
index|]
operator|&&
name|iPreferences
index|[
name|i
index|]
index|[
name|endTime
operator|+
literal|1
index|]
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
condition|)
name|endTime
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|boolean
name|same
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
name|i
init|;
name|k
operator|+
literal|1
operator|<
name|iDays
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|int
name|x
init|=
name|j
init|;
name|x
operator|<=
name|endTime
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|out
index|[
name|k
operator|+
literal|1
index|]
index|[
name|x
index|]
operator|&&
operator|!
name|iPreferences
index|[
name|i
index|]
index|[
name|x
index|]
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|k
operator|+
literal|1
index|]
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|same
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|same
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|same
condition|)
break|break;
block|}
if|if
condition|(
name|same
condition|)
name|endDay
operator|=
name|iDays
operator|.
name|length
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|canMergeDays
operator|&&
name|endDay
operator|+
literal|1
operator|<
name|iDays
operator|.
name|length
condition|)
block|{
name|boolean
name|same
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
name|j
init|;
name|x
operator|<=
name|endTime
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|!
name|out
index|[
name|endDay
operator|+
literal|1
index|]
index|[
name|x
index|]
operator|&&
operator|!
name|iPreferences
index|[
name|i
index|]
index|[
name|x
index|]
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|endDay
operator|+
literal|1
index|]
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|same
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|same
condition|)
break|break;
name|endDay
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|a
init|=
name|i
init|;
name|a
operator|<=
name|endDay
condition|;
name|a
operator|++
control|)
for|for
control|(
name|int
name|b
init|=
name|j
init|;
name|b
operator|<=
name|endTime
condition|;
name|b
operator|++
control|)
name|out
index|[
name|a
index|]
index|[
name|b
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2abbv
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
name|int
name|nrDays
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
name|boolean
name|thisDay
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
name|i
init|;
name|a
operator|<=
name|endDay
condition|;
name|a
operator|++
control|)
if|if
condition|(
operator|(
name|iDayCodes
index|[
name|a
index|]
operator|&
name|Constants
operator|.
name|DAY_CODES
index|[
name|x
index|]
operator|)
operator|!=
literal|0
condition|)
name|thisDay
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|thisDay
condition|)
name|nrDays
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|x
init|=
literal|0
init|;
name|x
operator|<
name|Constants
operator|.
name|DAY_CODES
operator|.
name|length
condition|;
name|x
operator|++
control|)
block|{
name|boolean
name|thisDay
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
name|i
init|;
name|a
operator|<=
name|endDay
condition|;
name|a
operator|++
control|)
if|if
condition|(
operator|(
name|iDayCodes
index|[
name|a
index|]
operator|&
name|Constants
operator|.
name|DAY_CODES
index|[
name|x
index|]
operator|)
operator|!=
literal|0
condition|)
name|thisDay
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|thisDay
condition|)
name|sb
operator|.
name|append
argument_list|(
name|nrDays
operator|==
literal|1
condition|?
name|Constants
operator|.
name|DAY_NAME
index|[
name|x
index|]
else|:
name|Constants
operator|.
name|DAY_NAMES_SHORT
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iTimePattern
operator|!=
literal|null
operator|&&
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" MTWThF"
argument_list|)
condition|)
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|7
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|iTimePattern
operator|==
literal|null
operator|&&
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|" MTWThFSSu"
argument_list|)
condition|)
name|sb
operator|.
name|delete
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|10
argument_list|,
name|sb
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|endTime
operator|+
literal|1
operator|==
name|iMinutes
operator|.
name|length
condition|)
block|{
comment|//all day
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|toTime
argument_list|(
name|iMinutes
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Constants
operator|.
name|toTime
argument_list|(
name|iMinutes
index|[
name|endTime
index|]
operator|+
name|getSlotsPerMtg
argument_list|()
operator|*
name|Constants
operator|.
name|SLOT_LENGTH_MIN
operator|-
name|iBreakTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|public
name|boolean
name|isExactTime
parameter_list|()
block|{
return|return
name|getType
argument_list|()
operator|==
name|TimePattern
operator|.
name|sTypeExactTime
return|;
block|}
specifier|public
name|int
name|getExactDays
parameter_list|()
block|{
if|if
condition|(
name|iPref
operator|==
literal|null
operator|||
name|iPref
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|iPref
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|iPref
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|int
name|getExactStartSlot
parameter_list|()
block|{
if|if
condition|(
name|iPref
operator|==
literal|null
operator|||
name|iPref
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|iPref
operator|.
name|substring
argument_list|(
name|iPref
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|setExactDays
parameter_list|(
name|int
name|days
parameter_list|)
block|{
name|iPref
operator|=
name|days
operator|+
literal|","
operator|+
name|getExactStartSlot
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setExactStartSlot
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
name|iPref
operator|=
name|getExactDays
argument_list|()
operator|+
literal|","
operator|+
name|slot
expr_stmt|;
block|}
specifier|public
name|boolean
name|changeRequired2Prohibited
parameter_list|()
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
return|return
literal|false
return|;
name|boolean
name|hasReq
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|)
block|{
name|hasReq
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|hasReq
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
operator|=
operator|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|PreferenceLevel
operator|.
name|sProhibited
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
name|boolean
name|changeProhibited2Required
parameter_list|()
block|{
if|if
condition|(
name|isExactTime
argument_list|()
condition|)
return|return
literal|false
return|;
name|boolean
name|hasElseThanNeutralProhibited
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
operator|&&
operator|!
name|PreferenceLevel
operator|.
name|sNeutral
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|)
block|{
name|hasElseThanNeutralProhibited
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hasElseThanNeutralProhibited
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
operator|=
operator|(
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|PreferenceLevel
operator|.
name|sRequired
operator|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|int
name|getNrSharedSlots
parameter_list|(
name|int
name|dayCode1
parameter_list|,
name|int
name|slot1
parameter_list|,
name|int
name|nrSlots1
parameter_list|,
name|int
name|dayCode2
parameter_list|,
name|int
name|slot2
parameter_list|,
name|int
name|nrSlots2
parameter_list|)
block|{
name|int
name|start
init|=
name|Math
operator|.
name|max
argument_list|(
name|slot1
argument_list|,
name|slot2
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|slot1
operator|+
name|nrSlots1
argument_list|,
name|slot2
operator|+
name|nrSlots2
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|>=
name|end
condition|)
return|return
literal|0
return|;
name|int
name|sharedTimes
init|=
name|end
operator|-
name|start
decl_stmt|;
name|int
name|sharedDays
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Constants
operator|.
name|NR_DAYS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dayCode
init|=
name|Constants
operator|.
name|DAY_CODES
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|dayCode1
operator|&
name|dayCode
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dayCode2
operator|&
name|dayCode
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|sharedDays
operator|++
expr_stmt|;
block|}
return|return
name|sharedDays
operator|*
name|sharedTimes
return|;
block|}
specifier|public
name|String
name|getCombinedPreference
parameter_list|(
name|int
name|givenDayCode
parameter_list|,
name|int
name|givenSlot
parameter_list|,
name|int
name|givenNrSlots
parameter_list|,
name|int
name|alg
parameter_list|)
block|{
name|PrefMix
name|mix
init|=
name|getMixAlg
argument_list|(
name|alg
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDayCodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dayCode
init|=
name|iDayCodes
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|int
name|min
init|=
name|iMinutes
index|[
name|j
index|]
decl_stmt|;
name|int
name|slot
init|=
operator|(
name|min
operator|-
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|/
name|Constants
operator|.
name|SLOT_LENGTH_MIN
decl_stmt|;
name|int
name|share
init|=
name|getNrSharedSlots
argument_list|(
name|dayCode
argument_list|,
name|slot
argument_list|,
name|getSlotsPerMtg
argument_list|()
argument_list|,
name|givenDayCode
argument_list|,
name|givenSlot
argument_list|,
name|givenNrSlots
argument_list|)
decl_stmt|;
if|if
condition|(
name|share
operator|>
literal|0
condition|)
name|mix
operator|.
name|addPref
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|share
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mix
operator|.
name|getPref
argument_list|()
return|;
block|}
specifier|public
name|void
name|combineWith
parameter_list|(
name|TimePatternModel
name|model
parameter_list|,
name|boolean
name|clear
parameter_list|)
block|{
name|combineWith
argument_list|(
name|model
argument_list|,
name|clear
argument_list|,
name|sMixAlgMinMax
argument_list|)
expr_stmt|;
block|}
comment|/**      * Combines preferences of two (different) time patterns into one      * @param model another model to take preferences from (to put into the current one)      * @param clear if true, preferences in current model are cleared first (it transfers preferences from the given model to the current one)      * @param alg algorithm that should be used for combining preferences (one of sMixAlgXxx constants)      */
specifier|public
name|void
name|combineWith
parameter_list|(
name|TimePatternModel
name|model
parameter_list|,
name|boolean
name|clear
parameter_list|,
name|int
name|alg
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|clear
condition|)
name|clear
argument_list|()
expr_stmt|;
else|else
name|changed
operator|=
name|changeRequired2Prohibited
argument_list|()
expr_stmt|;
name|changed
operator|=
name|model
operator|.
name|changeRequired2Prohibited
argument_list|()
operator|||
name|changed
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iDayCodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|dayCode
init|=
name|iDayCodes
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|iMinutes
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|int
name|min
init|=
name|iMinutes
index|[
name|j
index|]
decl_stmt|;
name|int
name|slot
init|=
operator|(
name|min
operator|-
name|Constants
operator|.
name|FIRST_SLOT_TIME_MIN
operator|)
operator|/
name|Constants
operator|.
name|SLOT_LENGTH_MIN
decl_stmt|;
name|String
name|pref
init|=
name|model
operator|.
name|getCombinedPreference
argument_list|(
name|dayCode
argument_list|,
name|slot
argument_list|,
name|getSlotsPerMtg
argument_list|()
argument_list|,
name|alg
argument_list|)
decl_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|pref
expr_stmt|;
block|}
else|else
block|{
name|PreferenceCombination
name|com
init|=
operator|new
name|MinMaxPreferenceCombination
argument_list|()
decl_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|null
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|pref
argument_list|)
expr_stmt|;
name|iPreferences
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|com
operator|.
name|getPreferenceProlog
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|changeProhibited2Required
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|combineMatching
parameter_list|(
name|TimePatternModel
name|model
parameter_list|)
block|{
name|combineMatching
argument_list|(
name|model
argument_list|,
literal|true
argument_list|,
name|sMixAlgFullCover
argument_list|)
expr_stmt|;
block|}
comment|/**      * Combines preferences of two (different, but matching -- see {@link TimePattern#getMatchingTimePattern(Long, TimePattern)}) time patterns into one.      * Unlike {@link TimePatternModel#combineWith(TimePatternModel, boolean, int)}, if the same field (days x time) is present in both time patterns,      * its preference is copied from one time pattern to the other. If the field is not present, its preference is computed the same way as in      * {@link TimePatternModel#combineWith(TimePatternModel, boolean, int)}.      * @param model another model to take preferences from (to put into the current one)      * @param clear if true, preferences in current model are cleared first (it transfers preferences from the given model to the current one)      * @param alg algorithm that should be used for combining preferences (one of sMixAlgXxx constants)      */
specifier|public
name|void
name|combineMatching
parameter_list|(
name|TimePatternModel
name|model
parameter_list|,
name|boolean
name|clear
parameter_list|,
name|int
name|alg
parameter_list|)
block|{
for|for
control|(
name|int
name|t1
init|=
literal|0
init|;
name|t1
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t1
operator|++
control|)
block|{
for|for
control|(
name|int
name|d1
init|=
literal|0
init|;
name|d1
operator|<
name|getNrDays
argument_list|()
condition|;
name|d1
operator|++
control|)
block|{
name|int
name|t2
init|=
operator|-
literal|1
decl_stmt|,
name|d2
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|model
operator|.
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|model
operator|.
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
name|getTime
argument_list|(
name|t1
argument_list|)
operator|==
name|model
operator|.
name|getTime
argument_list|(
name|t
argument_list|)
operator|&&
name|getDayCode
argument_list|(
name|d1
argument_list|)
operator|==
name|model
operator|.
name|getDayCode
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|t2
operator|=
name|t
expr_stmt|;
name|d2
operator|=
name|d
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|t2
operator|>=
literal|0
operator|&&
name|d2
operator|>=
literal|0
condition|)
if|if
condition|(
name|clear
condition|)
block|{
name|setPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|,
name|model
operator|.
name|getPreference
argument_list|(
name|d2
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PreferenceCombination
name|com
init|=
operator|new
name|MinMaxPreferenceCombination
argument_list|()
decl_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|getPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|)
operator|==
literal|null
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|getPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|model
operator|.
name|getPreference
argument_list|(
name|d2
argument_list|,
name|t2
argument_list|)
operator|==
literal|null
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|getPreference
argument_list|(
name|d2
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|setPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|,
name|com
operator|.
name|getPreferenceProlog
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|pref
init|=
name|model
operator|.
name|getCombinedPreference
argument_list|(
name|getDayCode
argument_list|(
name|d1
argument_list|)
argument_list|,
name|getStartSlot
argument_list|(
name|t1
argument_list|)
argument_list|,
name|getSlotsPerMtg
argument_list|()
argument_list|,
name|alg
argument_list|)
decl_stmt|;
if|if
condition|(
name|clear
condition|)
block|{
name|setPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|,
name|pref
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PreferenceCombination
name|com
init|=
operator|new
name|MinMaxPreferenceCombination
argument_list|()
decl_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|getPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|)
operator|==
literal|null
condition|?
name|PreferenceLevel
operator|.
name|sNeutral
else|:
name|getPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|)
argument_list|)
expr_stmt|;
name|com
operator|.
name|addPreferenceProlog
argument_list|(
name|pref
argument_list|)
expr_stmt|;
name|setPreference
argument_list|(
name|d1
argument_list|,
name|t1
argument_list|,
name|com
operator|.
name|getPreferenceProlog
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|public
name|void
name|weakenHardPreferences
parameter_list|()
block|{
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
block|{
name|String
name|p
init|=
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
decl_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|p
argument_list|)
condition|)
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
operator|=
name|PreferenceLevel
operator|.
name|sStronglyPreferred
expr_stmt|;
if|else if
condition|(
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|p
argument_list|)
condition|)
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
operator|=
name|PreferenceLevel
operator|.
name|sStronglyDiscouraged
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
specifier|final
name|int
name|sMixAlgAverage
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|sMixAlgSum
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|sMixAlgMinMax
init|=
literal|2
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|sMixAlgMaxUse
init|=
literal|3
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|sMixAlgFullCover
init|=
literal|4
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|sMixAlgs
init|=
operator|new
name|String
index|[]
block|{
literal|"Average"
block|,
literal|"Sum"
block|,
literal|"Min-Max"
block|,
literal|"MaxUsed"
block|,
literal|"FullCover"
block|}
decl_stmt|;
specifier|public
specifier|static
name|PrefMix
name|getMixAlg
parameter_list|(
name|int
name|algNum
parameter_list|)
block|{
switch|switch
condition|(
name|algNum
condition|)
block|{
case|case
name|sMixAlgAverage
case|:
return|return
operator|new
name|AvgPrefMix
argument_list|()
return|;
case|case
name|sMixAlgSum
case|:
return|return
operator|new
name|SumPrefMix
argument_list|()
return|;
case|case
name|sMixAlgMaxUse
case|:
return|return
operator|new
name|MaxUsagePrefMix
argument_list|()
return|;
case|case
name|sMixAlgMinMax
case|:
return|return
operator|new
name|MinMaxPrefMix
argument_list|()
return|;
case|case
name|sMixAlgFullCover
case|:
return|return
operator|new
name|FullCoverPrefMix
argument_list|()
return|;
default|default :
return|return
operator|new
name|AvgPrefMix
argument_list|()
return|;
block|}
block|}
specifier|public
specifier|static
interface|interface
name|PrefMix
block|{
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
specifier|public
name|String
name|getPref
parameter_list|()
function_decl|;
block|}
specifier|public
specifier|static
class|class
name|AvgPrefMix
implements|implements
name|PrefMix
block|{
name|int
name|iPref
init|=
literal|0
decl_stmt|,
name|iCnt
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|pref
init|=
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|prologPref
argument_list|)
decl_stmt|;
name|iPref
operator|+=
name|pref
operator|*
name|count
expr_stmt|;
name|iCnt
operator|+=
name|count
expr_stmt|;
block|}
specifier|public
name|String
name|getPref
parameter_list|()
block|{
if|if
condition|(
name|iCnt
operator|==
literal|0
condition|)
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
return|return
name|PreferenceLevel
operator|.
name|int2prolog
argument_list|(
name|Math
operator|.
name|round
argument_list|(
operator|(
operator|(
name|float
operator|)
name|iPref
operator|)
operator|/
name|iCnt
argument_list|)
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|SumPrefMix
implements|implements
name|PrefMix
block|{
name|int
name|iPref
init|=
literal|0
decl_stmt|,
name|iCnt
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|pref
init|=
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|prologPref
argument_list|)
decl_stmt|;
name|iPref
operator|+=
name|pref
operator|*
name|count
expr_stmt|;
name|iCnt
operator|+=
name|count
expr_stmt|;
block|}
specifier|public
name|String
name|getPref
parameter_list|()
block|{
if|if
condition|(
name|iCnt
operator|==
literal|0
condition|)
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
return|return
name|PreferenceLevel
operator|.
name|int2prolog
argument_list|(
name|iPref
operator|/
literal|4
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MinMaxPrefMix
implements|implements
name|PrefMix
block|{
name|int
name|iMin
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|,
name|iMax
init|=
name|Integer
operator|.
name|MIN_VALUE
decl_stmt|,
name|iCnt
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|pref
init|=
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|prologPref
argument_list|)
decl_stmt|;
name|iMin
operator|=
name|Math
operator|.
name|min
argument_list|(
name|iMin
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|iMax
operator|=
name|Math
operator|.
name|max
argument_list|(
name|iMax
argument_list|,
name|pref
argument_list|)
expr_stmt|;
name|iCnt
operator|+=
name|count
expr_stmt|;
block|}
specifier|public
name|String
name|getPref
parameter_list|()
block|{
if|if
condition|(
name|iCnt
operator|==
literal|0
condition|)
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|iMin
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|iMax
argument_list|)
condition|)
return|return
name|PreferenceLevel
operator|.
name|int2prolog
argument_list|(
name|iMin
argument_list|)
return|;
else|else
return|return
name|PreferenceLevel
operator|.
name|int2prolog
argument_list|(
name|iMax
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|MaxUsagePrefMix
implements|implements
name|PrefMix
block|{
name|Hashtable
name|iUsage
init|=
operator|new
name|Hashtable
argument_list|()
decl_stmt|;
name|int
name|iCnt
init|=
literal|0
decl_stmt|;
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Integer
name|use
init|=
operator|(
name|Integer
operator|)
name|iUsage
operator|.
name|get
argument_list|(
name|prologPref
argument_list|)
decl_stmt|;
name|use
operator|=
operator|new
name|Integer
argument_list|(
operator|(
name|use
operator|==
literal|null
condition|?
literal|0
else|:
name|use
operator|.
name|intValue
argument_list|()
operator|)
operator|+
name|count
argument_list|)
expr_stmt|;
name|iUsage
operator|.
name|put
argument_list|(
name|prologPref
argument_list|,
name|use
argument_list|)
expr_stmt|;
name|iCnt
operator|+=
name|count
expr_stmt|;
block|}
specifier|public
name|String
name|getPref
parameter_list|()
block|{
if|if
condition|(
name|iCnt
operator|==
literal|0
condition|)
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
name|int
name|bestUse
init|=
literal|0
decl_stmt|;
name|String
name|bestPref
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
name|i
init|=
name|iUsage
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
name|entry
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|pref
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|use
init|=
operator|(
operator|(
name|Integer
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|bestPref
operator|==
literal|null
operator|||
name|bestUse
operator|<
name|use
condition|)
block|{
name|bestPref
operator|=
name|pref
expr_stmt|;
name|bestUse
operator|=
name|use
expr_stmt|;
block|}
if|else if
condition|(
name|bestUse
operator|==
name|use
condition|)
block|{
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|pref
argument_list|)
argument_list|)
operator|>
name|Math
operator|.
name|abs
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|bestPref
argument_list|)
argument_list|)
condition|)
block|{
name|bestPref
operator|=
name|pref
expr_stmt|;
block|}
if|else if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|pref
argument_list|)
argument_list|)
operator|==
name|Math
operator|.
name|abs
argument_list|(
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|bestPref
argument_list|)
argument_list|)
operator|&&
name|PreferenceLevel
operator|.
name|prolog2int
argument_list|(
name|pref
argument_list|)
operator|>
literal|0
condition|)
block|{
name|bestPref
operator|=
name|pref
expr_stmt|;
block|}
block|}
block|}
return|return
name|bestPref
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|FullCoverPrefMix
implements|implements
name|PrefMix
block|{
name|String
name|iPref
init|=
literal|null
decl_stmt|;
name|boolean
name|iFullCover
init|=
literal|true
decl_stmt|;
specifier|public
name|void
name|addPref
parameter_list|(
name|String
name|prologPref
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|iPref
operator|==
literal|null
condition|)
name|iPref
operator|=
name|prologPref
expr_stmt|;
if|else if
condition|(
operator|!
name|iPref
operator|.
name|equals
argument_list|(
name|prologPref
argument_list|)
condition|)
name|iFullCover
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|String
name|getPref
parameter_list|()
block|{
if|if
condition|(
name|iPref
operator|==
literal|null
operator|||
operator|!
name|iFullCover
condition|)
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
return|return
name|iPref
return|;
block|}
block|}
specifier|public
name|String
name|getDefaultPreference
parameter_list|()
block|{
return|return
name|PreferenceLevel
operator|.
name|sNeutral
return|;
block|}
specifier|public
name|String
name|getFileName
parameter_list|()
block|{
name|StringBuffer
name|fileName
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
if|if
condition|(
name|getTimePattern
argument_list|()
operator|!=
literal|null
operator|&&
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|!=
literal|null
condition|)
name|fileName
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toHexString
argument_list|(
name|getTimePattern
argument_list|()
operator|.
name|getUniqueId
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fileName
operator|.
name|append
argument_list|(
name|getNrMeetings
argument_list|()
operator|+
literal|"x"
operator|+
name|getSlotsPerMtg
argument_list|()
argument_list|)
expr_stmt|;
name|fileName
operator|.
name|append
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|fileName
operator|.
name|append
argument_list|(
name|getPreferencesHex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getAssignment
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|fileName
operator|.
name|append
argument_list|(
literal|"_"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|getAssignment
argument_list|()
operator|.
name|getStartSlot
argument_list|()
operator|*
literal|256
operator|+
name|getAssignment
argument_list|()
operator|.
name|getDayCode
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fileName
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|TimeLocation
name|getAssignment
parameter_list|()
block|{
return|return
name|iAssignment
return|;
block|}
specifier|public
name|Color
name|getBorder
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
if|if
condition|(
name|iAssignment
operator|!=
literal|null
operator|&&
name|iAssignment
operator|.
name|getStartSlot
argument_list|()
operator|==
name|getStartSlot
argument_list|(
name|time
argument_list|)
operator|&&
name|iAssignment
operator|.
name|getDayCode
argument_list|()
operator|==
name|getDayCode
argument_list|(
name|day
argument_list|)
condition|)
return|return
operator|new
name|Color
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|242
argument_list|)
return|;
return|return
literal|null
return|;
block|}
specifier|public
name|String
index|[]
name|getPreferenceNames
parameter_list|()
block|{
name|List
argument_list|<
name|PreferenceLevel
argument_list|>
name|prefs
init|=
name|PreferenceLevel
operator|.
name|getPreferenceLevelList
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|iAllowHard
condition|)
block|{
name|boolean
name|hasRequired
init|=
literal|false
decl_stmt|,
name|hasProhibited
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|getNrDays
argument_list|()
condition|;
name|d
operator|++
control|)
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|getNrTimes
argument_list|()
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|PreferenceLevel
operator|.
name|sRequired
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|)
name|hasRequired
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|PreferenceLevel
operator|.
name|sProhibited
operator|.
name|equals
argument_list|(
name|iPreferences
index|[
name|d
index|]
index|[
name|t
index|]
argument_list|)
condition|)
name|hasProhibited
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasRequired
condition|)
name|prefs
operator|.
name|remove
argument_list|(
name|PreferenceLevel
operator|.
name|getPreferenceLevel
argument_list|(
name|PreferenceLevel
operator|.
name|sRequired
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasProhibited
condition|)
name|prefs
operator|.
name|remove
argument_list|(
name|PreferenceLevel
operator|.
name|getPreferenceLevel
argument_list|(
name|PreferenceLevel
operator|.
name|sProhibited
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|ret
init|=
operator|new
name|String
index|[
name|prefs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PreferenceLevel
name|p
range|:
name|prefs
control|)
block|{
name|ret
index|[
name|idx
operator|++
index|]
operator|=
name|p
operator|.
name|getPrefProlog
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|Color
name|getPreferenceColor
parameter_list|(
name|String
name|pref
parameter_list|)
block|{
return|return
name|PreferenceLevel
operator|.
name|prolog2awtColor
argument_list|(
name|pref
argument_list|)
return|;
block|}
specifier|public
name|String
name|getPreferenceText
parameter_list|(
name|String
name|pref
parameter_list|)
block|{
return|return
name|PreferenceLevel
operator|.
name|prolog2string
argument_list|(
name|pref
argument_list|)
return|;
block|}
specifier|public
name|int
name|getNrSelections
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
literal|5
else|:
literal|0
operator|)
return|;
block|}
specifier|public
name|String
name|getSelectionName
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"Workdays&times; Daytime"
return|;
case|case
literal|1
case|:
return|return
literal|"All Week&times; Daytime"
return|;
case|case
literal|2
case|:
return|return
literal|"Workdays&times; Evening"
return|;
case|case
literal|3
case|:
return|return
literal|"All Week&times; Evening"
return|;
case|case
literal|4
case|:
return|return
literal|"All Week&times; All Times"
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|int
index|[]
name|getSelectionLimits
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|36
block|,
literal|0
block|,
literal|4
block|}
return|;
case|case
literal|1
case|:
return|return
operator|new
name|int
index|[]
block|{
literal|15
block|,
literal|36
block|,
literal|0
block|,
literal|6
block|}
return|;
case|case
literal|2
case|:
return|return
operator|new
name|int
index|[]
block|{
literal|37
block|,
literal|47
block|,
literal|0
block|,
literal|4
block|}
return|;
case|case
literal|3
case|:
return|return
operator|new
name|int
index|[]
block|{
literal|37
block|,
literal|47
block|,
literal|0
block|,
literal|6
block|}
return|;
case|case
literal|4
case|:
return|return
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|47
block|,
literal|0
block|,
literal|6
block|}
return|;
block|}
return|return
operator|new
name|int
index|[]
block|{
literal|0
block|,
name|getNrTimes
argument_list|()
operator|-
literal|1
block|,
literal|0
block|,
name|getNrDays
argument_list|()
operator|-
literal|1
block|}
return|;
block|}
specifier|public
name|void
name|setDefaultSelection
parameter_list|(
name|int
name|selection
parameter_list|)
block|{
name|iDefaultSelection
operator|=
name|selection
expr_stmt|;
block|}
specifier|public
name|void
name|setDefaultSelection
parameter_list|(
name|String
name|selection
parameter_list|)
block|{
name|iDefaultSelection
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|selection
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|getNrSelections
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|selection
operator|.
name|equalsIgnoreCase
argument_list|(
name|getSelectionName
argument_list|(
name|i
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"&times;"
argument_list|,
literal|"x"
argument_list|)
argument_list|)
condition|)
block|{
name|iDefaultSelection
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|public
name|int
name|getDefaultSelection
parameter_list|()
block|{
return|return
operator|(
name|iTimePattern
operator|==
literal|null
condition|?
name|iDefaultSelection
else|:
operator|-
literal|1
operator|)
return|;
block|}
specifier|public
name|boolean
name|isEditable
parameter_list|(
name|int
name|day
parameter_list|,
name|int
name|time
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|getPreferenceCheck
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|boolean
name|getAllowHard
parameter_list|()
block|{
return|return
name|iAllowHard
return|;
block|}
specifier|public
name|void
name|setAllowHard
parameter_list|(
name|boolean
name|allowHard
parameter_list|)
block|{
name|iAllowHard
operator|=
name|allowHard
expr_stmt|;
block|}
specifier|public
name|boolean
name|isPreferenceEnabled
parameter_list|(
name|String
name|pref
parameter_list|)
block|{
return|return
operator|(
name|iAllowHard
operator|||
operator|!
name|PreferenceLevel
operator|.
name|getPreferenceLevel
argument_list|(
name|pref
argument_list|)
operator|.
name|isHard
argument_list|()
operator|)
return|;
block|}
specifier|public
name|int
name|getBreakTime
parameter_list|()
block|{
return|return
name|iBreakTime
return|;
block|}
block|}
end_class

end_unit

